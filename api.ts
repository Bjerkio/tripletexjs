/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Tripletex API
 * The Tripletex API is a **RESTful API**, which does not implement PATCH, but uses a PUT with optional fields.  **Actions** or commands are represented in our RESTful path with a prefixed **\":\"**. Example: **\"/v2/hours/123/:approve\"**.  **Summaries** or aggregated results are represented in our RESTful path with a prefixed **\"&gt;\"**. Example: **\"/v2/hours/&gt;thisWeeksBillables\"**.  **\"requestID\"** is a key found in all validation and error responses. If additional log information is absolutely necessary, our support division can locate the key value.  **HTTPS** is used by the entire API and will throw an error on HTTP.  **Download** the [swagger.json](/v2/swagger.json) file [OpenAPI Specification](https://github.com/OAI/OpenAPI-Specification) to [generate code](https://github.com/swagger-api/swagger-codegen). This document was generated from the Swagger JSON file.  **version:** This is a versioning number found on all DB records. If included, it will prevent your PUT/POST from overriding any updates to the record since your GET.  **Date & DateTime** follows the **ISO 8601** standard. Date: YYYY-MM-DD. DateTime: YYYY-MM-DDThh:mm:ssZ  **Sorting** is done by specifying a comma separated list, where a \"-\" prefix denotes descending. You can sort by sub object with the following format: 'project.name, -date'.  **Searching:** is done by entering values in the optional fields for each API call. The values fall into the following categories: range, in, exact and like.  **Missing fields or even no response data** can occur because result objects and fields are filtered on authorization.  **See [FAQ](https://tripletex.no/execute/docViewer?articleId=906&language=0) for more additional information.**   ##Authentication: - **Tokens:** The Tripletex API uses 3 different tokens - **consumerToken**, **employeeToken** and **sessionToken**.  - **consumerToken** is a token provided to the consumer by Tripletex after the API 2.0 registration is completed.  - **employeeToken** is a token created by an administrator in your Tripletex account via the user settings and the tab \"API access\". Each employee token must be given a set of entitlements. [Read more here.](https://tripletex.no/execute/docViewer?articleId=853&language=0)  - **sessionToken** is the token from \"/tokens/session/:create\" which requires a consumerToken and an employeeToken created with the same consumer token, but not an authentication header. See how to create a sessionToken [here](https://tripletex.no/execute/docViewer?articleId=855&language=0). - The session token is used as the password in \"Basic Authentication Header\" for API calls.  - Use blank or 0 as username for accessing the account with regular employee token, or if a company owned employee token accesses \"/company/&gt;withLoginAccess\" or \"/token/session/&gt;whoAmI\".  - For company owned employee tokens (accounting offices) the ID from \"/company/&gt;withLoginAccess\" can be used as username for accessing client accounts.  - If you need to create the header yourself use \"Authorization: Basic &lt;base64encode('0:sessionToken')&gt;\".   ##Tags: - <div class=\"tag-icon-beta\"></div> **[BETA]** This is a beta endpoint and can be subject to change. - <div class=\"tag-icon-deprecated\"></div> **[DEPRECATED]** Deprecated means that we intend to remove/change this feature or capability in a future \"major\" API release. We therefore discourage all use of this feature/capability.  ##Fields: - **project,activity,hours**  returns _{project:..., activity:...., hours:...}_. - just **project** returns _\"project\" : { \"id\": 12345, \"url\": \"tripletex.no/v2/projects/12345\"  }_. - **project(*)** returns _\"project\" : { \"id\": 12345 \"name\":\"ProjectName\" \"number.....startDate\": \"2013-01-07\" }_. - **project(name)** returns _*\"project\" : { \"name\":\"ProjectName\" }*_. - All elements and some subElements :  _*,activity(name),employee(*)_.  ##Changelog: - To get the changelog for a resource, 'changes' have to be explicitly specified as part of the fields parameter, I.E '*,changes'. - There are two types of change available:  -- 'CREATE' for when the resource was created -- 'UPDATE' for when the resource was last updated   ##Rate limiting in each response header: - **X-Rate-Limit-Limit** - The number of allowed requests in the current period. - **X-Rate-Limit-Remaining** - The number of remaining requests. - **X-Rate-Limit-Reset** - The number of seconds left in the current period.   ##Response envelope: ``` {   \"fullResultSize\": ###,   \"from\": ###, // Paging starting from   \"count\": ###, // Paging count   \"versionDigest\": \"Hash of full result\",   \"values\": [...list of objects...] } {   \"value\": {...single object...} } ```   ##WebHook envelope: ``` {   \"subscriptionId\": ###,   \"key\": \"object.verb\", // As listed from /v2/event/   \"id\": ###, // Object id   \"value\": {... single object, null if object.deleted ...} } ```    ##Error/Warning envelope: ``` {   \"status\": ###, // HTTP status code   \"code\": #####, // internal status code of event   \"message\": \"Basic feedback message in your language\",   \"link\": \"Link to doc\",   \"developerMessage\": \"More technical message\",   \"validationMessages\": [ // Will be null if Error     {       \"field\": \"Name of field\",       \"message\": \"Validation failure information\"     }   ],   \"requestId\": \"UUID used in any logs\" } ```   ##Status codes / Error codes: - **200 OK** - **201 Created** - From POSTs that create something new. - **204 No Content** - When there is no answer, ex: \"/:anAction\" or DELETE. - **400 Bad request** -   - **4000** Bad Request Exception   - **11000** Illegal Filter Exception   - **12000** Path Param Exception   - **24000**   Cryptography Exception - **401 Unauthorized** - When authentication is required and has failed or has not yet been provided   -  **3000** Authentication Exception   -  **9000** Security Exception - **403 Forbidden** - When AuthorisationManager says no. - **404 Not Found** - For content/IDs that does not exist.   -  **6000** Not Found Exception - **409 Conflict** - Such as an edit conflict between multiple simultaneous updates   -  **7000** Object Exists Exception   -  **8000** Revision Exception   - **10000** Locked Exception   - **14000** Duplicate entry - **422 Bad Request** - For Required fields or things like malformed payload.   - **15000** Value Validation Exception   - **16000** Mapping Exception   - **17000** Sorting Exception   - **18000** Validation Exception   - **21000** Param Exception   - **22000** Invalid JSON Exception   - **23000**   Result Set Too Large Exception - **500 Internal Error** -  Unexpected condition was encountered and no more specific message is suitable   -  **1000** Exception
 *
 * OpenAPI spec version: 2.15.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://tripletex.no/v2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AbstractDTO
 */
export interface AbstractDTO {
    /**
     * 
     * @type {string}
     * @memberof AbstractDTO
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof AbstractDTO
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface AccommodationAllowance
 */
export interface AccommodationAllowance {
    /**
     * 
     * @type {number}
     * @memberof AccommodationAllowance
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof AccommodationAllowance
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof AccommodationAllowance
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof AccommodationAllowance
     */
    url?: string;
    /**
     * 
     * @type {TravelExpense}
     * @memberof AccommodationAllowance
     */
    travelExpense?: TravelExpense;
    /**
     * 
     * @type {TravelExpenseRate}
     * @memberof AccommodationAllowance
     */
    rateType?: TravelExpenseRate;
    /**
     * 
     * @type {TravelExpenseRateCategory}
     * @memberof AccommodationAllowance
     */
    rateCategory?: TravelExpenseRateCategory;
    /**
     * 
     * @type {string}
     * @memberof AccommodationAllowance
     */
    zone?: string;
    /**
     * 
     * @type {string}
     * @memberof AccommodationAllowance
     */
    location: string;
    /**
     * 
     * @type {string}
     * @memberof AccommodationAllowance
     */
    address?: string;
    /**
     * 
     * @type {number}
     * @memberof AccommodationAllowance
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof AccommodationAllowance
     */
    rate?: number;
    /**
     * 
     * @type {number}
     * @memberof AccommodationAllowance
     */
    amount?: number;
}

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Account
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    number: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    type?: Account.TypeEnum;
    /**
     * The default vat type for this account.
     * @type {VatType}
     * @memberof Account
     */
    vatType?: VatType;
    /**
     * True if all entries on this account must have the vat type given by vatType.
     * @type {boolean}
     * @memberof Account
     */
    vatLocked?: boolean;
    /**
     * If given, all entries on this account must have this currency.
     * @type {Currency}
     * @memberof Account
     */
    currency?: Currency;
    /**
     * True if it should be possible to close entries on this account and it is possible to filter on open entries.
     * @type {boolean}
     * @memberof Account
     */
    isCloseable?: boolean;
    /**
     * True if this account is applicable for supplier invoice registration.
     * @type {boolean}
     * @memberof Account
     */
    isApplicableForSupplierInvoice?: boolean;
    /**
     * True if this account must be reconciled before the accounting period closure.
     * @type {boolean}
     * @memberof Account
     */
    requireReconciliation?: boolean;
    /**
     * Inactive accounts will not show up in UI lists.
     * @type {boolean}
     * @memberof Account
     */
    isInactive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    isBankAccount?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    isInvoiceAccount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    bankAccountNumber?: string;
    /**
     * 
     * @type {Country}
     * @memberof Account
     */
    bankAccountCountry?: Country;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    bankName?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    bankAccountIBAN?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    bankAccountSWIFT?: string;
}

/**
 * @export
 * @namespace Account
 */
export namespace Account {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        ASSETS = <any> 'ASSETS',
        EQUITY = <any> 'EQUITY',
        LIABILITIES = <any> 'LIABILITIES',
        OPERATINGREVENUES = <any> 'OPERATING_REVENUES',
        OPERATINGEXPENSES = <any> 'OPERATING_EXPENSES',
        INVESTMENTINCOME = <any> 'INVESTMENT_INCOME',
        COSTOFCAPITAL = <any> 'COST_OF_CAPITAL',
        TAXONORDINARYACTIVITIES = <any> 'TAX_ON_ORDINARY_ACTIVITIES',
        EXTRAORDINARYINCOME = <any> 'EXTRAORDINARY_INCOME',
        EXTRAORDINARYCOST = <any> 'EXTRAORDINARY_COST',
        TAXONEXTRAORDINARYACTIVITIES = <any> 'TAX_ON_EXTRAORDINARY_ACTIVITIES',
        ANNUALRESULT = <any> 'ANNUAL_RESULT',
        TRANSFERSANDALLOCATIONS = <any> 'TRANSFERS_AND_ALLOCATIONS'
    }
}

/**
 * 
 * @export
 * @interface AccountingPeriod
 */
export interface AccountingPeriod {
    /**
     * 
     * @type {number}
     * @memberof AccountingPeriod
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountingPeriod
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof AccountingPeriod
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof AccountingPeriod
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountingPeriod
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountingPeriod
     */
    number?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountingPeriod
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountingPeriod
     */
    end?: string;
}

/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Activity
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Activity
     */
    isProjectActivity?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Activity
     */
    isGeneral?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Activity
     */
    isChargeable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Activity
     */
    isTask?: boolean;
}

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Address
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    url?: string;
    /**
     * 
     * @type {Employee}
     * @memberof Address
     */
    employee?: Employee;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    addressLine1?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * 
     * @type {Country}
     * @memberof Address
     */
    country?: Country;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface AnnualAccount
 */
export interface AnnualAccount {
    /**
     * 
     * @type {number}
     * @memberof AnnualAccount
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof AnnualAccount
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof AnnualAccount
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof AnnualAccount
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof AnnualAccount
     */
    year?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnualAccount
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnualAccount
     */
    end?: string;
}

/**
 * 
 * @export
 * @interface ApiConsumer
 */
export interface ApiConsumer {
    /**
     * 
     * @type {number}
     * @memberof ApiConsumer
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiConsumer
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof ApiConsumer
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof ApiConsumer
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConsumer
     */
    consumerName: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConsumer
     */
    emails: string;
}

/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {number}
     * @memberof ApiError
     */
    status?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    link?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    developerMessage?: string;
    /**
     * 
     * @type {Array&lt;ApiValidationMessage&gt;}
     * @memberof ApiError
     */
    validationMessages?: Array<ApiValidationMessage>;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    requestId?: string;
}

/**
 * 
 * @export
 * @interface ApiValidationMessage
 */
export interface ApiValidationMessage {
    /**
     * 
     * @type {string}
     * @memberof ApiValidationMessage
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiValidationMessage
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface AppSpecific
 */
export interface AppSpecific {
    /**
     * 
     * @type {boolean}
     * @memberof AppSpecific
     */
    hourRegistrationEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppSpecific
     */
    projectEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppSpecific
     */
    userIsAllowedToRegisterHours?: boolean;
}

/**
 * 
 * @export
 * @interface Bank
 */
export interface Bank {
    /**
     * 
     * @type {number}
     * @memberof Bank
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Bank
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Bank
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    url?: string;
    /**
     * Bank name
     * @type {string}
     * @memberof Bank
     */
    name?: string;
    /**
     * Bank statement file formats supported.
     * @type {Array&lt;string&gt;}
     * @memberof Bank
     */
    bankStatementFileFormatSupport?: Array<Bank.BankStatementFileFormatSupportEnum>;
    /**
     * Register numbers belonging to bank.
     * @type {Array&lt;number&gt;}
     * @memberof Bank
     */
    registerNumbers?: Array<number>;
}

/**
 * @export
 * @namespace Bank
 */
export namespace Bank {
    /**
     * @export
     * @enum {string}
     */
    export enum BankStatementFileFormatSupportEnum {
        DANSKEBANKCSV = <any> 'DANSKE_BANK_CSV',
        EIKATELEPAY = <any> 'EIKA_TELEPAY'
    }
}

/**
 * 
 * @export
 * @interface BankReconciliation
 */
export interface BankReconciliation {
    /**
     * 
     * @type {number}
     * @memberof BankReconciliation
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof BankReconciliation
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof BankReconciliation
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof BankReconciliation
     */
    url?: string;
    /**
     * 
     * @type {Account}
     * @memberof BankReconciliation
     */
    account: Account;
    /**
     * 
     * @type {AccountingPeriod}
     * @memberof BankReconciliation
     */
    accountingPeriod: AccountingPeriod;
    /**
     * 
     * @type {Voucher}
     * @memberof BankReconciliation
     */
    voucher?: Voucher;
    /**
     * 
     * @type {BankStatement}
     * @memberof BankReconciliation
     */
    bankStatement?: BankStatement;
    /**
     * 
     * @type {boolean}
     * @memberof BankReconciliation
     */
    isClosed?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BankReconciliation
     */
    outgoingBankAccountBalanceCurrency?: number;
    /**
     * 
     * @type {string}
     * @memberof BankReconciliation
     */
    closedDate?: string;
    /**
     * 
     * @type {Contact}
     * @memberof BankReconciliation
     */
    closedByContact?: Contact;
    /**
     * 
     * @type {Employee}
     * @memberof BankReconciliation
     */
    closedByEmployee?: Employee;
}

/**
 * 
 * @export
 * @interface BankReconciliationMatch
 */
export interface BankReconciliationMatch {
    /**
     * 
     * @type {number}
     * @memberof BankReconciliationMatch
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof BankReconciliationMatch
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof BankReconciliationMatch
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof BankReconciliationMatch
     */
    url?: string;
    /**
     * 
     * @type {BankReconciliation}
     * @memberof BankReconciliationMatch
     */
    bankReconciliation: BankReconciliation;
    /**
     * Match transactions
     * @type {Array&lt;BankTransaction&gt;}
     * @memberof BankReconciliationMatch
     */
    transactions?: Array<BankTransaction>;
    /**
     * Match postings
     * @type {Array&lt;Posting&gt;}
     * @memberof BankReconciliationMatch
     */
    postings?: Array<Posting>;
}

/**
 * 
 * @export
 * @interface BankReconciliationPaymentType
 */
export interface BankReconciliationPaymentType {
    /**
     * 
     * @type {number}
     * @memberof BankReconciliationPaymentType
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof BankReconciliationPaymentType
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof BankReconciliationPaymentType
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof BankReconciliationPaymentType
     */
    url?: string;
    /**
     * Description
     * @type {string}
     * @memberof BankReconciliationPaymentType
     */
    description?: string;
    /**
     * Debit account
     * @type {Account}
     * @memberof BankReconciliationPaymentType
     */
    debitAccount?: Account;
    /**
     * Credit account
     * @type {Account}
     * @memberof BankReconciliationPaymentType
     */
    creditAccount?: Account;
}

/**
 * 
 * @export
 * @interface BankStatement
 */
export interface BankStatement {
    /**
     * 
     * @type {number}
     * @memberof BankStatement
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof BankStatement
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof BankStatement
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof BankStatement
     */
    url?: string;
    /**
     * Balance on the account.
     * @type {number}
     * @memberof BankStatement
     */
    balanceCurrency?: number;
    /**
     * Bank statement file name.
     * @type {string}
     * @memberof BankStatement
     */
    fileName?: string;
    /**
     * Bank transactions tied to the bank statement
     * @type {Array&lt;BankTransaction&gt;}
     * @memberof BankStatement
     */
    transactions?: Array<BankTransaction>;
}

/**
 * 
 * @export
 * @interface BankTransaction
 */
export interface BankTransaction {
    /**
     * 
     * @type {number}
     * @memberof BankTransaction
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof BankTransaction
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof BankTransaction
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof BankTransaction
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransaction
     */
    postedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransaction
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof BankTransaction
     */
    amountCurrency?: number;
    /**
     * 
     * @type {BankReconciliation}
     * @memberof BankTransaction
     */
    bankStatement?: BankReconciliation;
}

/**
 * 
 * @export
 * @interface Banner
 */
export interface Banner {
    /**
     * 
     * @type {number}
     * @memberof Banner
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Banner
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Banner
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    bannerType: string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    button: string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    link: string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    tag: string;
    /**
     * 
     * @type {boolean}
     * @memberof Banner
     */
    done: boolean;
}

/**
 * 
 * @export
 * @interface CSVRecord
 */
export interface CSVRecord {
    /**
     * 
     * @type {string}
     * @memberof CSVRecord
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof CSVRecord
     */
    recordNumber?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CSVRecord
     */
    consistent?: boolean;
}

/**
 * 
 * @export
 * @interface Change
 */
export interface Change {
    /**
     * 
     * @type {number}
     * @memberof Change
     */
    employeeId?: number;
    /**
     * 
     * @type {Date}
     * @memberof Change
     */
    timestamp?: Date;
    /**
     * 
     * @type {string}
     * @memberof Change
     */
    changeType?: Change.ChangeTypeEnum;
}

/**
 * @export
 * @namespace Change
 */
export namespace Change {
    /**
     * @export
     * @enum {string}
     */
    export enum ChangeTypeEnum {
        CREATE = <any> 'CREATE',
        UPDATE = <any> 'UPDATE',
        DELETE = <any> 'DELETE'
    }
}

/**
 * 
 * @export
 * @interface CloseGroup
 */
export interface CloseGroup {
    /**
     * 
     * @type {number}
     * @memberof CloseGroup
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof CloseGroup
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof CloseGroup
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof CloseGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof CloseGroup
     */
    date?: string;
    /**
     * 
     * @type {Array&lt;Posting&gt;}
     * @memberof CloseGroup
     */
    postings?: Array<Posting>;
}

/**
 * 
 * @export
 * @interface Company
 */
export interface Company {
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Company
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    endDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    organizationNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    phoneNumberMobile?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    faxNumber?: string;
    /**
     * 
     * @type {Address}
     * @memberof Company
     */
    address: Address;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    type: Company.TypeEnum;
}

/**
 * @export
 * @namespace Company
 */
export namespace Company {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        NONE = <any> 'NONE',
        ENK = <any> 'ENK',
        AS = <any> 'AS',
        NUF = <any> 'NUF',
        ANS = <any> 'ANS',
        DA = <any> 'DA',
        PRE = <any> 'PRE',
        KS = <any> 'KS',
        ASA = <any> 'ASA',
        BBL = <any> 'BBL',
        BRL = <any> 'BRL',
        GFS = <any> 'GFS',
        SPA = <any> 'SPA',
        SF = <any> 'SF',
        IKS = <any> 'IKS',
        KFFKF = <any> 'KF_FKF',
        FCD = <any> 'FCD',
        EOFG = <any> 'EOFG',
        BA = <any> 'BA',
        STI = <any> 'STI',
        ORG = <any> 'ORG',
        ESEK = <any> 'ESEK',
        SAM = <any> 'SAM',
        BO = <any> 'BO',
        VPFO = <any> 'VPFO',
        OS = <any> 'OS',
        Other = <any> 'Other'
    }
}

/**
 * 
 * @export
 * @interface ConsumerToken
 */
export interface ConsumerToken {
    /**
     * 
     * @type {number}
     * @memberof ConsumerToken
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ConsumerToken
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof ConsumerToken
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof ConsumerToken
     */
    url?: string;
    /**
     * 
     * @type {ApiConsumer}
     * @memberof ConsumerToken
     */
    apiConsumer?: ApiConsumer;
    /**
     * 
     * @type {string}
     * @memberof ConsumerToken
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsumerToken
     */
    expirationDate?: string;
}

/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Contact
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    email?: string;
    /**
     * 
     * @type {Customer}
     * @memberof Contact
     */
    customer?: Customer;
}

/**
 * 
 * @export
 * @interface Cost
 */
export interface Cost {
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Cost
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Cost
     */
    url?: string;
    /**
     * 
     * @type {TravelExpense}
     * @memberof Cost
     */
    travelExpense?: TravelExpense;
    /**
     * 
     * @type {VatType}
     * @memberof Cost
     */
    vatType?: VatType;
    /**
     * 
     * @type {Currency}
     * @memberof Cost
     */
    currency?: Currency;
    /**
     * 
     * @type {PaymentType}
     * @memberof Cost
     */
    costCategory: PaymentType;
    /**
     * 
     * @type {PaymentType}
     * @memberof Cost
     */
    paymentType: PaymentType;
    /**
     * 
     * @type {string}
     * @memberof Cost
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof Cost
     */
    comments?: string;
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    rate?: number;
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    amountCurrencyIncVat: number;
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    amountNOKInclVAT?: number;
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    amountNOKInclVATLow?: number;
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    amountNOKInclVATMedium?: number;
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    amountNOKInclVATHigh?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Cost
     */
    isPaidByEmployee?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Cost
     */
    isChargeable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Cost
     */
    date: string;
}

/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {number}
     * @memberof Country
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Country
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Country
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * 
     * @type {number}
     * @memberof Currency
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Currency
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Currency
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {number}
     * @memberof Customer
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Customer
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Customer
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    organizationNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof Customer
     */
    supplierNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof Customer
     */
    customerNumber?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Customer
     */
    isSupplier?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Customer
     */
    isCustomer?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Customer
     */
    isInactive?: boolean;
    /**
     * 
     * @type {Employee}
     * @memberof Customer
     */
    accountManager?: Employee;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    invoiceEmail?: string;
    /**
     * List of the bank account numbers for this customer. Norwegian bank account numbers only.
     * @type {Array&lt;string&gt;}
     * @memberof Customer
     */
    bankAccounts?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    phoneNumberMobile?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Customer
     */
    isPrivateIndividual?: boolean;
    /**
     * 
     * @type {Address}
     * @memberof Customer
     */
    postalAddress?: Address;
    /**
     * 
     * @type {Address}
     * @memberof Customer
     */
    physicalAddress?: Address;
    /**
     * 
     * @type {Address}
     * @memberof Customer
     */
    deliveryAddress?: Address;
    /**
     * Category 1 of this customer
     * @type {CustomerCategory}
     * @memberof Customer
     */
    category1?: CustomerCategory;
    /**
     * Category 2 of this customer
     * @type {CustomerCategory}
     * @memberof Customer
     */
    category2?: CustomerCategory;
    /**
     * Category 3 of this customer
     * @type {CustomerCategory}
     * @memberof Customer
     */
    category3?: CustomerCategory;
}

/**
 * 
 * @export
 * @interface CustomerCategory
 */
export interface CustomerCategory {
    /**
     * 
     * @type {number}
     * @memberof CustomerCategory
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerCategory
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof CustomerCategory
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof CustomerCategory
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCategory
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCategory
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerCategory
     */
    type?: number;
}

/**
 * 
 * @export
 * @interface CustomerTripletexAccount
 */
export interface CustomerTripletexAccount {
    /**
     * Administrator user to create in the new company. Leave empty if calling this enpoint as an auditor og accountant company
     * @type {Employee}
     * @memberof CustomerTripletexAccount
     */
    administrator?: Employee;
    /**
     * The customer id to an already created customer to create a Tripletex account for.
     * @type {number}
     * @memberof CustomerTripletexAccount
     */
    customerId?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerTripletexAccount
     */
    accountType: CustomerTripletexAccount.AccountTypeEnum;
    /**
     * 
     * @type {Modules}
     * @memberof CustomerTripletexAccount
     */
    modules: Modules;
    /**
     * 
     * @type {string}
     * @memberof CustomerTripletexAccount
     */
    type: CustomerTripletexAccount.TypeEnum;
    /**
     * Should the emails normally sent during creation be sent in this case?
     * @type {boolean}
     * @memberof CustomerTripletexAccount
     */
    sendEmails?: boolean;
    /**
     * Should the user be automatically validated?
     * @type {boolean}
     * @memberof CustomerTripletexAccount
     */
    autoValidateUserLogin?: boolean;
    /**
     * Creates a token for the admin user. The accounting office could also use their tokens so you might not need this.
     * @type {boolean}
     * @memberof CustomerTripletexAccount
     */
    createApiToken?: boolean;
    /**
     * Should the invoices for this account be sent to the customer?
     * @type {boolean}
     * @memberof CustomerTripletexAccount
     */
    sendInvoiceToCustomer?: boolean;
    /**
     * The address to send the invoice to at the customer.
     * @type {string}
     * @memberof CustomerTripletexAccount
     */
    customerInvoiceEmail?: string;
    /**
     * The number of employees in the customer company. Is used for calculating prices and setting some default settings, i.e. approval settings for timesheet.
     * @type {number}
     * @memberof CustomerTripletexAccount
     */
    numberOfEmployees?: number;
    /**
     * Number of vouchers each year. Used to calculate prices.
     * @type {string}
     * @memberof CustomerTripletexAccount
     */
    numberOfVouchers: CustomerTripletexAccount.NumberOfVouchersEnum;
    /**
     * The password of the administrator user.
     * @type {string}
     * @memberof CustomerTripletexAccount
     */
    administratorPassword?: string;
}

/**
 * @export
 * @namespace CustomerTripletexAccount
 */
export namespace CustomerTripletexAccount {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        TEST = <any> 'TEST',
        PAYING = <any> 'PAYING'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        NONE = <any> 'NONE',
        ENK = <any> 'ENK',
        AS = <any> 'AS',
        NUF = <any> 'NUF',
        ANS = <any> 'ANS',
        DA = <any> 'DA',
        PRE = <any> 'PRE',
        KS = <any> 'KS',
        ASA = <any> 'ASA',
        BBL = <any> 'BBL',
        BRL = <any> 'BRL',
        GFS = <any> 'GFS',
        SPA = <any> 'SPA',
        SF = <any> 'SF',
        IKS = <any> 'IKS',
        KFFKF = <any> 'KF_FKF',
        FCD = <any> 'FCD',
        EOFG = <any> 'EOFG',
        BA = <any> 'BA',
        STI = <any> 'STI',
        ORG = <any> 'ORG',
        ESEK = <any> 'ESEK',
        SAM = <any> 'SAM',
        BO = <any> 'BO',
        VPFO = <any> 'VPFO',
        OS = <any> 'OS',
        Other = <any> 'Other'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NumberOfVouchersEnum {
        _0100 = <any> 'INTERVAL_0_100',
        _101500 = <any> 'INTERVAL_101_500',
        _0500 = <any> 'INTERVAL_0_500',
        _5011000 = <any> 'INTERVAL_501_1000',
        _10012000 = <any> 'INTERVAL_1001_2000',
        _20013500 = <any> 'INTERVAL_2001_3500',
        _35015000 = <any> 'INTERVAL_3501_5000',
        _500110000 = <any> 'INTERVAL_5001_10000',
        UNLIMITED = <any> 'INTERVAL_UNLIMITED'
    }
}

/**
 * 
 * @export
 * @interface Department
 */
export interface Department {
    /**
     * 
     * @type {number}
     * @memberof Department
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Department
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Department
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    departmentNumber?: string;
    /**
     * 
     * @type {Employee}
     * @memberof Department
     */
    departmentManager?: Employee;
}

/**
 * 
 * @export
 * @interface Employee
 */
export interface Employee {
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Employee
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    employeeNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    dateOfBirth?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    phoneNumberMobile?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    nationalIdentityNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    dnumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    bankAccountNumber?: string;
    /**
     * Define the employee's user type.<br>STANDARD: Reduced access. Users with limited system entitlements.<br>EXTENDED: Users can be given all system entitlements.<br>NO_ACCESS: User with no log on access.<br>Users with access to Tripletex must confirm the email address.
     * @type {string}
     * @memberof Employee
     */
    userType?: Employee.UserTypeEnum;
    /**
     * Determines if salary information can be registered on the user including hours, travel expenses and employee expenses. The user may also be selected as a project member on projects.
     * @type {boolean}
     * @memberof Employee
     */
    allowInformationRegistration?: boolean;
    /**
     * Address tied to the employee
     * @type {Address}
     * @memberof Employee
     */
    address?: Address;
    /**
     * 
     * @type {Department}
     * @memberof Employee
     */
    department?: Department;
    /**
     * Employments tied to the employee
     * @type {Array&lt;Employment&gt;}
     * @memberof Employee
     */
    employments?: Array<Employment>;
}

/**
 * @export
 * @namespace Employee
 */
export namespace Employee {
    /**
     * @export
     * @enum {string}
     */
    export enum UserTypeEnum {
        STANDARD = <any> 'STANDARD',
        EXTENDED = <any> 'EXTENDED',
        NOACCESS = <any> 'NO_ACCESS'
    }
}

/**
 * 
 * @export
 * @interface EmployeeToken
 */
export interface EmployeeToken {
    /**
     * 
     * @type {number}
     * @memberof EmployeeToken
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof EmployeeToken
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof EmployeeToken
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof EmployeeToken
     */
    url?: string;
    /**
     * 
     * @type {Employee}
     * @memberof EmployeeToken
     */
    employee?: Employee;
    /**
     * 
     * @type {ApiConsumer}
     * @memberof EmployeeToken
     */
    apiConsumer?: ApiConsumer;
    /**
     * 
     * @type {string}
     * @memberof EmployeeToken
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeToken
     */
    expirationDate?: string;
}

/**
 * 
 * @export
 * @interface Employment
 */
export interface Employment {
    /**
     * 
     * @type {number}
     * @memberof Employment
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Employment
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Employment
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Employment
     */
    url?: string;
    /**
     * 
     * @type {Employee}
     * @memberof Employment
     */
    employee?: Employee;
    /**
     * Existing employment ID used by the current accounting system
     * @type {string}
     * @memberof Employment
     */
    employmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof Employment
     */
    startDate: string;
    /**
     * 
     * @type {string}
     * @memberof Employment
     */
    endDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Employment
     */
    division?: number;
    /**
     * 
     * @type {string}
     * @memberof Employment
     */
    lastSalaryChangeDate?: string;
    /**
     * Employment types tied to the employment
     * @type {Array&lt;EmploymentDetails&gt;}
     * @memberof Employment
     */
    employmentDetails?: Array<EmploymentDetails>;
}

/**
 * 
 * @export
 * @interface EmploymentDetails
 */
export interface EmploymentDetails {
    /**
     * 
     * @type {number}
     * @memberof EmploymentDetails
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof EmploymentDetails
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof EmploymentDetails
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof EmploymentDetails
     */
    url?: string;
    /**
     * 
     * @type {Employment}
     * @memberof EmploymentDetails
     */
    employment?: Employment;
    /**
     * 
     * @type {string}
     * @memberof EmploymentDetails
     */
    date?: string;
    /**
     * To find the right value to enter in this field, you could go to <br>GET /employee/employment/employmentType and select TYPE_OF_EMPLOYMENT_RELATIONSHIP in the dropdown.
     * @type {number}
     * @memberof EmploymentDetails
     */
    employmentType?: number;
    /**
     * To find the right value to enter in this field, you could go to <br> GET /employee/employment/remunerationType and select REMUNERATION_TYPE in the dropdown.
     * @type {number}
     * @memberof EmploymentDetails
     */
    remunerationType?: number;
    /**
     * To find the right value to enter in this field, you could go to GET /employee/employment/workingHoursScheme and select WORKING_HOURS_SCHEME in the dropdown.
     * @type {number}
     * @memberof EmploymentDetails
     */
    workingHoursScheme?: number;
    /**
     * To find the right value to enter in this field, you could go to GET /employee/employment/occupationCode to get a list of valid ID's.
     * @type {number}
     * @memberof EmploymentDetails
     */
    occupationCode?: number;
    /**
     * 
     * @type {number}
     * @memberof EmploymentDetails
     */
    percentageOfFullTimeEquivalent: number;
    /**
     * 
     * @type {number}
     * @memberof EmploymentDetails
     */
    annualSalary?: number;
    /**
     * 
     * @type {number}
     * @memberof EmploymentDetails
     */
    hourlyWage?: number;
}

/**
 * 
 * @export
 * @interface EmploymentType
 */
export interface EmploymentType {
    /**
     * 
     * @type {number}
     * @memberof EmploymentType
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof EmploymentType
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof EmploymentType
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof EmploymentType
     */
    url?: string;
    /**
     * Defines the employment type option. 
     * @type {string}
     * @memberof EmploymentType
     */
    employmentType: EmploymentType.EmploymentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EmploymentType
     */
    nameNO?: string;
    /**
     * 
     * @type {string}
     * @memberof EmploymentType
     */
    code?: string;
}

/**
 * @export
 * @namespace EmploymentType
 */
export namespace EmploymentType {
    /**
     * @export
     * @enum {string}
     */
    export enum EmploymentTypeEnum {
        RELATIONSHIP = <any> 'TYPE_OF_EMPLOYMENT_RELATIONSHIP'
    }
}

/**
 * 
 * @export
 * @interface Entitlement
 */
export interface Entitlement {
    /**
     * 
     * @type {number}
     * @memberof Entitlement
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Entitlement
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Entitlement
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Entitlement
     */
    url?: string;
    /**
     * Employee which has this privilege
     * @type {Employee}
     * @memberof Entitlement
     */
    employee: Employee;
    /**
     * Descriptive name for the privilege. Might change between releases.
     * @type {string}
     * @memberof Entitlement
     */
    name?: string;
    /**
     * Unique id for the type of privilege.
     * @type {number}
     * @memberof Entitlement
     */
    entitlementId: number;
    /**
     * The company this role applies for
     * @type {Company}
     * @memberof Entitlement
     */
    customer: Company;
}

/**
 * 
 * @export
 * @interface EventInfoDescription
 */
export interface EventInfoDescription {
    /**
     * 
     * @type {string}
     * @memberof EventInfoDescription
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof EventInfoDescription
     */
    payloadModel?: string;
}

/**
 * 
 * @export
 * @interface ImportConfigDTO
 */
export interface ImportConfigDTO {
    /**
     * 
     * @type {boolean}
     * @memberof ImportConfigDTO
     */
    onlyUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ImportConfigDTO
     */
    skipUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ImportConfigDTO
     */
    skipAccounts?: boolean;
}

/**
 * 
 * @export
 * @interface ImportReportDTO
 */
export interface ImportReportDTO {
    /**
     * 
     * @type {number}
     * @memberof ImportReportDTO
     */
    companyId?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportReportDTO
     */
    companyName?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportReportDTO
     */
    agreementNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportReportDTO
     */
    agreementType?: string;
    /**
     * 
     * @type {number}
     * @memberof ImportReportDTO
     */
    accountantCompanyId?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportReportDTO
     */
    accountantAgreementNumber?: string;
    /**
     * 
     * @type {Date}
     * @memberof ImportReportDTO
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ImportReportDTO
     */
    endDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof ImportReportDTO
     */
    success?: boolean;
    /**
     * 
     * @type {ImportConfigDTO}
     * @memberof ImportReportDTO
     */
    config?: ImportConfigDTO;
    /**
     * 
     * @type {Array&lt;string&gt;}
     * @memberof ImportReportDTO
     */
    admins?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof ImportReportDTO
     */
    summary?: { [key: string]: { [key: string]: number; }; };
    /**
     * 
     * @type {Array&lt;Result&gt;}
     * @memberof ImportReportDTO
     */
    errors?: Array<Result>;
    /**
     * 
     * @type {Array&lt;string&gt;}
     * @memberof ImportReportDTO
     */
    messages?: Array<string>;
    /**
     * 
     * @type {Array&lt;Result&gt;}
     * @memberof ImportReportDTO
     */
    results?: Array<Result>;
}

/**
 * 
 * @export
 * @interface Inventory
 */
export interface Inventory {
    /**
     * 
     * @type {number}
     * @memberof Inventory
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Inventory
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Inventory
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Inventory
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Inventory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Inventory
     */
    number?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Inventory
     */
    isMainInventory?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Inventory
     */
    isInactive?: boolean;
}

/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Invoice
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    url?: string;
    /**
     * If value is set to 0, the invoice number will be generated.
     * @type {number}
     * @memberof Invoice
     */
    invoiceNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    invoiceDate: string;
    /**
     * The invoice customer
     * @type {Customer}
     * @memberof Invoice
     */
    customer?: Customer;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    invoiceDueDate: string;
    /**
     * KID - Kundeidentifikasjonsnummer.
     * @type {string}
     * @memberof Invoice
     */
    kid?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    comment?: string;
    /**
     * Related orders. Only one order per invoice is supported at the moment.
     * @type {Array&lt;Order&gt;}
     * @memberof Invoice
     */
    orders: Array<Order>;
    /**
     * The invoice voucher.
     * @type {Voucher}
     * @memberof Invoice
     */
    voucher?: Voucher;
    /**
     * The delivery date.
     * @type {string}
     * @memberof Invoice
     */
    deliveryDate?: string;
    /**
     * In the company’s currency, typically NOK.
     * @type {number}
     * @memberof Invoice
     */
    amount?: number;
    /**
     * In the specified currency.
     * @type {number}
     * @memberof Invoice
     */
    amountCurrency?: number;
    /**
     * Amount excluding VAT (NOK).
     * @type {number}
     * @memberof Invoice
     */
    amountExcludingVat?: number;
    /**
     * Amount excluding VAT in the specified currency.
     * @type {number}
     * @memberof Invoice
     */
    amountExcludingVatCurrency?: number;
    /**
     * 
     * @type {Currency}
     * @memberof Invoice
     */
    currency?: Currency;
    /**
     * 
     * @type {boolean}
     * @memberof Invoice
     */
    isCreditNote?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    ehfSendStatus?: Invoice.EhfSendStatusEnum;
}

/**
 * @export
 * @namespace Invoice
 */
export namespace Invoice {
    /**
     * @export
     * @enum {string}
     */
    export enum EhfSendStatusEnum {
        DONOTSEND = <any> 'DO_NOT_SEND',
        SEND = <any> 'SEND',
        SENT = <any> 'SENT',
        SENDFAILURERECIPIENTNOTFOUND = <any> 'SEND_FAILURE_RECIPIENT_NOT_FOUND'
    }
}

/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    group?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    stateful?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    interruptable?: boolean;
    /**
     * 
     * @type {JobDetailDTO}
     * @memberof Job
     */
    jobDetail?: JobDetailDTO;
    /**
     * 
     * @type {Array&lt;TriggerDTO&gt;}
     * @memberof Job
     */
    triggers?: Array<TriggerDTO>;
}

/**
 * 
 * @export
 * @interface JobDetailDTO
 */
export interface JobDetailDTO {
    /**
     * 
     * @type {string}
     * @memberof JobDetailDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof JobDetailDTO
     */
    group?: string;
    /**
     * 
     * @type {string}
     * @memberof JobDetailDTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof JobDetailDTO
     */
    jobclass?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobDetailDTO
     */
    jobData?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface LeaveOfAbsence
 */
export interface LeaveOfAbsence {
    /**
     * 
     * @type {number}
     * @memberof LeaveOfAbsence
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaveOfAbsence
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof LeaveOfAbsence
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof LeaveOfAbsence
     */
    url?: string;
    /**
     * 
     * @type {Employment}
     * @memberof LeaveOfAbsence
     */
    employment?: Employment;
    /**
     * Existing leave of absence ID used by the current accounting system
     * @type {string}
     * @memberof LeaveOfAbsence
     */
    leaveOfAbsenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof LeaveOfAbsence
     */
    startDate: string;
    /**
     * 
     * @type {string}
     * @memberof LeaveOfAbsence
     */
    endDate?: string;
    /**
     * 
     * @type {number}
     * @memberof LeaveOfAbsence
     */
    percentage: number;
    /**
     * 
     * @type {boolean}
     * @memberof LeaveOfAbsence
     */
    isWageDeduction?: boolean;
    /**
     * 
     * @type {number}
     * @memberof LeaveOfAbsence
     */
    type: number;
}

/**
 * 
 * @export
 * @interface LeaveOfAbsenceType
 */
export interface LeaveOfAbsenceType {
    /**
     * 
     * @type {number}
     * @memberof LeaveOfAbsenceType
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaveOfAbsenceType
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof LeaveOfAbsenceType
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof LeaveOfAbsenceType
     */
    url?: string;
    /**
     * Defines the leave of absence type option.
     * @type {string}
     * @memberof LeaveOfAbsenceType
     */
    leaveOfAbsenceType: LeaveOfAbsenceType.LeaveOfAbsenceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof LeaveOfAbsenceType
     */
    nameNO?: string;
    /**
     * 
     * @type {string}
     * @memberof LeaveOfAbsenceType
     */
    code?: string;
}

/**
 * @export
 * @namespace LeaveOfAbsenceType
 */
export namespace LeaveOfAbsenceType {
    /**
     * @export
     * @enum {string}
     */
    export enum LeaveOfAbsenceTypeEnum {
        TYPE = <any> 'LEAVE_OF_ABSENCE_TYPE'
    }
}

/**
 * 
 * @export
 * @interface LedgerAccount
 */
export interface LedgerAccount {
    /**
     * 
     * @type {Account}
     * @memberof LedgerAccount
     */
    account?: Account;
    /**
     * 
     * @type {number}
     * @memberof LedgerAccount
     */
    sumAmount?: number;
    /**
     * 
     * @type {Currency}
     * @memberof LedgerAccount
     */
    currency?: Currency;
    /**
     * 
     * @type {number}
     * @memberof LedgerAccount
     */
    sumAmountCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof LedgerAccount
     */
    openingBalance?: number;
    /**
     * 
     * @type {number}
     * @memberof LedgerAccount
     */
    openingBalanceCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof LedgerAccount
     */
    closingBalance?: number;
    /**
     * 
     * @type {number}
     * @memberof LedgerAccount
     */
    closingBalanceCurrency?: number;
    /**
     * Link to postings on this account.
     * @type {Array&lt;Posting&gt;}
     * @memberof LedgerAccount
     */
    postings?: Array<Posting>;
}

/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    rel?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    type?: Link.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href?: string;
}

/**
 * @export
 * @namespace Link
 */
export namespace Link {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        POST = <any> 'POST',
        PUT = <any> 'PUT',
        GET = <any> 'GET',
        DELETE = <any> 'DELETE'
    }
}

/**
 * 
 * @export
 * @interface ListResponseAccommodationAllowance
 */
export interface ListResponseAccommodationAllowance {
    /**
     * 
     * @type {number}
     * @memberof ListResponseAccommodationAllowance
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseAccommodationAllowance
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseAccommodationAllowance
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseAccommodationAllowance
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;AccommodationAllowance&gt;}
     * @memberof ListResponseAccommodationAllowance
     */
    values?: Array<AccommodationAllowance>;
}

/**
 * 
 * @export
 * @interface ListResponseAccount
 */
export interface ListResponseAccount {
    /**
     * 
     * @type {number}
     * @memberof ListResponseAccount
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseAccount
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseAccount
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseAccount
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Account&gt;}
     * @memberof ListResponseAccount
     */
    values?: Array<Account>;
}

/**
 * 
 * @export
 * @interface ListResponseAccountingPeriod
 */
export interface ListResponseAccountingPeriod {
    /**
     * 
     * @type {number}
     * @memberof ListResponseAccountingPeriod
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseAccountingPeriod
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseAccountingPeriod
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseAccountingPeriod
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;AccountingPeriod&gt;}
     * @memberof ListResponseAccountingPeriod
     */
    values?: Array<AccountingPeriod>;
}

/**
 * 
 * @export
 * @interface ListResponseActivity
 */
export interface ListResponseActivity {
    /**
     * 
     * @type {number}
     * @memberof ListResponseActivity
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseActivity
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseActivity
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseActivity
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Activity&gt;}
     * @memberof ListResponseActivity
     */
    values?: Array<Activity>;
}

/**
 * 
 * @export
 * @interface ListResponseAddress
 */
export interface ListResponseAddress {
    /**
     * 
     * @type {number}
     * @memberof ListResponseAddress
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseAddress
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseAddress
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseAddress
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Address&gt;}
     * @memberof ListResponseAddress
     */
    values?: Array<Address>;
}

/**
 * 
 * @export
 * @interface ListResponseAnnualAccount
 */
export interface ListResponseAnnualAccount {
    /**
     * 
     * @type {number}
     * @memberof ListResponseAnnualAccount
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseAnnualAccount
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseAnnualAccount
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseAnnualAccount
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;AnnualAccount&gt;}
     * @memberof ListResponseAnnualAccount
     */
    values?: Array<AnnualAccount>;
}

/**
 * 
 * @export
 * @interface ListResponseBank
 */
export interface ListResponseBank {
    /**
     * 
     * @type {number}
     * @memberof ListResponseBank
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBank
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBank
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseBank
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Bank&gt;}
     * @memberof ListResponseBank
     */
    values?: Array<Bank>;
}

/**
 * 
 * @export
 * @interface ListResponseBankReconciliation
 */
export interface ListResponseBankReconciliation {
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankReconciliation
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankReconciliation
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankReconciliation
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseBankReconciliation
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;BankReconciliation&gt;}
     * @memberof ListResponseBankReconciliation
     */
    values?: Array<BankReconciliation>;
}

/**
 * 
 * @export
 * @interface ListResponseBankReconciliationMatch
 */
export interface ListResponseBankReconciliationMatch {
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankReconciliationMatch
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankReconciliationMatch
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankReconciliationMatch
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseBankReconciliationMatch
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;BankReconciliationMatch&gt;}
     * @memberof ListResponseBankReconciliationMatch
     */
    values?: Array<BankReconciliationMatch>;
}

/**
 * 
 * @export
 * @interface ListResponseBankReconciliationPaymentType
 */
export interface ListResponseBankReconciliationPaymentType {
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankReconciliationPaymentType
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankReconciliationPaymentType
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankReconciliationPaymentType
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseBankReconciliationPaymentType
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;BankReconciliationPaymentType&gt;}
     * @memberof ListResponseBankReconciliationPaymentType
     */
    values?: Array<BankReconciliationPaymentType>;
}

/**
 * 
 * @export
 * @interface ListResponseBankStatement
 */
export interface ListResponseBankStatement {
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankStatement
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankStatement
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankStatement
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseBankStatement
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;BankStatement&gt;}
     * @memberof ListResponseBankStatement
     */
    values?: Array<BankStatement>;
}

/**
 * 
 * @export
 * @interface ListResponseBankTransaction
 */
export interface ListResponseBankTransaction {
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankTransaction
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankTransaction
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBankTransaction
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseBankTransaction
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;BankTransaction&gt;}
     * @memberof ListResponseBankTransaction
     */
    values?: Array<BankTransaction>;
}

/**
 * 
 * @export
 * @interface ListResponseBanner
 */
export interface ListResponseBanner {
    /**
     * 
     * @type {number}
     * @memberof ListResponseBanner
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBanner
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseBanner
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseBanner
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Banner&gt;}
     * @memberof ListResponseBanner
     */
    values?: Array<Banner>;
}

/**
 * 
 * @export
 * @interface ListResponseCloseGroup
 */
export interface ListResponseCloseGroup {
    /**
     * 
     * @type {number}
     * @memberof ListResponseCloseGroup
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCloseGroup
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCloseGroup
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseCloseGroup
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;CloseGroup&gt;}
     * @memberof ListResponseCloseGroup
     */
    values?: Array<CloseGroup>;
}

/**
 * 
 * @export
 * @interface ListResponseCompany
 */
export interface ListResponseCompany {
    /**
     * 
     * @type {number}
     * @memberof ListResponseCompany
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCompany
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCompany
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseCompany
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Company&gt;}
     * @memberof ListResponseCompany
     */
    values?: Array<Company>;
}

/**
 * 
 * @export
 * @interface ListResponseContact
 */
export interface ListResponseContact {
    /**
     * 
     * @type {number}
     * @memberof ListResponseContact
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseContact
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseContact
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseContact
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Contact&gt;}
     * @memberof ListResponseContact
     */
    values?: Array<Contact>;
}

/**
 * 
 * @export
 * @interface ListResponseCost
 */
export interface ListResponseCost {
    /**
     * 
     * @type {number}
     * @memberof ListResponseCost
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCost
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCost
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseCost
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Cost&gt;}
     * @memberof ListResponseCost
     */
    values?: Array<Cost>;
}

/**
 * 
 * @export
 * @interface ListResponseCountry
 */
export interface ListResponseCountry {
    /**
     * 
     * @type {number}
     * @memberof ListResponseCountry
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCountry
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCountry
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseCountry
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Country&gt;}
     * @memberof ListResponseCountry
     */
    values?: Array<Country>;
}

/**
 * 
 * @export
 * @interface ListResponseCurrency
 */
export interface ListResponseCurrency {
    /**
     * 
     * @type {number}
     * @memberof ListResponseCurrency
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCurrency
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCurrency
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseCurrency
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Currency&gt;}
     * @memberof ListResponseCurrency
     */
    values?: Array<Currency>;
}

/**
 * 
 * @export
 * @interface ListResponseCustomer
 */
export interface ListResponseCustomer {
    /**
     * 
     * @type {number}
     * @memberof ListResponseCustomer
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCustomer
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCustomer
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseCustomer
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Customer&gt;}
     * @memberof ListResponseCustomer
     */
    values?: Array<Customer>;
}

/**
 * 
 * @export
 * @interface ListResponseCustomerCategory
 */
export interface ListResponseCustomerCategory {
    /**
     * 
     * @type {number}
     * @memberof ListResponseCustomerCategory
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCustomerCategory
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCustomerCategory
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseCustomerCategory
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;CustomerCategory&gt;}
     * @memberof ListResponseCustomerCategory
     */
    values?: Array<CustomerCategory>;
}

/**
 * 
 * @export
 * @interface ListResponseDepartment
 */
export interface ListResponseDepartment {
    /**
     * 
     * @type {number}
     * @memberof ListResponseDepartment
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseDepartment
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseDepartment
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseDepartment
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Department&gt;}
     * @memberof ListResponseDepartment
     */
    values?: Array<Department>;
}

/**
 * 
 * @export
 * @interface ListResponseEmployee
 */
export interface ListResponseEmployee {
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmployee
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmployee
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmployee
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseEmployee
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Employee&gt;}
     * @memberof ListResponseEmployee
     */
    values?: Array<Employee>;
}

/**
 * 
 * @export
 * @interface ListResponseEmployment
 */
export interface ListResponseEmployment {
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmployment
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmployment
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmployment
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseEmployment
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Employment&gt;}
     * @memberof ListResponseEmployment
     */
    values?: Array<Employment>;
}

/**
 * 
 * @export
 * @interface ListResponseEmploymentDetails
 */
export interface ListResponseEmploymentDetails {
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmploymentDetails
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmploymentDetails
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmploymentDetails
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseEmploymentDetails
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;EmploymentDetails&gt;}
     * @memberof ListResponseEmploymentDetails
     */
    values?: Array<EmploymentDetails>;
}

/**
 * 
 * @export
 * @interface ListResponseEmploymentType
 */
export interface ListResponseEmploymentType {
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmploymentType
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmploymentType
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseEmploymentType
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseEmploymentType
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;EmploymentType&gt;}
     * @memberof ListResponseEmploymentType
     */
    values?: Array<EmploymentType>;
}

/**
 * 
 * @export
 * @interface ListResponseEntitlement
 */
export interface ListResponseEntitlement {
    /**
     * 
     * @type {number}
     * @memberof ListResponseEntitlement
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseEntitlement
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseEntitlement
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseEntitlement
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Entitlement&gt;}
     * @memberof ListResponseEntitlement
     */
    values?: Array<Entitlement>;
}

/**
 * 
 * @export
 * @interface ListResponseInventory
 */
export interface ListResponseInventory {
    /**
     * 
     * @type {number}
     * @memberof ListResponseInventory
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseInventory
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseInventory
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseInventory
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Inventory&gt;}
     * @memberof ListResponseInventory
     */
    values?: Array<Inventory>;
}

/**
 * 
 * @export
 * @interface ListResponseInvoice
 */
export interface ListResponseInvoice {
    /**
     * 
     * @type {number}
     * @memberof ListResponseInvoice
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseInvoice
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseInvoice
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseInvoice
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Invoice&gt;}
     * @memberof ListResponseInvoice
     */
    values?: Array<Invoice>;
}

/**
 * 
 * @export
 * @interface ListResponseLeaveOfAbsenceType
 */
export interface ListResponseLeaveOfAbsenceType {
    /**
     * 
     * @type {number}
     * @memberof ListResponseLeaveOfAbsenceType
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseLeaveOfAbsenceType
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseLeaveOfAbsenceType
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseLeaveOfAbsenceType
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;LeaveOfAbsenceType&gt;}
     * @memberof ListResponseLeaveOfAbsenceType
     */
    values?: Array<LeaveOfAbsenceType>;
}

/**
 * 
 * @export
 * @interface ListResponseLedgerAccount
 */
export interface ListResponseLedgerAccount {
    /**
     * 
     * @type {number}
     * @memberof ListResponseLedgerAccount
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseLedgerAccount
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseLedgerAccount
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseLedgerAccount
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;LedgerAccount&gt;}
     * @memberof ListResponseLedgerAccount
     */
    values?: Array<LedgerAccount>;
}

/**
 * 
 * @export
 * @interface ListResponseMileageAllowance
 */
export interface ListResponseMileageAllowance {
    /**
     * 
     * @type {number}
     * @memberof ListResponseMileageAllowance
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseMileageAllowance
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseMileageAllowance
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseMileageAllowance
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;MileageAllowance&gt;}
     * @memberof ListResponseMileageAllowance
     */
    values?: Array<MileageAllowance>;
}

/**
 * 
 * @export
 * @interface ListResponseNotification
 */
export interface ListResponseNotification {
    /**
     * 
     * @type {number}
     * @memberof ListResponseNotification
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseNotification
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseNotification
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseNotification
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Notification&gt;}
     * @memberof ListResponseNotification
     */
    values?: Array<Notification>;
}

/**
 * 
 * @export
 * @interface ListResponseOccupationCode
 */
export interface ListResponseOccupationCode {
    /**
     * 
     * @type {number}
     * @memberof ListResponseOccupationCode
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseOccupationCode
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseOccupationCode
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseOccupationCode
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;OccupationCode&gt;}
     * @memberof ListResponseOccupationCode
     */
    values?: Array<OccupationCode>;
}

/**
 * 
 * @export
 * @interface ListResponseOrder
 */
export interface ListResponseOrder {
    /**
     * 
     * @type {number}
     * @memberof ListResponseOrder
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseOrder
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseOrder
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseOrder
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Order&gt;}
     * @memberof ListResponseOrder
     */
    values?: Array<Order>;
}

/**
 * 
 * @export
 * @interface ListResponseOrderLine
 */
export interface ListResponseOrderLine {
    /**
     * 
     * @type {number}
     * @memberof ListResponseOrderLine
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseOrderLine
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseOrderLine
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseOrderLine
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;OrderLine&gt;}
     * @memberof ListResponseOrderLine
     */
    values?: Array<OrderLine>;
}

/**
 * 
 * @export
 * @interface ListResponsePassenger
 */
export interface ListResponsePassenger {
    /**
     * 
     * @type {number}
     * @memberof ListResponsePassenger
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePassenger
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePassenger
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponsePassenger
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Passenger&gt;}
     * @memberof ListResponsePassenger
     */
    values?: Array<Passenger>;
}

/**
 * 
 * @export
 * @interface ListResponsePaymentType
 */
export interface ListResponsePaymentType {
    /**
     * 
     * @type {number}
     * @memberof ListResponsePaymentType
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePaymentType
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePaymentType
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponsePaymentType
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;PaymentType&gt;}
     * @memberof ListResponsePaymentType
     */
    values?: Array<PaymentType>;
}

/**
 * 
 * @export
 * @interface ListResponsePaymentTypeOut
 */
export interface ListResponsePaymentTypeOut {
    /**
     * 
     * @type {number}
     * @memberof ListResponsePaymentTypeOut
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePaymentTypeOut
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePaymentTypeOut
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponsePaymentTypeOut
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;PaymentTypeOut&gt;}
     * @memberof ListResponsePaymentTypeOut
     */
    values?: Array<PaymentTypeOut>;
}

/**
 * 
 * @export
 * @interface ListResponsePayslip
 */
export interface ListResponsePayslip {
    /**
     * 
     * @type {number}
     * @memberof ListResponsePayslip
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePayslip
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePayslip
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponsePayslip
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Payslip&gt;}
     * @memberof ListResponsePayslip
     */
    values?: Array<Payslip>;
}

/**
 * 
 * @export
 * @interface ListResponsePerDiemCompensation
 */
export interface ListResponsePerDiemCompensation {
    /**
     * 
     * @type {number}
     * @memberof ListResponsePerDiemCompensation
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePerDiemCompensation
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePerDiemCompensation
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponsePerDiemCompensation
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;PerDiemCompensation&gt;}
     * @memberof ListResponsePerDiemCompensation
     */
    values?: Array<PerDiemCompensation>;
}

/**
 * 
 * @export
 * @interface ListResponsePosting
 */
export interface ListResponsePosting {
    /**
     * 
     * @type {number}
     * @memberof ListResponsePosting
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePosting
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponsePosting
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponsePosting
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Posting&gt;}
     * @memberof ListResponsePosting
     */
    values?: Array<Posting>;
}

/**
 * 
 * @export
 * @interface ListResponseProduct
 */
export interface ListResponseProduct {
    /**
     * 
     * @type {number}
     * @memberof ListResponseProduct
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseProduct
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseProduct
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseProduct
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Product&gt;}
     * @memberof ListResponseProduct
     */
    values?: Array<Product>;
}

/**
 * 
 * @export
 * @interface ListResponseProductUnit
 */
export interface ListResponseProductUnit {
    /**
     * 
     * @type {number}
     * @memberof ListResponseProductUnit
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseProductUnit
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseProductUnit
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseProductUnit
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;ProductUnit&gt;}
     * @memberof ListResponseProductUnit
     */
    values?: Array<ProductUnit>;
}

/**
 * 
 * @export
 * @interface ListResponseProject
 */
export interface ListResponseProject {
    /**
     * 
     * @type {number}
     * @memberof ListResponseProject
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseProject
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseProject
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseProject
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Project&gt;}
     * @memberof ListResponseProject
     */
    values?: Array<Project>;
}

/**
 * 
 * @export
 * @interface ListResponseProjectCategory
 */
export interface ListResponseProjectCategory {
    /**
     * 
     * @type {number}
     * @memberof ListResponseProjectCategory
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseProjectCategory
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseProjectCategory
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseProjectCategory
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;ProjectCategory&gt;}
     * @memberof ListResponseProjectCategory
     */
    values?: Array<ProjectCategory>;
}

/**
 * 
 * @export
 * @interface ListResponseProspect
 */
export interface ListResponseProspect {
    /**
     * 
     * @type {number}
     * @memberof ListResponseProspect
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseProspect
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseProspect
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseProspect
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Prospect&gt;}
     * @memberof ListResponseProspect
     */
    values?: Array<Prospect>;
}

/**
 * 
 * @export
 * @interface ListResponseRemunerationType
 */
export interface ListResponseRemunerationType {
    /**
     * 
     * @type {number}
     * @memberof ListResponseRemunerationType
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseRemunerationType
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseRemunerationType
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseRemunerationType
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;RemunerationType&gt;}
     * @memberof ListResponseRemunerationType
     */
    values?: Array<RemunerationType>;
}

/**
 * 
 * @export
 * @interface ListResponseSalarySpecification
 */
export interface ListResponseSalarySpecification {
    /**
     * 
     * @type {number}
     * @memberof ListResponseSalarySpecification
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSalarySpecification
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSalarySpecification
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseSalarySpecification
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;SalarySpecification&gt;}
     * @memberof ListResponseSalarySpecification
     */
    values?: Array<SalarySpecification>;
}

/**
 * 
 * @export
 * @interface ListResponseSalaryTransaction
 */
export interface ListResponseSalaryTransaction {
    /**
     * 
     * @type {number}
     * @memberof ListResponseSalaryTransaction
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSalaryTransaction
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSalaryTransaction
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseSalaryTransaction
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;SalaryTransaction&gt;}
     * @memberof ListResponseSalaryTransaction
     */
    values?: Array<SalaryTransaction>;
}

/**
 * 
 * @export
 * @interface ListResponseSalaryType
 */
export interface ListResponseSalaryType {
    /**
     * 
     * @type {number}
     * @memberof ListResponseSalaryType
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSalaryType
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSalaryType
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseSalaryType
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;SalaryType&gt;}
     * @memberof ListResponseSalaryType
     */
    values?: Array<SalaryType>;
}

/**
 * 
 * @export
 * @interface ListResponseStandardTime
 */
export interface ListResponseStandardTime {
    /**
     * 
     * @type {number}
     * @memberof ListResponseStandardTime
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseStandardTime
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseStandardTime
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseStandardTime
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;StandardTime&gt;}
     * @memberof ListResponseStandardTime
     */
    values?: Array<StandardTime>;
}

/**
 * 
 * @export
 * @interface ListResponseSubscription
 */
export interface ListResponseSubscription {
    /**
     * 
     * @type {number}
     * @memberof ListResponseSubscription
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSubscription
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSubscription
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseSubscription
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Subscription&gt;}
     * @memberof ListResponseSubscription
     */
    values?: Array<Subscription>;
}

/**
 * 
 * @export
 * @interface ListResponseSupplier
 */
export interface ListResponseSupplier {
    /**
     * 
     * @type {number}
     * @memberof ListResponseSupplier
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSupplier
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSupplier
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseSupplier
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Supplier&gt;}
     * @memberof ListResponseSupplier
     */
    values?: Array<Supplier>;
}

/**
 * 
 * @export
 * @interface ListResponseSupplierBalance
 */
export interface ListResponseSupplierBalance {
    /**
     * 
     * @type {number}
     * @memberof ListResponseSupplierBalance
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSupplierBalance
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseSupplierBalance
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseSupplierBalance
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;SupplierBalance&gt;}
     * @memberof ListResponseSupplierBalance
     */
    values?: Array<SupplierBalance>;
}

/**
 * 
 * @export
 * @interface ListResponseTimeClock
 */
export interface ListResponseTimeClock {
    /**
     * 
     * @type {number}
     * @memberof ListResponseTimeClock
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTimeClock
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTimeClock
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseTimeClock
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;TimeClock&gt;}
     * @memberof ListResponseTimeClock
     */
    values?: Array<TimeClock>;
}

/**
 * 
 * @export
 * @interface ListResponseTimesheetEntry
 */
export interface ListResponseTimesheetEntry {
    /**
     * 
     * @type {number}
     * @memberof ListResponseTimesheetEntry
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTimesheetEntry
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTimesheetEntry
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseTimesheetEntry
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;TimesheetEntry&gt;}
     * @memberof ListResponseTimesheetEntry
     */
    values?: Array<TimesheetEntry>;
}

/**
 * 
 * @export
 * @interface ListResponseTravelCostCategory
 */
export interface ListResponseTravelCostCategory {
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelCostCategory
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelCostCategory
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelCostCategory
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseTravelCostCategory
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;TravelCostCategory&gt;}
     * @memberof ListResponseTravelCostCategory
     */
    values?: Array<TravelCostCategory>;
}

/**
 * 
 * @export
 * @interface ListResponseTravelExpense
 */
export interface ListResponseTravelExpense {
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpense
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpense
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpense
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseTravelExpense
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;TravelExpense&gt;}
     * @memberof ListResponseTravelExpense
     */
    values?: Array<TravelExpense>;
}

/**
 * 
 * @export
 * @interface ListResponseTravelExpenseRate
 */
export interface ListResponseTravelExpenseRate {
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpenseRate
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpenseRate
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpenseRate
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseTravelExpenseRate
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;TravelExpenseRate&gt;}
     * @memberof ListResponseTravelExpenseRate
     */
    values?: Array<TravelExpenseRate>;
}

/**
 * 
 * @export
 * @interface ListResponseTravelExpenseRateCategory
 */
export interface ListResponseTravelExpenseRateCategory {
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpenseRateCategory
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpenseRateCategory
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpenseRateCategory
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseTravelExpenseRateCategory
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;TravelExpenseRateCategory&gt;}
     * @memberof ListResponseTravelExpenseRateCategory
     */
    values?: Array<TravelExpenseRateCategory>;
}

/**
 * 
 * @export
 * @interface ListResponseTravelExpenseRateCategoryGroup
 */
export interface ListResponseTravelExpenseRateCategoryGroup {
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpenseRateCategoryGroup
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpenseRateCategoryGroup
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelExpenseRateCategoryGroup
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseTravelExpenseRateCategoryGroup
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;TravelExpenseRateCategoryGroup&gt;}
     * @memberof ListResponseTravelExpenseRateCategoryGroup
     */
    values?: Array<TravelExpenseRateCategoryGroup>;
}

/**
 * 
 * @export
 * @interface ListResponseTravelPaymentType
 */
export interface ListResponseTravelPaymentType {
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelPaymentType
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelPaymentType
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTravelPaymentType
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseTravelPaymentType
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;TravelPaymentType&gt;}
     * @memberof ListResponseTravelPaymentType
     */
    values?: Array<TravelPaymentType>;
}

/**
 * 
 * @export
 * @interface ListResponseVatType
 */
export interface ListResponseVatType {
    /**
     * 
     * @type {number}
     * @memberof ListResponseVatType
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseVatType
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseVatType
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseVatType
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;VatType&gt;}
     * @memberof ListResponseVatType
     */
    values?: Array<VatType>;
}

/**
 * 
 * @export
 * @interface ListResponseVoucher
 */
export interface ListResponseVoucher {
    /**
     * 
     * @type {number}
     * @memberof ListResponseVoucher
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseVoucher
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseVoucher
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseVoucher
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Voucher&gt;}
     * @memberof ListResponseVoucher
     */
    values?: Array<Voucher>;
}

/**
 * 
 * @export
 * @interface ListResponseVoucherType
 */
export interface ListResponseVoucherType {
    /**
     * 
     * @type {number}
     * @memberof ListResponseVoucherType
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseVoucherType
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseVoucherType
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseVoucherType
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;VoucherType&gt;}
     * @memberof ListResponseVoucherType
     */
    values?: Array<VoucherType>;
}

/**
 * 
 * @export
 * @interface ListResponseWeeklyStatus
 */
export interface ListResponseWeeklyStatus {
    /**
     * 
     * @type {number}
     * @memberof ListResponseWeeklyStatus
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseWeeklyStatus
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseWeeklyStatus
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseWeeklyStatus
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;WeeklyStatus&gt;}
     * @memberof ListResponseWeeklyStatus
     */
    values?: Array<WeeklyStatus>;
}

/**
 * 
 * @export
 * @interface ListResponseWorkingHoursScheme
 */
export interface ListResponseWorkingHoursScheme {
    /**
     * 
     * @type {number}
     * @memberof ListResponseWorkingHoursScheme
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseWorkingHoursScheme
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseWorkingHoursScheme
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof ListResponseWorkingHoursScheme
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;WorkingHoursScheme&gt;}
     * @memberof ListResponseWorkingHoursScheme
     */
    values?: Array<WorkingHoursScheme>;
}

/**
 * 
 * @export
 * @interface LoggedInUserInfoDTO
 */
export interface LoggedInUserInfoDTO {
    /**
     * 
     * @type {number}
     * @memberof LoggedInUserInfoDTO
     */
    employeeId?: number;
    /**
     * 
     * @type {Employee}
     * @memberof LoggedInUserInfoDTO
     */
    employee?: Employee;
    /**
     * 
     * @type {number}
     * @memberof LoggedInUserInfoDTO
     */
    companyId?: number;
    /**
     * 
     * @type {Company}
     * @memberof LoggedInUserInfoDTO
     */
    company?: Company;
    /**
     * 
     * @type {string}
     * @memberof LoggedInUserInfoDTO
     */
    language?: string;
}

/**
 * 
 * @export
 * @interface MaventaEventDataDTO
 */
export interface MaventaEventDataDTO {
    /**
     * 
     * @type {string}
     * @memberof MaventaEventDataDTO
     */
    invoiceId: string;
    /**
     * 
     * @type {string}
     * @memberof MaventaEventDataDTO
     */
    invoiceNumber: string;
    /**
     * 
     * @type {string}
     * @memberof MaventaEventDataDTO
     */
    destination: string;
    /**
     * 
     * @type {string}
     * @memberof MaventaEventDataDTO
     */
    recipientName: string;
    /**
     * 
     * @type {string}
     * @memberof MaventaEventDataDTO
     */
    recipientBid: string;
    /**
     * 
     * @type {string}
     * @memberof MaventaEventDataDTO
     */
    errorMessage?: string;
}

/**
 * 
 * @export
 * @interface MaventaStatusDTO
 */
export interface MaventaStatusDTO {
    /**
     * 
     * @type {string}
     * @memberof MaventaStatusDTO
     */
    event: string;
    /**
     * 
     * @type {string}
     * @memberof MaventaStatusDTO
     */
    companyId: string;
    /**
     * 
     * @type {Date}
     * @memberof MaventaStatusDTO
     */
    eventTimestamp: Date;
    /**
     * 
     * @type {MaventaEventDataDTO}
     * @memberof MaventaStatusDTO
     */
    eventData: MaventaEventDataDTO;
}

/**
 * 
 * @export
 * @interface MileageAllowance
 */
export interface MileageAllowance {
    /**
     * 
     * @type {number}
     * @memberof MileageAllowance
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof MileageAllowance
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof MileageAllowance
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof MileageAllowance
     */
    url?: string;
    /**
     * 
     * @type {TravelExpense}
     * @memberof MileageAllowance
     */
    travelExpense?: TravelExpense;
    /**
     * 
     * @type {TravelExpenseRate}
     * @memberof MileageAllowance
     */
    rateType?: TravelExpenseRate;
    /**
     * 
     * @type {TravelExpenseRateCategory}
     * @memberof MileageAllowance
     */
    rateCategory?: TravelExpenseRateCategory;
    /**
     * 
     * @type {string}
     * @memberof MileageAllowance
     */
    date: string;
    /**
     * 
     * @type {string}
     * @memberof MileageAllowance
     */
    departureLocation: string;
    /**
     * 
     * @type {string}
     * @memberof MileageAllowance
     */
    destination: string;
    /**
     * 
     * @type {number}
     * @memberof MileageAllowance
     */
    km?: number;
    /**
     * 
     * @type {number}
     * @memberof MileageAllowance
     */
    rate?: number;
    /**
     * 
     * @type {number}
     * @memberof MileageAllowance
     */
    amount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MileageAllowance
     */
    isCompanyCar?: boolean;
    /**
     * Link to individual passengers.
     * @type {Array&lt;Passenger&gt;}
     * @memberof MileageAllowance
     */
    passengers?: Array<Passenger>;
}

/**
 * 
 * @export
 * @interface MobileAppLogin
 */
export interface MobileAppLogin {
    /**
     * Users username (email)
     * @type {string}
     * @memberof MobileAppLogin
     */
    username: string;
    /**
     * Users password
     * @type {string}
     * @memberof MobileAppLogin
     */
    password: string;
    /**
     * App secret (temporary security mechanism during testing)
     * @type {string}
     * @memberof MobileAppLogin
     */
    appSecret: string;
    /**
     * Expiration date for the combined token
     * @type {string}
     * @memberof MobileAppLogin
     */
    expirationDate: string;
}

/**
 * 
 * @export
 * @interface Modules
 */
export interface Modules {
    /**
     * Not readable. Only for input.
     * @type {boolean}
     * @memberof Modules
     */
    accounting?: boolean;
    /**
     * Not readable. Only for input.
     * @type {boolean}
     * @memberof Modules
     */
    invoice?: boolean;
    /**
     * Not readable. Only for input.
     * @type {boolean}
     * @memberof Modules
     */
    salary?: boolean;
    /**
     * Not readable. Only for input.
     * @type {boolean}
     * @memberof Modules
     */
    project?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Modules
     */
    ocr?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Modules
     */
    remit?: boolean;
    /**
     * Not readable. Only for input.
     * @type {boolean}
     * @memberof Modules
     */
    electronicVouchers?: boolean;
    /**
     * Not readable. Only for input.
     * @type {boolean}
     * @memberof Modules
     */
    electro?: boolean;
    /**
     * Not readable. Only for input.
     * @type {boolean}
     * @memberof Modules
     */
    vvs?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Modules
     */
    agro?: boolean;
    /**
     * Only readable for now
     * @type {boolean}
     * @memberof Modules
     */
    approveVoucher?: boolean;
}

/**
 * 
 * @export
 * @interface MonthlyStatus
 */
export interface MonthlyStatus {
    /**
     * 
     * @type {number}
     * @memberof MonthlyStatus
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof MonthlyStatus
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof MonthlyStatus
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof MonthlyStatus
     */
    url?: string;
    /**
     * 
     * @type {Employee}
     * @memberof MonthlyStatus
     */
    employee: Employee;
    /**
     * 
     * @type {string}
     * @memberof MonthlyStatus
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof MonthlyStatus
     */
    hoursPaid?: number;
    /**
     * 
     * @type {number}
     * @memberof MonthlyStatus
     */
    vacationTransferred?: number;
    /**
     * 
     * @type {number}
     * @memberof MonthlyStatus
     */
    vacationPaid?: number;
    /**
     * 
     * @type {Payslip}
     * @memberof MonthlyStatus
     */
    wagePayment?: Payslip;
    /**
     * 
     * @type {boolean}
     * @memberof MonthlyStatus
     */
    completed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MonthlyStatus
     */
    approved?: boolean;
    /**
     * 
     * @type {Employee}
     * @memberof MonthlyStatus
     */
    approvedBy?: Employee;
    /**
     * 
     * @type {string}
     * @memberof MonthlyStatus
     */
    approvedDate?: string;
}

/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Notification
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    date: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    link?: string;
}

/**
 * 
 * @export
 * @interface OccupationCode
 */
export interface OccupationCode {
    /**
     * 
     * @type {number}
     * @memberof OccupationCode
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof OccupationCode
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof OccupationCode
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof OccupationCode
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof OccupationCode
     */
    nameNO?: string;
    /**
     * 
     * @type {string}
     * @memberof OccupationCode
     */
    code?: string;
}

/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Order
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    url?: string;
    /**
     * 
     * @type {Customer}
     * @memberof Order
     */
    customer: Customer;
    /**
     * 
     * @type {Contact}
     * @memberof Order
     */
    contact?: Contact;
    /**
     * 
     * @type {Contact}
     * @memberof Order
     */
    attn?: Contact;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    receiverEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    overdueNoticeEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    reference?: string;
    /**
     * If the contact is not an employee
     * @type {Contact}
     * @memberof Order
     */
    ourContact?: Contact;
    /**
     * If the contact is an employee
     * @type {Employee}
     * @memberof Order
     */
    ourContactEmployee?: Employee;
    /**
     * 
     * @type {Department}
     * @memberof Order
     */
    department?: Department;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    orderDate: string;
    /**
     * 
     * @type {Project}
     * @memberof Order
     */
    project?: Project;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    invoiceComment?: string;
    /**
     * 
     * @type {Currency}
     * @memberof Order
     */
    currency?: Currency;
    /**
     * Number of days/months in which invoices created from this order is due
     * @type {number}
     * @memberof Order
     */
    invoicesDueIn?: number;
    /**
     * Set the time unit of invoicesDueIn. The special case RECURRING_DAY_OF_MONTH enables the due date to be fixed to a specific day of the month, in this case the fixed due date will automatically be set as standard on all invoices created from this order. Note that when RECURRING_DAY_OF_MONTH is set, the due date will be set to the last day of month if \"31\" is set in invoicesDueIn.
     * @type {string}
     * @memberof Order
     */
    invoicesDueInType?: Order.InvoicesDueInTypeEnum;
    /**
     * Show account statement - open posts on invoices created from this order
     * @type {boolean}
     * @memberof Order
     */
    isShowOpenPostsOnInvoices?: boolean;
    /**
     * Denotes if this order is closed. A closed order can no longer be invoiced unless it is opened again.
     * @type {boolean}
     * @memberof Order
     */
    isClosed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    deliveryDate: string;
    /**
     * Delivery address of this order. This can be a new or existing address
     * @type {Address}
     * @memberof Order
     */
    deliveryAddress?: Address;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    deliveryComment?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    isPrioritizeAmountsIncludingVat?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    orderLineSorting?: Order.OrderLineSortingEnum;
    /**
     * Order lines tied to the order
     * @type {Array&lt;OrderLine&gt;}
     * @memberof Order
     */
    orderLines?: Array<OrderLine>;
    /**
     * If true, the order is a subscription, which enables periodical invoicing of order lines
     * @type {boolean}
     * @memberof Order
     */
    isSubscription?: boolean;
    /**
     * Number of months/years the subscription shall run
     * @type {number}
     * @memberof Order
     */
    subscriptionDuration?: number;
    /**
     * The time unit of subscriptionDuration
     * @type {string}
     * @memberof Order
     */
    subscriptionDurationType?: Order.SubscriptionDurationTypeEnum;
    /**
     * Number of periods on each invoice
     * @type {number}
     * @memberof Order
     */
    subscriptionPeriodsOnInvoice?: number;
    /**
     * The time unit of subscriptionPeriodsOnInvoice
     * @type {string}
     * @memberof Order
     */
    subscriptionPeriodsOnInvoiceType?: Order.SubscriptionPeriodsOnInvoiceTypeEnum;
    /**
     * Invoicing in advance/in arrears
     * @type {string}
     * @memberof Order
     */
    subscriptionInvoicingTimeInAdvanceOrArrears?: Order.SubscriptionInvoicingTimeInAdvanceOrArrearsEnum;
    /**
     * Number of days/months invoicing in advance/in arrears
     * @type {number}
     * @memberof Order
     */
    subscriptionInvoicingTime?: number;
    /**
     * The time unit of subscriptionInvoicingTime
     * @type {string}
     * @memberof Order
     */
    subscriptionInvoicingTimeType?: Order.SubscriptionInvoicingTimeTypeEnum;
    /**
     * Automatic invoicing. Starts when the subscription is approved
     * @type {boolean}
     * @memberof Order
     */
    isSubscriptionAutoInvoicing?: boolean;
}

/**
 * @export
 * @namespace Order
 */
export namespace Order {
    /**
     * @export
     * @enum {string}
     */
    export enum InvoicesDueInTypeEnum {
        DAYS = <any> 'DAYS',
        MONTHS = <any> 'MONTHS',
        RECURRINGDAYOFMONTH = <any> 'RECURRING_DAY_OF_MONTH'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OrderLineSortingEnum {
        ID = <any> 'ID',
        PRODUCT = <any> 'PRODUCT',
        CUSTOM = <any> 'CUSTOM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubscriptionDurationTypeEnum {
        MONTHS = <any> 'MONTHS',
        YEAR = <any> 'YEAR'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubscriptionPeriodsOnInvoiceTypeEnum {
        MONTHS = <any> 'MONTHS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubscriptionInvoicingTimeInAdvanceOrArrearsEnum {
        ADVANCE = <any> 'ADVANCE',
        ARREARS = <any> 'ARREARS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubscriptionInvoicingTimeTypeEnum {
        DAYS = <any> 'DAYS',
        MONTHS = <any> 'MONTHS'
    }
}

/**
 * 
 * @export
 * @interface OrderLine
 */
export interface OrderLine {
    /**
     * 
     * @type {number}
     * @memberof OrderLine
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderLine
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof OrderLine
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof OrderLine
     */
    url?: string;
    /**
     * 
     * @type {Order}
     * @memberof OrderLine
     */
    order: Order;
    /**
     * 
     * @type {Product}
     * @memberof OrderLine
     */
    product?: Product;
    /**
     * 
     * @type {Inventory}
     * @memberof OrderLine
     */
    inventory?: Inventory;
    /**
     * 
     * @type {string}
     * @memberof OrderLine
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderLine
     */
    count?: number;
    /**
     * Unit price purchase (cost) excluding VAT in the order's currency
     * @type {number}
     * @memberof OrderLine
     */
    unitCostCurrency?: number;
    /**
     * Unit price of purchase excluding VAT in the order's currency
     * @type {number}
     * @memberof OrderLine
     */
    unitPriceExcludingVatCurrency?: number;
    /**
     * Unit price of purchase including VAT in the order's currency
     * @type {number}
     * @memberof OrderLine
     */
    unitPriceIncludingVatCurrency?: number;
    /**
     * The order line's currency. Determined by the order's currency.
     * @type {Currency}
     * @memberof OrderLine
     */
    currency?: Currency;
    /**
     * Markup given as a percentage (%)
     * @type {number}
     * @memberof OrderLine
     */
    markup?: number;
    /**
     * Discount given as a percentage (%)
     * @type {number}
     * @memberof OrderLine
     */
    discount?: number;
    /**
     * 
     * @type {VatType}
     * @memberof OrderLine
     */
    vatType?: VatType;
    /**
     * Total amount on order line excluding VAT in the order's currency
     * @type {number}
     * @memberof OrderLine
     */
    amountExcludingVatCurrency?: number;
    /**
     * Total amount on order line including VAT in the order's currency
     * @type {number}
     * @memberof OrderLine
     */
    amountIncludingVatCurrency?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderLine
     */
    isSubscription?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderLine
     */
    subscriptionPeriodStart?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderLine
     */
    subscriptionPeriodEnd?: string;
}

/**
 * 
 * @export
 * @interface Passenger
 */
export interface Passenger {
    /**
     * 
     * @type {number}
     * @memberof Passenger
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Passenger
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Passenger
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Passenger
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Passenger
     */
    name: string;
    /**
     * 
     * @type {MileageAllowance}
     * @memberof Passenger
     */
    mileageAllowance?: MileageAllowance;
}

/**
 * 
 * @export
 * @interface PaymentType
 */
export interface PaymentType {
    /**
     * 
     * @type {number}
     * @memberof PaymentType
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentType
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof PaymentType
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    description: string;
    /**
     * 
     * @type {Account}
     * @memberof PaymentType
     */
    debitAccount?: Account;
    /**
     * 
     * @type {Account}
     * @memberof PaymentType
     */
    creditAccount?: Account;
    /**
     * 
     * @type {VatType}
     * @memberof PaymentType
     */
    vatType?: VatType;
    /**
     * 
     * @type {Customer}
     * @memberof PaymentType
     */
    customer?: Customer;
    /**
     * 
     * @type {Supplier}
     * @memberof PaymentType
     */
    supplier?: Supplier;
}

/**
 * 
 * @export
 * @interface PaymentTypeOut
 */
export interface PaymentTypeOut {
    /**
     * 
     * @type {number}
     * @memberof PaymentTypeOut
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentTypeOut
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof PaymentTypeOut
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof PaymentTypeOut
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTypeOut
     */
    description: string;
    /**
     * true if it should be a deduction from the wage. The module PROVISIONSALARY is required to both view and change this setting
     * @type {boolean}
     * @memberof PaymentTypeOut
     */
    isBruttoWageDeduction?: boolean;
    /**
     * 
     * @type {Account}
     * @memberof PaymentTypeOut
     */
    creditAccount: Account;
    /**
     * true if the payment type should be available in supplier invoices
     * @type {boolean}
     * @memberof PaymentTypeOut
     */
    showIncomingInvoice?: boolean;
    /**
     * true if the payment type should be available in wage payments. The wage module is required to both view and change this setting
     * @type {boolean}
     * @memberof PaymentTypeOut
     */
    showWagePayment?: boolean;
    /**
     * true if the payment type should be available in vat returns
     * @type {boolean}
     * @memberof PaymentTypeOut
     */
    showVatReturns?: boolean;
    /**
     * true if the payment type should be available in period transactionsThe wage module is required to both view and change this setting
     * @type {boolean}
     * @memberof PaymentTypeOut
     */
    showWagePeriodTransaction?: boolean;
    /**
     * true if a separate voucher is required
     * @type {boolean}
     * @memberof PaymentTypeOut
     */
    requiresSeparateVoucher?: boolean;
    /**
     * determines in which order the types should be listed. No 1 is listed first
     * @type {number}
     * @memberof PaymentTypeOut
     */
    sequence?: number;
    /**
     * true if the payment type should be hidden from available payment types
     * @type {boolean}
     * @memberof PaymentTypeOut
     */
    isInactive?: boolean;
}

/**
 * 
 * @export
 * @interface Payslip
 */
export interface Payslip {
    /**
     * 
     * @type {number}
     * @memberof Payslip
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Payslip
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Payslip
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Payslip
     */
    url?: string;
    /**
     * 
     * @type {SalaryTransaction}
     * @memberof Payslip
     */
    transaction?: SalaryTransaction;
    /**
     * 
     * @type {Employee}
     * @memberof Payslip
     */
    employee: Employee;
    /**
     * Voucher date.
     * @type {string}
     * @memberof Payslip
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof Payslip
     */
    year?: number;
    /**
     * 
     * @type {number}
     * @memberof Payslip
     */
    month?: number;
    /**
     * Link to salary specifications.
     * @type {Array&lt;SalarySpecification&gt;}
     * @memberof Payslip
     */
    specifications?: Array<SalarySpecification>;
    /**
     * 
     * @type {number}
     * @memberof Payslip
     */
    vacationAllowanceAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof Payslip
     */
    grossAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof Payslip
     */
    amount?: number;
}

/**
 * 
 * @export
 * @interface PerDiemCompensation
 */
export interface PerDiemCompensation {
    /**
     * 
     * @type {number}
     * @memberof PerDiemCompensation
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PerDiemCompensation
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof PerDiemCompensation
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof PerDiemCompensation
     */
    url?: string;
    /**
     * 
     * @type {TravelExpense}
     * @memberof PerDiemCompensation
     */
    travelExpense?: TravelExpense;
    /**
     * 
     * @type {TravelExpenseRate}
     * @memberof PerDiemCompensation
     */
    rateType?: TravelExpenseRate;
    /**
     * 
     * @type {TravelExpenseRateCategory}
     * @memberof PerDiemCompensation
     */
    rateCategory?: TravelExpenseRateCategory;
    /**
     * 
     * @type {string}
     * @memberof PerDiemCompensation
     */
    zone?: string;
    /**
     * Set what sort of accommodation was had overnight.
     * @type {string}
     * @memberof PerDiemCompensation
     */
    overnightAccommodation?: PerDiemCompensation.OvernightAccommodationEnum;
    /**
     * 
     * @type {string}
     * @memberof PerDiemCompensation
     */
    location: string;
    /**
     * 
     * @type {string}
     * @memberof PerDiemCompensation
     */
    address?: string;
    /**
     * 
     * @type {number}
     * @memberof PerDiemCompensation
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof PerDiemCompensation
     */
    rate?: number;
    /**
     * 
     * @type {number}
     * @memberof PerDiemCompensation
     */
    amount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PerDiemCompensation
     */
    isDeductionForBreakfast?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PerDiemCompensation
     */
    isDeductionForLunch?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PerDiemCompensation
     */
    isDeductionForDinner?: boolean;
}

/**
 * @export
 * @namespace PerDiemCompensation
 */
export namespace PerDiemCompensation {
    /**
     * @export
     * @enum {string}
     */
    export enum OvernightAccommodationEnum {
        NONE = <any> 'NONE',
        HOTEL = <any> 'HOTEL',
        BOARDINGHOUSEWITHOUTCOOKING = <any> 'BOARDING_HOUSE_WITHOUT_COOKING',
        BOARDINGHOUSEWITHCOOKING = <any> 'BOARDING_HOUSE_WITH_COOKING'
    }
}

/**
 * 
 * @export
 * @interface Posting
 */
export interface Posting {
    /**
     * 
     * @type {number}
     * @memberof Posting
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Posting
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Posting
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Posting
     */
    url?: string;
    /**
     * 
     * @type {Voucher}
     * @memberof Posting
     */
    voucher?: Voucher;
    /**
     * 
     * @type {string}
     * @memberof Posting
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof Posting
     */
    description?: string;
    /**
     * 
     * @type {Account}
     * @memberof Posting
     */
    account?: Account;
    /**
     * 
     * @type {Customer}
     * @memberof Posting
     */
    customer?: Customer;
    /**
     * 
     * @type {Supplier}
     * @memberof Posting
     */
    supplier?: Supplier;
    /**
     * 
     * @type {Employee}
     * @memberof Posting
     */
    employee?: Employee;
    /**
     * 
     * @type {Project}
     * @memberof Posting
     */
    project?: Project;
    /**
     * 
     * @type {Product}
     * @memberof Posting
     */
    product?: Product;
    /**
     * 
     * @type {Department}
     * @memberof Posting
     */
    department?: Department;
    /**
     * 
     * @type {VatType}
     * @memberof Posting
     */
    vatType?: VatType;
    /**
     * 
     * @type {number}
     * @memberof Posting
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof Posting
     */
    amountCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof Posting
     */
    amountGross?: number;
    /**
     * 
     * @type {number}
     * @memberof Posting
     */
    amountGrossCurrency?: number;
    /**
     * 
     * @type {Currency}
     * @memberof Posting
     */
    currency?: Currency;
    /**
     * 
     * @type {CloseGroup}
     * @memberof Posting
     */
    closeGroup?: CloseGroup;
    /**
     * 
     * @type {string}
     * @memberof Posting
     */
    invoiceNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Posting
     */
    termOfPayment?: string;
    /**
     * 
     * @type {number}
     * @memberof Posting
     */
    row?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Posting
     */
    systemGenerated?: boolean;
}

/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Product
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    number?: string;
    /**
     * Price purchase (cost) excluding VAT in the product's currency
     * @type {number}
     * @memberof Product
     */
    costExcludingVatCurrency?: number;
    /**
     * Price of purchase excluding VAT in the product's currency
     * @type {number}
     * @memberof Product
     */
    priceExcludingVatCurrency?: number;
    /**
     * Price of purchase including VAT in the product's currency
     * @type {number}
     * @memberof Product
     */
    priceIncludingVatCurrency?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    isInactive?: boolean;
    /**
     * 
     * @type {ProductUnit}
     * @memberof Product
     */
    productUnit?: ProductUnit;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    isStockItem?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    stockOfGoods?: number;
    /**
     * 
     * @type {VatType}
     * @memberof Product
     */
    vatType?: VatType;
    /**
     * 
     * @type {Currency}
     * @memberof Product
     */
    currency?: Currency;
    /**
     * 
     * @type {Department}
     * @memberof Product
     */
    department?: Department;
    /**
     * 
     * @type {Account}
     * @memberof Product
     */
    account?: Account;
}

/**
 * 
 * @export
 * @interface ProductUnit
 */
export interface ProductUnit {
    /**
     * 
     * @type {number}
     * @memberof ProductUnit
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductUnit
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof ProductUnit
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof ProductUnit
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductUnit
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductUnit
     */
    nameShort?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductUnit
     */
    commonCode?: string;
}

/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Project
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    description?: string;
    /**
     * 
     * @type {Employee}
     * @memberof Project
     */
    projectManager: Employee;
    /**
     * 
     * @type {Department}
     * @memberof Project
     */
    department?: Department;
    /**
     * 
     * @type {Project}
     * @memberof Project
     */
    mainProject?: Project;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    endDate?: string;
    /**
     * The project's customer
     * @type {Customer}
     * @memberof Project
     */
    customer?: Customer;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    isClosed?: boolean;
    /**
     * Must be set to true.
     * @type {boolean}
     * @memberof Project
     */
    isInternal: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    isOffer?: boolean;
    /**
     * 
     * @type {ProjectCategory}
     * @memberof Project
     */
    projectCategory?: ProjectCategory;
    /**
     * Defines project name presentation in overviews.
     * @type {string}
     * @memberof Project
     */
    displayNameFormat?: Project.DisplayNameFormatEnum;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    externalAccountsNumber?: string;
}

/**
 * @export
 * @namespace Project
 */
export namespace Project {
    /**
     * @export
     * @enum {string}
     */
    export enum DisplayNameFormatEnum {
        STANDARD = <any> 'NAME_STANDARD',
        INCLCUSTOMERNAME = <any> 'NAME_INCL_CUSTOMER_NAME',
        INCLPARENTNAME = <any> 'NAME_INCL_PARENT_NAME',
        INCLPARENTNUMBER = <any> 'NAME_INCL_PARENT_NUMBER',
        INCLPARENTNAMEANDNUMBER = <any> 'NAME_INCL_PARENT_NAME_AND_NUMBER'
    }
}

/**
 * 
 * @export
 * @interface ProjectCategory
 */
export interface ProjectCategory {
    /**
     * 
     * @type {number}
     * @memberof ProjectCategory
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectCategory
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof ProjectCategory
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof ProjectCategory
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCategory
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCategory
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface Prospect
 */
export interface Prospect {
    /**
     * 
     * @type {number}
     * @memberof Prospect
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Prospect
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Prospect
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Prospect
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Prospect
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Prospect
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Prospect
     */
    createdDate: string;
    /**
     * 
     * @type {Customer}
     * @memberof Prospect
     */
    customer?: Customer;
    /**
     * 
     * @type {Employee}
     * @memberof Prospect
     */
    salesEmployee?: Employee;
    /**
     * 
     * @type {boolean}
     * @memberof Prospect
     */
    isClosed?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Prospect
     */
    closedReason?: number;
    /**
     * 
     * @type {string}
     * @memberof Prospect
     */
    closedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Prospect
     */
    competitor?: string;
    /**
     * 
     * @type {number}
     * @memberof Prospect
     */
    prospectType?: number;
    /**
     * The project connected to this prospect.
     * @type {Project}
     * @memberof Prospect
     */
    project?: Project;
    /**
     * The project offer connected to this prospect.
     * @type {Project}
     * @memberof Prospect
     */
    projectOffer?: Project;
    /**
     * The estimated start date for income on the prospect.
     * @type {string}
     * @memberof Prospect
     */
    finalIncomeDate?: string;
    /**
     * The estimated startup fee on this prospect.
     * @type {number}
     * @memberof Prospect
     */
    finalInitialValue?: number;
    /**
     * The estimated monthly fee on this prospect.
     * @type {number}
     * @memberof Prospect
     */
    finalMonthlyValue?: number;
    /**
     * Tripletex specific.
     * @type {number}
     * @memberof Prospect
     */
    finalAdditionalServicesValue?: number;
    /**
     * The estimated total fee on this prospect.
     * @type {number}
     * @memberof Prospect
     */
    totalValue?: number;
}

/**
 * 
 * @export
 * @interface RemunerationType
 */
export interface RemunerationType {
    /**
     * 
     * @type {number}
     * @memberof RemunerationType
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof RemunerationType
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof RemunerationType
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof RemunerationType
     */
    url?: string;
    /**
     * Defines the remuneration type option. 
     * @type {string}
     * @memberof RemunerationType
     */
    remunerationType: RemunerationType.RemunerationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RemunerationType
     */
    nameNO?: string;
    /**
     * 
     * @type {string}
     * @memberof RemunerationType
     */
    code?: string;
}

/**
 * @export
 * @namespace RemunerationType
 */
export namespace RemunerationType {
    /**
     * @export
     * @enum {string}
     */
    export enum RemunerationTypeEnum {
        TYPE = <any> 'REMUNERATION_TYPE'
    }
}

/**
 * 
 * @export
 * @interface ResponseWrapperAccommodationAllowance
 */
export interface ResponseWrapperAccommodationAllowance {
    /**
     * 
     * @type {AccommodationAllowance}
     * @memberof ResponseWrapperAccommodationAllowance
     */
    value?: AccommodationAllowance;
}

/**
 * 
 * @export
 * @interface ResponseWrapperAccount
 */
export interface ResponseWrapperAccount {
    /**
     * 
     * @type {Account}
     * @memberof ResponseWrapperAccount
     */
    value?: Account;
}

/**
 * 
 * @export
 * @interface ResponseWrapperAccountingPeriod
 */
export interface ResponseWrapperAccountingPeriod {
    /**
     * 
     * @type {AccountingPeriod}
     * @memberof ResponseWrapperAccountingPeriod
     */
    value?: AccountingPeriod;
}

/**
 * 
 * @export
 * @interface ResponseWrapperActivity
 */
export interface ResponseWrapperActivity {
    /**
     * 
     * @type {Activity}
     * @memberof ResponseWrapperActivity
     */
    value?: Activity;
}

/**
 * 
 * @export
 * @interface ResponseWrapperAddress
 */
export interface ResponseWrapperAddress {
    /**
     * 
     * @type {Address}
     * @memberof ResponseWrapperAddress
     */
    value?: Address;
}

/**
 * 
 * @export
 * @interface ResponseWrapperAnnualAccount
 */
export interface ResponseWrapperAnnualAccount {
    /**
     * 
     * @type {AnnualAccount}
     * @memberof ResponseWrapperAnnualAccount
     */
    value?: AnnualAccount;
}

/**
 * 
 * @export
 * @interface ResponseWrapperApiConsumer
 */
export interface ResponseWrapperApiConsumer {
    /**
     * 
     * @type {ApiConsumer}
     * @memberof ResponseWrapperApiConsumer
     */
    value?: ApiConsumer;
}

/**
 * 
 * @export
 * @interface ResponseWrapperAppSpecific
 */
export interface ResponseWrapperAppSpecific {
    /**
     * 
     * @type {AppSpecific}
     * @memberof ResponseWrapperAppSpecific
     */
    value?: AppSpecific;
}

/**
 * 
 * @export
 * @interface ResponseWrapperBankReconciliation
 */
export interface ResponseWrapperBankReconciliation {
    /**
     * 
     * @type {BankReconciliation}
     * @memberof ResponseWrapperBankReconciliation
     */
    value?: BankReconciliation;
}

/**
 * 
 * @export
 * @interface ResponseWrapperBankReconciliationMatch
 */
export interface ResponseWrapperBankReconciliationMatch {
    /**
     * 
     * @type {BankReconciliationMatch}
     * @memberof ResponseWrapperBankReconciliationMatch
     */
    value?: BankReconciliationMatch;
}

/**
 * 
 * @export
 * @interface ResponseWrapperBankReconciliationPaymentType
 */
export interface ResponseWrapperBankReconciliationPaymentType {
    /**
     * 
     * @type {BankReconciliationPaymentType}
     * @memberof ResponseWrapperBankReconciliationPaymentType
     */
    value?: BankReconciliationPaymentType;
}

/**
 * 
 * @export
 * @interface ResponseWrapperBankStatement
 */
export interface ResponseWrapperBankStatement {
    /**
     * 
     * @type {BankStatement}
     * @memberof ResponseWrapperBankStatement
     */
    value?: BankStatement;
}

/**
 * 
 * @export
 * @interface ResponseWrapperBankTransaction
 */
export interface ResponseWrapperBankTransaction {
    /**
     * 
     * @type {BankTransaction}
     * @memberof ResponseWrapperBankTransaction
     */
    value?: BankTransaction;
}

/**
 * 
 * @export
 * @interface ResponseWrapperBanner
 */
export interface ResponseWrapperBanner {
    /**
     * 
     * @type {Banner}
     * @memberof ResponseWrapperBanner
     */
    value?: Banner;
}

/**
 * 
 * @export
 * @interface ResponseWrapperBoolean
 */
export interface ResponseWrapperBoolean {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseWrapperBoolean
     */
    value?: boolean;
}

/**
 * 
 * @export
 * @interface ResponseWrapperCloseGroup
 */
export interface ResponseWrapperCloseGroup {
    /**
     * 
     * @type {CloseGroup}
     * @memberof ResponseWrapperCloseGroup
     */
    value?: CloseGroup;
}

/**
 * 
 * @export
 * @interface ResponseWrapperCompany
 */
export interface ResponseWrapperCompany {
    /**
     * 
     * @type {Company}
     * @memberof ResponseWrapperCompany
     */
    value?: Company;
}

/**
 * 
 * @export
 * @interface ResponseWrapperConsumerToken
 */
export interface ResponseWrapperConsumerToken {
    /**
     * 
     * @type {ConsumerToken}
     * @memberof ResponseWrapperConsumerToken
     */
    value?: ConsumerToken;
}

/**
 * 
 * @export
 * @interface ResponseWrapperContact
 */
export interface ResponseWrapperContact {
    /**
     * 
     * @type {Contact}
     * @memberof ResponseWrapperContact
     */
    value?: Contact;
}

/**
 * 
 * @export
 * @interface ResponseWrapperCost
 */
export interface ResponseWrapperCost {
    /**
     * 
     * @type {Cost}
     * @memberof ResponseWrapperCost
     */
    value?: Cost;
}

/**
 * 
 * @export
 * @interface ResponseWrapperCountry
 */
export interface ResponseWrapperCountry {
    /**
     * 
     * @type {Country}
     * @memberof ResponseWrapperCountry
     */
    value?: Country;
}

/**
 * 
 * @export
 * @interface ResponseWrapperCurrency
 */
export interface ResponseWrapperCurrency {
    /**
     * 
     * @type {Currency}
     * @memberof ResponseWrapperCurrency
     */
    value?: Currency;
}

/**
 * 
 * @export
 * @interface ResponseWrapperCustomer
 */
export interface ResponseWrapperCustomer {
    /**
     * 
     * @type {Customer}
     * @memberof ResponseWrapperCustomer
     */
    value?: Customer;
}

/**
 * 
 * @export
 * @interface ResponseWrapperCustomerCategory
 */
export interface ResponseWrapperCustomerCategory {
    /**
     * 
     * @type {CustomerCategory}
     * @memberof ResponseWrapperCustomerCategory
     */
    value?: CustomerCategory;
}

/**
 * 
 * @export
 * @interface ResponseWrapperDepartment
 */
export interface ResponseWrapperDepartment {
    /**
     * 
     * @type {Department}
     * @memberof ResponseWrapperDepartment
     */
    value?: Department;
}

/**
 * 
 * @export
 * @interface ResponseWrapperDouble
 */
export interface ResponseWrapperDouble {
    /**
     * 
     * @type {number}
     * @memberof ResponseWrapperDouble
     */
    value?: number;
}

/**
 * 
 * @export
 * @interface ResponseWrapperEmployee
 */
export interface ResponseWrapperEmployee {
    /**
     * 
     * @type {Employee}
     * @memberof ResponseWrapperEmployee
     */
    value?: Employee;
}

/**
 * 
 * @export
 * @interface ResponseWrapperEmployeeToken
 */
export interface ResponseWrapperEmployeeToken {
    /**
     * 
     * @type {EmployeeToken}
     * @memberof ResponseWrapperEmployeeToken
     */
    value?: EmployeeToken;
}

/**
 * 
 * @export
 * @interface ResponseWrapperEmployment
 */
export interface ResponseWrapperEmployment {
    /**
     * 
     * @type {Employment}
     * @memberof ResponseWrapperEmployment
     */
    value?: Employment;
}

/**
 * 
 * @export
 * @interface ResponseWrapperEmploymentDetails
 */
export interface ResponseWrapperEmploymentDetails {
    /**
     * 
     * @type {EmploymentDetails}
     * @memberof ResponseWrapperEmploymentDetails
     */
    value?: EmploymentDetails;
}

/**
 * 
 * @export
 * @interface ResponseWrapperEntitlement
 */
export interface ResponseWrapperEntitlement {
    /**
     * 
     * @type {Entitlement}
     * @memberof ResponseWrapperEntitlement
     */
    value?: Entitlement;
}

/**
 * 
 * @export
 * @interface ResponseWrapperInteger
 */
export interface ResponseWrapperInteger {
    /**
     * 
     * @type {number}
     * @memberof ResponseWrapperInteger
     */
    value?: number;
}

/**
 * 
 * @export
 * @interface ResponseWrapperInventory
 */
export interface ResponseWrapperInventory {
    /**
     * 
     * @type {Inventory}
     * @memberof ResponseWrapperInventory
     */
    value?: Inventory;
}

/**
 * 
 * @export
 * @interface ResponseWrapperInvoice
 */
export interface ResponseWrapperInvoice {
    /**
     * 
     * @type {Invoice}
     * @memberof ResponseWrapperInvoice
     */
    value?: Invoice;
}

/**
 * 
 * @export
 * @interface ResponseWrapperLeaveOfAbsence
 */
export interface ResponseWrapperLeaveOfAbsence {
    /**
     * 
     * @type {LeaveOfAbsence}
     * @memberof ResponseWrapperLeaveOfAbsence
     */
    value?: LeaveOfAbsence;
}

/**
 * 
 * @export
 * @interface ResponseWrapperListJob
 */
export interface ResponseWrapperListJob {
    /**
     * 
     * @type {Array&lt;Job&gt;}
     * @memberof ResponseWrapperListJob
     */
    value?: Array<Job>;
}

/**
 * 
 * @export
 * @interface ResponseWrapperLoggedInUserInfoDTO
 */
export interface ResponseWrapperLoggedInUserInfoDTO {
    /**
     * 
     * @type {LoggedInUserInfoDTO}
     * @memberof ResponseWrapperLoggedInUserInfoDTO
     */
    value?: LoggedInUserInfoDTO;
}

/**
 * 
 * @export
 * @interface ResponseWrapperMapStringEventInfoDescription
 */
export interface ResponseWrapperMapStringEventInfoDescription {
    /**
     * 
     * @type {{ [key: string]: EventInfoDescription; }}
     * @memberof ResponseWrapperMapStringEventInfoDescription
     */
    value?: { [key: string]: EventInfoDescription; };
}

/**
 * 
 * @export
 * @interface ResponseWrapperMileageAllowance
 */
export interface ResponseWrapperMileageAllowance {
    /**
     * 
     * @type {MileageAllowance}
     * @memberof ResponseWrapperMileageAllowance
     */
    value?: MileageAllowance;
}

/**
 * 
 * @export
 * @interface ResponseWrapperModules
 */
export interface ResponseWrapperModules {
    /**
     * 
     * @type {Modules}
     * @memberof ResponseWrapperModules
     */
    value?: Modules;
}

/**
 * 
 * @export
 * @interface ResponseWrapperMonthlyStatus
 */
export interface ResponseWrapperMonthlyStatus {
    /**
     * 
     * @type {MonthlyStatus}
     * @memberof ResponseWrapperMonthlyStatus
     */
    value?: MonthlyStatus;
}

/**
 * 
 * @export
 * @interface ResponseWrapperNotification
 */
export interface ResponseWrapperNotification {
    /**
     * 
     * @type {Notification}
     * @memberof ResponseWrapperNotification
     */
    value?: Notification;
}

/**
 * 
 * @export
 * @interface ResponseWrapperObject
 */
export interface ResponseWrapperObject {
    /**
     * 
     * @type {any}
     * @memberof ResponseWrapperObject
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface ResponseWrapperOrder
 */
export interface ResponseWrapperOrder {
    /**
     * 
     * @type {Order}
     * @memberof ResponseWrapperOrder
     */
    value?: Order;
}

/**
 * 
 * @export
 * @interface ResponseWrapperOrderLine
 */
export interface ResponseWrapperOrderLine {
    /**
     * 
     * @type {OrderLine}
     * @memberof ResponseWrapperOrderLine
     */
    value?: OrderLine;
}

/**
 * 
 * @export
 * @interface ResponseWrapperPassenger
 */
export interface ResponseWrapperPassenger {
    /**
     * 
     * @type {Passenger}
     * @memberof ResponseWrapperPassenger
     */
    value?: Passenger;
}

/**
 * 
 * @export
 * @interface ResponseWrapperPaymentType
 */
export interface ResponseWrapperPaymentType {
    /**
     * 
     * @type {PaymentType}
     * @memberof ResponseWrapperPaymentType
     */
    value?: PaymentType;
}

/**
 * 
 * @export
 * @interface ResponseWrapperPaymentTypeOut
 */
export interface ResponseWrapperPaymentTypeOut {
    /**
     * 
     * @type {PaymentTypeOut}
     * @memberof ResponseWrapperPaymentTypeOut
     */
    value?: PaymentTypeOut;
}

/**
 * 
 * @export
 * @interface ResponseWrapperPayslip
 */
export interface ResponseWrapperPayslip {
    /**
     * 
     * @type {Payslip}
     * @memberof ResponseWrapperPayslip
     */
    value?: Payslip;
}

/**
 * 
 * @export
 * @interface ResponseWrapperPerDiemCompensation
 */
export interface ResponseWrapperPerDiemCompensation {
    /**
     * 
     * @type {PerDiemCompensation}
     * @memberof ResponseWrapperPerDiemCompensation
     */
    value?: PerDiemCompensation;
}

/**
 * 
 * @export
 * @interface ResponseWrapperPosting
 */
export interface ResponseWrapperPosting {
    /**
     * 
     * @type {Posting}
     * @memberof ResponseWrapperPosting
     */
    value?: Posting;
}

/**
 * 
 * @export
 * @interface ResponseWrapperProduct
 */
export interface ResponseWrapperProduct {
    /**
     * 
     * @type {Product}
     * @memberof ResponseWrapperProduct
     */
    value?: Product;
}

/**
 * 
 * @export
 * @interface ResponseWrapperProductUnit
 */
export interface ResponseWrapperProductUnit {
    /**
     * 
     * @type {ProductUnit}
     * @memberof ResponseWrapperProductUnit
     */
    value?: ProductUnit;
}

/**
 * 
 * @export
 * @interface ResponseWrapperProject
 */
export interface ResponseWrapperProject {
    /**
     * 
     * @type {Project}
     * @memberof ResponseWrapperProject
     */
    value?: Project;
}

/**
 * 
 * @export
 * @interface ResponseWrapperProjectCategory
 */
export interface ResponseWrapperProjectCategory {
    /**
     * 
     * @type {ProjectCategory}
     * @memberof ResponseWrapperProjectCategory
     */
    value?: ProjectCategory;
}

/**
 * 
 * @export
 * @interface ResponseWrapperProspect
 */
export interface ResponseWrapperProspect {
    /**
     * 
     * @type {Prospect}
     * @memberof ResponseWrapperProspect
     */
    value?: Prospect;
}

/**
 * 
 * @export
 * @interface ResponseWrapperSalarySpecification
 */
export interface ResponseWrapperSalarySpecification {
    /**
     * 
     * @type {SalarySpecification}
     * @memberof ResponseWrapperSalarySpecification
     */
    value?: SalarySpecification;
}

/**
 * 
 * @export
 * @interface ResponseWrapperSalaryTransaction
 */
export interface ResponseWrapperSalaryTransaction {
    /**
     * 
     * @type {SalaryTransaction}
     * @memberof ResponseWrapperSalaryTransaction
     */
    value?: SalaryTransaction;
}

/**
 * 
 * @export
 * @interface ResponseWrapperSalaryType
 */
export interface ResponseWrapperSalaryType {
    /**
     * 
     * @type {SalaryType}
     * @memberof ResponseWrapperSalaryType
     */
    value?: SalaryType;
}

/**
 * 
 * @export
 * @interface ResponseWrapperSessionToken
 */
export interface ResponseWrapperSessionToken {
    /**
     * 
     * @type {SessionToken}
     * @memberof ResponseWrapperSessionToken
     */
    value?: SessionToken;
}

/**
 * 
 * @export
 * @interface ResponseWrapperStandardTime
 */
export interface ResponseWrapperStandardTime {
    /**
     * 
     * @type {StandardTime}
     * @memberof ResponseWrapperStandardTime
     */
    value?: StandardTime;
}

/**
 * 
 * @export
 * @interface ResponseWrapperString
 */
export interface ResponseWrapperString {
    /**
     * 
     * @type {string}
     * @memberof ResponseWrapperString
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface ResponseWrapperSubscription
 */
export interface ResponseWrapperSubscription {
    /**
     * 
     * @type {Subscription}
     * @memberof ResponseWrapperSubscription
     */
    value?: Subscription;
}

/**
 * 
 * @export
 * @interface ResponseWrapperSupplier
 */
export interface ResponseWrapperSupplier {
    /**
     * 
     * @type {Supplier}
     * @memberof ResponseWrapperSupplier
     */
    value?: Supplier;
}

/**
 * 
 * @export
 * @interface ResponseWrapperSystemMessage
 */
export interface ResponseWrapperSystemMessage {
    /**
     * 
     * @type {SystemMessage}
     * @memberof ResponseWrapperSystemMessage
     */
    value?: SystemMessage;
}

/**
 * 
 * @export
 * @interface ResponseWrapperTimeClock
 */
export interface ResponseWrapperTimeClock {
    /**
     * 
     * @type {TimeClock}
     * @memberof ResponseWrapperTimeClock
     */
    value?: TimeClock;
}

/**
 * 
 * @export
 * @interface ResponseWrapperTimesheetEntry
 */
export interface ResponseWrapperTimesheetEntry {
    /**
     * 
     * @type {TimesheetEntry}
     * @memberof ResponseWrapperTimesheetEntry
     */
    value?: TimesheetEntry;
}

/**
 * 
 * @export
 * @interface ResponseWrapperTravelCostCategory
 */
export interface ResponseWrapperTravelCostCategory {
    /**
     * 
     * @type {TravelCostCategory}
     * @memberof ResponseWrapperTravelCostCategory
     */
    value?: TravelCostCategory;
}

/**
 * 
 * @export
 * @interface ResponseWrapperTravelExpense
 */
export interface ResponseWrapperTravelExpense {
    /**
     * 
     * @type {TravelExpense}
     * @memberof ResponseWrapperTravelExpense
     */
    value?: TravelExpense;
}

/**
 * 
 * @export
 * @interface ResponseWrapperTravelExpenseRate
 */
export interface ResponseWrapperTravelExpenseRate {
    /**
     * 
     * @type {TravelExpenseRate}
     * @memberof ResponseWrapperTravelExpenseRate
     */
    value?: TravelExpenseRate;
}

/**
 * 
 * @export
 * @interface ResponseWrapperTravelExpenseRateCategory
 */
export interface ResponseWrapperTravelExpenseRateCategory {
    /**
     * 
     * @type {TravelExpenseRateCategory}
     * @memberof ResponseWrapperTravelExpenseRateCategory
     */
    value?: TravelExpenseRateCategory;
}

/**
 * 
 * @export
 * @interface ResponseWrapperTravelExpenseRateCategoryGroup
 */
export interface ResponseWrapperTravelExpenseRateCategoryGroup {
    /**
     * 
     * @type {TravelExpenseRateCategoryGroup}
     * @memberof ResponseWrapperTravelExpenseRateCategoryGroup
     */
    value?: TravelExpenseRateCategoryGroup;
}

/**
 * 
 * @export
 * @interface ResponseWrapperTravelPaymentType
 */
export interface ResponseWrapperTravelPaymentType {
    /**
     * 
     * @type {TravelPaymentType}
     * @memberof ResponseWrapperTravelPaymentType
     */
    value?: TravelPaymentType;
}

/**
 * 
 * @export
 * @interface ResponseWrapperTripletexAccountReturn
 */
export interface ResponseWrapperTripletexAccountReturn {
    /**
     * 
     * @type {TripletexAccountReturn}
     * @memberof ResponseWrapperTripletexAccountReturn
     */
    value?: TripletexAccountReturn;
}

/**
 * 
 * @export
 * @interface ResponseWrapperUnreadCountDTO
 */
export interface ResponseWrapperUnreadCountDTO {
    /**
     * 
     * @type {UnreadCountDTO}
     * @memberof ResponseWrapperUnreadCountDTO
     */
    value?: UnreadCountDTO;
}

/**
 * 
 * @export
 * @interface ResponseWrapperVatType
 */
export interface ResponseWrapperVatType {
    /**
     * 
     * @type {VatType}
     * @memberof ResponseWrapperVatType
     */
    value?: VatType;
}

/**
 * 
 * @export
 * @interface ResponseWrapperVoucher
 */
export interface ResponseWrapperVoucher {
    /**
     * 
     * @type {Voucher}
     * @memberof ResponseWrapperVoucher
     */
    value?: Voucher;
}

/**
 * 
 * @export
 * @interface ResponseWrapperVoucherType
 */
export interface ResponseWrapperVoucherType {
    /**
     * 
     * @type {VoucherType}
     * @memberof ResponseWrapperVoucherType
     */
    value?: VoucherType;
}

/**
 * 
 * @export
 * @interface ResponseWrapperWeeklyStatus
 */
export interface ResponseWrapperWeeklyStatus {
    /**
     * 
     * @type {WeeklyStatus}
     * @memberof ResponseWrapperWeeklyStatus
     */
    value?: WeeklyStatus;
}

/**
 * 
 * @export
 * @interface Result
 */
export interface Result {
    /**
     * 
     * @type {string}
     * @memberof Result
     */
    file?: Result.FileEnum;
    /**
     * 
     * @type {number}
     * @memberof Result
     */
    line?: number;
    /**
     * 
     * @type {string}
     * @memberof Result
     */
    type?: Result.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Result
     */
    number?: string;
    /**
     * 
     * @type {number}
     * @memberof Result
     */
    dbId?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Result
     */
    input?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Result
     */
    output?: { [key: string]: any; };
    /**
     * 
     * @type {Array&lt;string&gt;}
     * @memberof Result
     */
    log?: Array<string>;
    /**
     * 
     * @type {CSVRecord}
     * @memberof Result
     */
    record?: CSVRecord;
    /**
     * 
     * @type {AbstractDTO}
     * @memberof Result
     */
    dto?: AbstractDTO;
}

/**
 * @export
 * @namespace Result
 */
export namespace Result {
    /**
     * @export
     * @enum {string}
     */
    export enum FileEnum {
        DEPARTMENTS = <any> 'DEPARTMENTS',
        EMPLOYEES = <any> 'EMPLOYEES',
        VATCODES = <any> 'VATCODES',
        ACCOUNTS = <any> 'ACCOUNTS',
        CUSTOMERS = <any> 'CUSTOMERS',
        CUSTOMERSCATEGORIES = <any> 'CUSTOMERS_CATEGORIES',
        VENDORS = <any> 'VENDORS',
        VENDORSCATEGORIES = <any> 'VENDORS_CATEGORIES',
        CONTACTS = <any> 'CONTACTS',
        DELIVERYADDRESSES = <any> 'DELIVERY_ADDRESSES',
        PRODUCTS = <any> 'PRODUCTS',
        PRODUCTSCATEGORIES = <any> 'PRODUCTS_CATEGORIES',
        PROJECTS = <any> 'PROJECTS',
        PROJECTSCATEGORIES = <any> 'PROJECTS_CATEGORIES'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        IGNORED = <any> 'IGNORED',
        UPDATED = <any> 'UPDATED',
        CREATED = <any> 'CREATED',
        ERROR = <any> 'ERROR'
    }
}

/**
 * 
 * @export
 * @interface SalarySpecification
 */
export interface SalarySpecification {
    /**
     * 
     * @type {number}
     * @memberof SalarySpecification
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof SalarySpecification
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof SalarySpecification
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof SalarySpecification
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof SalarySpecification
     */
    rate: number;
    /**
     * 
     * @type {number}
     * @memberof SalarySpecification
     */
    count: number;
    /**
     * 
     * @type {Project}
     * @memberof SalarySpecification
     */
    project?: Project;
    /**
     * 
     * @type {Department}
     * @memberof SalarySpecification
     */
    department?: Department;
    /**
     * 
     * @type {SalaryType}
     * @memberof SalarySpecification
     */
    salaryType: SalaryType;
    /**
     * 
     * @type {Payslip}
     * @memberof SalarySpecification
     */
    payslip?: Payslip;
    /**
     * 
     * @type {Employee}
     * @memberof SalarySpecification
     */
    employee?: Employee;
    /**
     * 
     * @type {string}
     * @memberof SalarySpecification
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof SalarySpecification
     */
    year?: number;
    /**
     * 
     * @type {number}
     * @memberof SalarySpecification
     */
    month?: number;
    /**
     * 
     * @type {number}
     * @memberof SalarySpecification
     */
    amount?: number;
}

/**
 * 
 * @export
 * @interface SalaryTransaction
 */
export interface SalaryTransaction {
    /**
     * 
     * @type {number}
     * @memberof SalaryTransaction
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof SalaryTransaction
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof SalaryTransaction
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof SalaryTransaction
     */
    url?: string;
    /**
     * Voucher date.
     * @type {string}
     * @memberof SalaryTransaction
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof SalaryTransaction
     */
    year: number;
    /**
     * 
     * @type {number}
     * @memberof SalaryTransaction
     */
    month: number;
    /**
     * Link to individual payslip objects.
     * @type {Array&lt;Payslip&gt;}
     * @memberof SalaryTransaction
     */
    payslips: Array<Payslip>;
}

/**
 * 
 * @export
 * @interface SalaryType
 */
export interface SalaryType {
    /**
     * 
     * @type {number}
     * @memberof SalaryType
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof SalaryType
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof SalaryType
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof SalaryType
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof SalaryType
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof SalaryType
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SalaryType
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface SessionToken
 */
export interface SessionToken {
    /**
     * 
     * @type {number}
     * @memberof SessionToken
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof SessionToken
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof SessionToken
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof SessionToken
     */
    url?: string;
    /**
     * 
     * @type {ConsumerToken}
     * @memberof SessionToken
     */
    consumerToken?: ConsumerToken;
    /**
     * 
     * @type {EmployeeToken}
     * @memberof SessionToken
     */
    employeeToken?: EmployeeToken;
    /**
     * 
     * @type {string}
     * @memberof SessionToken
     */
    expirationDate: string;
    /**
     * 
     * @type {string}
     * @memberof SessionToken
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionToken
     */
    encryptionKey?: string;
}

/**
 * 
 * @export
 * @interface SmartScanWebhook
 */
export interface SmartScanWebhook {
    /**
     * 
     * @type {string}
     * @memberof SmartScanWebhook
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartScanWebhook
     */
    documentId?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartScanWebhook
     */
    clientDocumentId?: string;
}

/**
 * 
 * @export
 * @interface StandardTime
 */
export interface StandardTime {
    /**
     * 
     * @type {number}
     * @memberof StandardTime
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof StandardTime
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof StandardTime
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof StandardTime
     */
    url?: string;
    /**
     * 
     * @type {Employee}
     * @memberof StandardTime
     */
    employee?: Employee;
    /**
     * 
     * @type {string}
     * @memberof StandardTime
     */
    fromDate: string;
    /**
     * 
     * @type {number}
     * @memberof StandardTime
     */
    hoursPerDay: number;
}

/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Subscription
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    url?: string;
    /**
     * Event name (from v2/event) you wish to subscribe to. Form should be: *subject.verb*.
     * @type {string}
     * @memberof Subscription
     */
    event: string;
    /**
     * The callback URL used for subscriptions (including authentication tokens). Must be absolute and use HTTPS.
     * @type {string}
     * @memberof Subscription
     */
    targetUrl: string;
    /**
     * The fields in the object delivered with the notification callback, nested as in other API calls.
     * @type {string}
     * @memberof Subscription
     */
    fields?: string;
    /**
     * The status of the subscription.
     * @type {string}
     * @memberof Subscription
     */
    status?: Subscription.StatusEnum;
}

/**
 * @export
 * @namespace Subscription
 */
export namespace Subscription {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        DISABLED = <any> 'DISABLED',
        DISABLEDTOOMANYERRORS = <any> 'DISABLED_TOO_MANY_ERRORS',
        DISABLEDRATELIMITEXCEEDED = <any> 'DISABLED_RATE_LIMIT_EXCEEDED',
        DISABLEDMISUSE = <any> 'DISABLED_MISUSE'
    }
}

/**
 * 
 * @export
 * @interface Supplier
 */
export interface Supplier {
    /**
     * 
     * @type {number}
     * @memberof Supplier
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Supplier
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Supplier
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    organizationNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof Supplier
     */
    supplierNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof Supplier
     */
    customerNumber?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Supplier
     */
    isSupplier?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Supplier
     */
    isCustomer?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Supplier
     */
    isInactive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    email?: string;
    /**
     * List of the bank account numbers for this supplier.  Norwegian bank account numbers only.
     * @type {Array&lt;string&gt;}
     * @memberof Supplier
     */
    bankAccounts?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    invoiceEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    phoneNumberMobile?: string;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Supplier
     */
    isPrivateIndividual?: boolean;
    /**
     * 
     * @type {Employee}
     * @memberof Supplier
     */
    accountManager?: Employee;
    /**
     * 
     * @type {Address}
     * @memberof Supplier
     */
    postalAddress?: Address;
    /**
     * 
     * @type {Address}
     * @memberof Supplier
     */
    physicalAddress?: Address;
    /**
     * 
     * @type {Address}
     * @memberof Supplier
     */
    deliveryAddress?: Address;
    /**
     * Category 1 of this supplier
     * @type {CustomerCategory}
     * @memberof Supplier
     */
    category1?: CustomerCategory;
    /**
     * Category 2 of this supplier
     * @type {CustomerCategory}
     * @memberof Supplier
     */
    category2?: CustomerCategory;
    /**
     * Category 3 of this supplier
     * @type {CustomerCategory}
     * @memberof Supplier
     */
    category3?: CustomerCategory;
}

/**
 * 
 * @export
 * @interface SupplierBalance
 */
export interface SupplierBalance {
    /**
     * 
     * @type {Supplier}
     * @memberof SupplierBalance
     */
    supplier?: Supplier;
    /**
     * 
     * @type {number}
     * @memberof SupplierBalance
     */
    balanceIn?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierBalance
     */
    balanceChange?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierBalance
     */
    balanceOut?: number;
    /**
     * Currencies that have been used prior to this period, for the given filter
     * @type {Array&lt;Currency&gt;}
     * @memberof SupplierBalance
     */
    balanceInCurrencies?: Array<Currency>;
    /**
     * 
     * @type {number}
     * @memberof SupplierBalance
     */
    sumAmountNegative?: number;
}

/**
 * 
 * @export
 * @interface SystemMessage
 */
export interface SystemMessage {
    /**
     * 
     * @type {string}
     * @memberof SystemMessage
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface TimeClock
 */
export interface TimeClock {
    /**
     * 
     * @type {number}
     * @memberof TimeClock
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeClock
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof TimeClock
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof TimeClock
     */
    url?: string;
    /**
     * 
     * @type {Employee}
     * @memberof TimeClock
     */
    employee: Employee;
    /**
     * 
     * @type {Project}
     * @memberof TimeClock
     */
    project?: Project;
    /**
     * 
     * @type {Activity}
     * @memberof TimeClock
     */
    activity?: Activity;
    /**
     * 
     * @type {TimesheetEntry}
     * @memberof TimeClock
     */
    timesheetEntry?: TimesheetEntry;
    /**
     * 
     * @type {string}
     * @memberof TimeClock
     */
    date: string;
    /**
     * 
     * @type {string}
     * @memberof TimeClock
     */
    timeStart: string;
    /**
     * 
     * @type {string}
     * @memberof TimeClock
     */
    timeStop?: string;
    /**
     * 
     * @type {number}
     * @memberof TimeClock
     */
    hoursStart?: number;
}

/**
 * 
 * @export
 * @interface TimesheetEntry
 */
export interface TimesheetEntry {
    /**
     * 
     * @type {number}
     * @memberof TimesheetEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof TimesheetEntry
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof TimesheetEntry
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof TimesheetEntry
     */
    url?: string;
    /**
     * 
     * @type {Project}
     * @memberof TimesheetEntry
     */
    project?: Project;
    /**
     * 
     * @type {Activity}
     * @memberof TimesheetEntry
     */
    activity: Activity;
    /**
     * 
     * @type {string}
     * @memberof TimesheetEntry
     */
    date: string;
    /**
     * 
     * @type {number}
     * @memberof TimesheetEntry
     */
    hours: number;
    /**
     * 
     * @type {number}
     * @memberof TimesheetEntry
     */
    chargeableHours: number;
    /**
     * 
     * @type {Employee}
     * @memberof TimesheetEntry
     */
    employee: Employee;
    /**
     * Link to stop watches on this hour.
     * @type {Array&lt;TimeClock&gt;}
     * @memberof TimesheetEntry
     */
    timeClocks?: Array<TimeClock>;
    /**
     * 
     * @type {string}
     * @memberof TimesheetEntry
     */
    comment?: string;
    /**
     * Indicates if the hour can be changed.
     * @type {boolean}
     * @memberof TimesheetEntry
     */
    locked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TimesheetEntry
     */
    chargeable?: boolean;
}

/**
 * 
 * @export
 * @interface TimesheetEntrySearchResponse
 */
export interface TimesheetEntrySearchResponse {
    /**
     * 
     * @type {number}
     * @memberof TimesheetEntrySearchResponse
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof TimesheetEntrySearchResponse
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof TimesheetEntrySearchResponse
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof TimesheetEntrySearchResponse
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;TimesheetEntry&gt;}
     * @memberof TimesheetEntrySearchResponse
     */
    values?: Array<TimesheetEntry>;
    /**
     * 
     * @type {number}
     * @memberof TimesheetEntrySearchResponse
     */
    sumAllHours?: number;
}

/**
 * 
 * @export
 * @interface TravelCostCategory
 */
export interface TravelCostCategory {
    /**
     * 
     * @type {number}
     * @memberof TravelCostCategory
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelCostCategory
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof TravelCostCategory
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof TravelCostCategory
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelCostCategory
     */
    description: string;
    /**
     * 
     * @type {Account}
     * @memberof TravelCostCategory
     */
    account?: Account;
    /**
     * 
     * @type {VatType}
     * @memberof TravelCostCategory
     */
    vatType?: VatType;
    /**
     * 
     * @type {boolean}
     * @memberof TravelCostCategory
     */
    isVatLocked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelCostCategory
     */
    showOnTravelExpenses?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelCostCategory
     */
    showOnEmployeeExpenses?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelCostCategory
     */
    isInactive?: boolean;
}

/**
 * 
 * @export
 * @interface TravelDetails
 */
export interface TravelDetails {
    /**
     * 
     * @type {boolean}
     * @memberof TravelDetails
     */
    isForeignTravel?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelDetails
     */
    isDayTrip?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelDetails
     */
    isCompensationFromRates?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TravelDetails
     */
    departureDate?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelDetails
     */
    returnDate?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelDetails
     */
    detailedJourneyDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelDetails
     */
    departureFrom?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelDetails
     */
    destination?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelDetails
     */
    departureTime?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelDetails
     */
    returnTime?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelDetails
     */
    purpose?: string;
}

/**
 * 
 * @export
 * @interface TravelExpense
 */
export interface TravelExpense {
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof TravelExpense
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof TravelExpense
     */
    url?: string;
    /**
     * 
     * @type {Project}
     * @memberof TravelExpense
     */
    project?: Project;
    /**
     * 
     * @type {Employee}
     * @memberof TravelExpense
     */
    employee: Employee;
    /**
     * 
     * @type {Employee}
     * @memberof TravelExpense
     */
    approvedBy?: Employee;
    /**
     * 
     * @type {Employee}
     * @memberof TravelExpense
     */
    completedBy?: Employee;
    /**
     * 
     * @type {Department}
     * @memberof TravelExpense
     */
    department?: Department;
    /**
     * 
     * @type {Payslip}
     * @memberof TravelExpense
     */
    payslip?: Payslip;
    /**
     * 
     * @type {VatType}
     * @memberof TravelExpense
     */
    vatType?: VatType;
    /**
     * 
     * @type {Currency}
     * @memberof TravelExpense
     */
    paymentCurrency?: Currency;
    /**
     * 
     * @type {TravelDetails}
     * @memberof TravelExpense
     */
    travelDetails?: TravelDetails;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpense
     */
    isCompleted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpense
     */
    isApproved?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpense
     */
    isChargeable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpense
     */
    isFixedInvoicedAmount?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpense
     */
    isIncludeAttachedReceiptsWhenReinvoicing?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TravelExpense
     */
    completedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelExpense
     */
    approvedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelExpense
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    travelAdvance?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    fixedInvoicedAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    lowRateVAT?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    mediumRateVAT?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    highRateVAT?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    paymentAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    paymentAmountCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    number?: number;
    /**
     * 
     * @type {string}
     * @memberof TravelExpense
     */
    title?: string;
    /**
     * Link to individual per diem compensations.
     * @type {Array&lt;PerDiemCompensation&gt;}
     * @memberof TravelExpense
     */
    perDiemCompensations?: Array<PerDiemCompensation>;
    /**
     * Link to individual mileage allowances.
     * @type {Array&lt;MileageAllowance&gt;}
     * @memberof TravelExpense
     */
    mileageAllowances?: Array<MileageAllowance>;
    /**
     * Link to individual accommodation allowances.
     * @type {Array&lt;AccommodationAllowance&gt;}
     * @memberof TravelExpense
     */
    accommodationAllowances?: Array<AccommodationAllowance>;
    /**
     * Link to individual costs.
     * @type {Array&lt;Cost&gt;}
     * @memberof TravelExpense
     */
    costs?: Array<Cost>;
    /**
     * 
     * @type {number}
     * @memberof TravelExpense
     */
    attachmentCount?: number;
    /**
     * 
     * @type {string}
     * @memberof TravelExpense
     */
    state?: TravelExpense.StateEnum;
    /**
     * 
     * @type {Array&lt;Link&gt;}
     * @memberof TravelExpense
     */
    actions?: Array<Link>;
}

/**
 * @export
 * @namespace TravelExpense
 */
export namespace TravelExpense {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ALL = <any> 'ALL',
        OPEN = <any> 'OPEN',
        APPROVED = <any> 'APPROVED',
        SALARYPAID = <any> 'SALARY_PAID',
        DELIVERED = <any> 'DELIVERED'
    }
}

/**
 * 
 * @export
 * @interface TravelExpenseRate
 */
export interface TravelExpenseRate {
    /**
     * 
     * @type {number}
     * @memberof TravelExpenseRate
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpenseRate
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof TravelExpenseRate
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRate
     */
    url?: string;
    /**
     * 
     * @type {TravelExpenseRateCategory}
     * @memberof TravelExpenseRate
     */
    rateCategory: TravelExpenseRateCategory;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRate
     */
    zone: string;
    /**
     * 
     * @type {number}
     * @memberof TravelExpenseRate
     */
    rate?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpenseRate
     */
    breakfastDeductionRate?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpenseRate
     */
    lunchDeductionRate?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpenseRate
     */
    dinnerDeductionRate?: number;
}

/**
 * 
 * @export
 * @interface TravelExpenseRateCategory
 */
export interface TravelExpenseRateCategory {
    /**
     * 
     * @type {number}
     * @memberof TravelExpenseRateCategory
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpenseRateCategory
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof TravelExpenseRateCategory
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRateCategory
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRateCategory
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof TravelExpenseRateCategory
     */
    ameldingWageCode?: number;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRateCategory
     */
    wageCodeNumber?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpenseRateCategory
     */
    isValidDayTrip?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpenseRateCategory
     */
    isValidAccommodation?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpenseRateCategory
     */
    isValidForeignTravel?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpenseRateCategory
     */
    isRequiresZone?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpenseRateCategory
     */
    isRequiresOvernightAccommodation?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRateCategory
     */
    fromDate: string;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRateCategory
     */
    toDate: string;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRateCategory
     */
    type?: TravelExpenseRateCategory.TypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpenseRateCategory
     */
    validDomestic?: boolean;
}

/**
 * @export
 * @namespace TravelExpenseRateCategory
 */
export namespace TravelExpenseRateCategory {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        PERDIEM = <any> 'PER_DIEM',
        ACCOMMODATIONALLOWANCE = <any> 'ACCOMMODATION_ALLOWANCE',
        MILEAGEALLOWANCE = <any> 'MILEAGE_ALLOWANCE'
    }
}

/**
 * 
 * @export
 * @interface TravelExpenseRateCategoryGroup
 */
export interface TravelExpenseRateCategoryGroup {
    /**
     * 
     * @type {number}
     * @memberof TravelExpenseRateCategoryGroup
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelExpenseRateCategoryGroup
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof TravelExpenseRateCategoryGroup
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRateCategoryGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRateCategoryGroup
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TravelExpenseRateCategoryGroup
     */
    isForeignTravel?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRateCategoryGroup
     */
    fromDate: string;
    /**
     * 
     * @type {string}
     * @memberof TravelExpenseRateCategoryGroup
     */
    toDate: string;
}

/**
 * 
 * @export
 * @interface TravelPaymentType
 */
export interface TravelPaymentType {
    /**
     * 
     * @type {number}
     * @memberof TravelPaymentType
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelPaymentType
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof TravelPaymentType
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof TravelPaymentType
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof TravelPaymentType
     */
    description: string;
    /**
     * 
     * @type {Account}
     * @memberof TravelPaymentType
     */
    account?: Account;
    /**
     * 
     * @type {boolean}
     * @memberof TravelPaymentType
     */
    showOnTravelExpenses?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelPaymentType
     */
    showOnEmployeeExpenses?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelPaymentType
     */
    isInactive?: boolean;
}

/**
 * 
 * @export
 * @interface TriggerDTO
 */
export interface TriggerDTO {
    /**
     * 
     * @type {string}
     * @memberof TriggerDTO
     */
    calendarName?: string;
    /**
     * 
     * @type {string}
     * @memberof TriggerDTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof TriggerDTO
     */
    name?: string;
    /**
     * 
     * @type {Date}
     * @memberof TriggerDTO
     */
    nextFireTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TriggerDTO
     */
    previousFireTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof TriggerDTO
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface TripletexAccount
 */
export interface TripletexAccount {
    /**
     * Information about the company to create. Supply as much info as you have, but at least name, type and address.
     * @type {Company}
     * @memberof TripletexAccount
     */
    company: Company;
    /**
     * Employee to create. Department on this object will also be created if supplied. If null a dummy user and department will be created instead
     * @type {Employee}
     * @memberof TripletexAccount
     */
    administrator?: Employee;
    /**
     * Is this a test account or a paying account?
     * @type {string}
     * @memberof TripletexAccount
     */
    accountType: TripletexAccount.AccountTypeEnum;
    /**
     * Modules (functionality in the application) to activate for the newly created account. Some modules have extra costs.
     * @type {Modules}
     * @memberof TripletexAccount
     */
    modules: Modules;
    /**
     * Password for the administrator user to create. Not a part of the administrator employee object since this is a value that never can be read (it is salted and hashed before storing)
     * @type {string}
     * @memberof TripletexAccount
     */
    administratorPassword: string;
    /**
     * Should the regular creation emails be sent to the company created and its users? If false you probably want to set autoValidateUserLogin to true
     * @type {boolean}
     * @memberof TripletexAccount
     */
    sendEmails?: boolean;
    /**
     * If true, the users created will be allowed to log in without validating their email address. ONLY USE THIS IF YOU ALREADY HAVE VALIDATED THE USER EMAILS.
     * @type {boolean}
     * @memberof TripletexAccount
     */
    autoValidateUserLogin?: boolean;
    /**
     * Create an API token for the administrator user for the consumer token used during this call. The token will be returned in the response.
     * @type {boolean}
     * @memberof TripletexAccount
     */
    createAdministratorApiToken?: boolean;
    /**
     * Create an API token for the company to use to call their clients, only possible for accounting and auditor accounts. The token will be returned in the response.
     * @type {boolean}
     * @memberof TripletexAccount
     */
    createCompanyOwnedApiToken?: boolean;
    /**
     * Should the company we are creating be able to create new Tripletex accounts?
     * @type {boolean}
     * @memberof TripletexAccount
     */
    mayCreateTripletexAccounts?: boolean;
    /**
     * Used to calculate prices.
     * @type {string}
     * @memberof TripletexAccount
     */
    numberOfVouchers: TripletexAccount.NumberOfVouchersEnum;
    /**
     * 
     * @type {boolean}
     * @memberof TripletexAccount
     */
    auditor?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TripletexAccount
     */
    reseller?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TripletexAccount
     */
    accountingOffice?: boolean;
}

/**
 * @export
 * @namespace TripletexAccount
 */
export namespace TripletexAccount {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        TEST = <any> 'TEST',
        PAYING = <any> 'PAYING'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NumberOfVouchersEnum {
        _0100 = <any> 'INTERVAL_0_100',
        _101500 = <any> 'INTERVAL_101_500',
        _0500 = <any> 'INTERVAL_0_500',
        _5011000 = <any> 'INTERVAL_501_1000',
        _10012000 = <any> 'INTERVAL_1001_2000',
        _20013500 = <any> 'INTERVAL_2001_3500',
        _35015000 = <any> 'INTERVAL_3501_5000',
        _500110000 = <any> 'INTERVAL_5001_10000',
        UNLIMITED = <any> 'INTERVAL_UNLIMITED'
    }
}

/**
 * 
 * @export
 * @interface TripletexAccountReturn
 */
export interface TripletexAccountReturn {
    /**
     * 
     * @type {Company}
     * @memberof TripletexAccountReturn
     */
    company?: Company;
    /**
     * 
     * @type {Employee}
     * @memberof TripletexAccountReturn
     */
    administrator?: Employee;
    /**
     * 
     * @type {EmployeeToken}
     * @memberof TripletexAccountReturn
     */
    administratorApiToken?: EmployeeToken;
    /**
     * 
     * @type {EmployeeToken}
     * @memberof TripletexAccountReturn
     */
    companyOwnedApiToken?: EmployeeToken;
    /**
     * 
     * @type {number}
     * @memberof TripletexAccountReturn
     */
    companyOwnedApiTokenRobotId?: number;
}

/**
 * 
 * @export
 * @interface UnreadCountDTO
 */
export interface UnreadCountDTO {
    /**
     * 
     * @type {number}
     * @memberof UnreadCountDTO
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof UnreadCountDTO
     */
    readCursor?: number;
}

/**
 * 
 * @export
 * @interface VNTCStatusDTO
 */
export interface VNTCStatusDTO {
    /**
     * 
     * @type {string}
     * @memberof VNTCStatusDTO
     */
    messageId: string;
    /**
     * 
     * @type {string}
     * @memberof VNTCStatusDTO
     */
    externalSenderId: string;
    /**
     * 
     * @type {string}
     * @memberof VNTCStatusDTO
     */
    externalMessageId: string;
    /**
     * 
     * @type {number}
     * @memberof VNTCStatusDTO
     */
    partCount?: number;
    /**
     * 
     * @type {string}
     * @memberof VNTCStatusDTO
     */
    messageStatus: string;
}

/**
 * 
 * @export
 * @interface VatType
 */
export interface VatType {
    /**
     * 
     * @type {number}
     * @memberof VatType
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof VatType
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof VatType
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof VatType
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof VatType
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof VatType
     */
    number?: string;
    /**
     * 
     * @type {number}
     * @memberof VatType
     */
    percentage?: number;
}

/**
 * 
 * @export
 * @interface Voucher
 */
export interface Voucher {
    /**
     * 
     * @type {number}
     * @memberof Voucher
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Voucher
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof Voucher
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    date: string;
    /**
     * System generated number that cannot be changed.
     * @type {number}
     * @memberof Voucher
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof Voucher
     */
    year?: number;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    description: string;
    /**
     * 
     * @type {VoucherType}
     * @memberof Voucher
     */
    voucherType?: VoucherType;
    /**
     * 
     * @type {Voucher}
     * @memberof Voucher
     */
    reverseVoucher?: Voucher;
    /**
     * 
     * @type {Array&lt;Posting&gt;}
     * @memberof Voucher
     */
    postings: Array<Posting>;
}

/**
 * 
 * @export
 * @interface VoucherSearchResponse
 */
export interface VoucherSearchResponse {
    /**
     * 
     * @type {number}
     * @memberof VoucherSearchResponse
     */
    fullResultSize?: number;
    /**
     * 
     * @type {number}
     * @memberof VoucherSearchResponse
     */
    from?: number;
    /**
     * 
     * @type {number}
     * @memberof VoucherSearchResponse
     */
    count?: number;
    /**
     * Used to know if the paginated list has changed.
     * @type {string}
     * @memberof VoucherSearchResponse
     */
    versionDigest?: string;
    /**
     * 
     * @type {Array&lt;Voucher&gt;}
     * @memberof VoucherSearchResponse
     */
    values?: Array<Voucher>;
    /**
     * 
     * @type {number}
     * @memberof VoucherSearchResponse
     */
    totalNumberOfPostings?: number;
}

/**
 * 
 * @export
 * @interface VoucherType
 */
export interface VoucherType {
    /**
     * 
     * @type {number}
     * @memberof VoucherType
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof VoucherType
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof VoucherType
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof VoucherType
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof VoucherType
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface WeeklyStatus
 */
export interface WeeklyStatus {
    /**
     * 
     * @type {number}
     * @memberof WeeklyStatus
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof WeeklyStatus
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof WeeklyStatus
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof WeeklyStatus
     */
    url?: string;
    /**
     * 
     * @type {Employee}
     * @memberof WeeklyStatus
     */
    employee: Employee;
    /**
     * 
     * @type {number}
     * @memberof WeeklyStatus
     */
    year?: number;
    /**
     * 
     * @type {number}
     * @memberof WeeklyStatus
     */
    week?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WeeklyStatus
     */
    completed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WeeklyStatus
     */
    approved?: boolean;
    /**
     * 
     * @type {Employee}
     * @memberof WeeklyStatus
     */
    approvedBy?: Employee;
    /**
     * 
     * @type {string}
     * @memberof WeeklyStatus
     */
    approvedDate?: string;
}

/**
 * 
 * @export
 * @interface WorkingHoursScheme
 */
export interface WorkingHoursScheme {
    /**
     * 
     * @type {number}
     * @memberof WorkingHoursScheme
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkingHoursScheme
     */
    version?: number;
    /**
     * 
     * @type {Array&lt;Change&gt;}
     * @memberof WorkingHoursScheme
     */
    changes?: Array<Change>;
    /**
     * 
     * @type {string}
     * @memberof WorkingHoursScheme
     */
    url?: string;
    /**
     * Defines the working hours scheme option.
     * @type {string}
     * @memberof WorkingHoursScheme
     */
    workingHoursScheme: WorkingHoursScheme.WorkingHoursSchemeEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkingHoursScheme
     */
    nameNO?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkingHoursScheme
     */
    code?: string;
}

/**
 * @export
 * @namespace WorkingHoursScheme
 */
export namespace WorkingHoursScheme {
    /**
     * @export
     * @enum {string}
     */
    export enum WorkingHoursSchemeEnum {
        SCHEME = <any> 'WORKING_HOURS_SCHEME'
    }
}


/**
 * ActivityApi - fetch parameter creator
 * @export
 */
export const ActivityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find activity by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/activity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find applicable time sheet activities for an employee on a specific day.
         * @param {number} projectId Project ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet(projectId: number, employeeId?: number, date?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling getForTimeSheet.');
            }
            const localVarPath = `/activity/>forTimeSheet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find activities corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {boolean} [isProjectActivity] Equals
         * @param {boolean} [isGeneral] Equals
         * @param {boolean} [isChargeable] Equals
         * @param {boolean} [isTask] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, description?: string, isProjectActivity?: boolean, isGeneral?: boolean, isChargeable?: boolean, isTask?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/activity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (isProjectActivity !== undefined) {
                localVarQueryParameter['isProjectActivity'] = isProjectActivity;
            }

            if (isGeneral !== undefined) {
                localVarQueryParameter['isGeneral'] = isGeneral;
            }

            if (isChargeable !== undefined) {
                localVarQueryParameter['isChargeable'] = isChargeable;
            }

            if (isTask !== undefined) {
                localVarQueryParameter['isTask'] = isTask;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find activity by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperActivity> {
            const localVarFetchArgs = ActivityApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find applicable time sheet activities for an employee on a specific day.
         * @param {number} projectId Project ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet(projectId: number, employeeId?: number, date?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseActivity> {
            const localVarFetchArgs = ActivityApiFetchParamCreator(configuration).getForTimeSheet(projectId, employeeId, date, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find activities corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {boolean} [isProjectActivity] Equals
         * @param {boolean} [isGeneral] Equals
         * @param {boolean} [isChargeable] Equals
         * @param {boolean} [isTask] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, description?: string, isProjectActivity?: boolean, isGeneral?: boolean, isChargeable?: boolean, isTask?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseActivity> {
            const localVarFetchArgs = ActivityApiFetchParamCreator(configuration).search(id, name, number, description, isProjectActivity, isGeneral, isChargeable, isTask, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Find activity by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return ActivityApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find applicable time sheet activities for an employee on a specific day.
         * @param {number} projectId Project ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet(projectId: number, employeeId?: number, date?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return ActivityApiFp(configuration).getForTimeSheet(projectId, employeeId, date, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find activities corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {boolean} [isProjectActivity] Equals
         * @param {boolean} [isGeneral] Equals
         * @param {boolean} [isChargeable] Equals
         * @param {boolean} [isTask] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, description?: string, isProjectActivity?: boolean, isGeneral?: boolean, isChargeable?: boolean, isTask?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return ActivityApiFp(configuration).search(id, name, number, description, isProjectActivity, isGeneral, isChargeable, isTask, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * 
     * @summary Find activity by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public get(id: number, fields?: string, options?: any) {
        return ActivityApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find applicable time sheet activities for an employee on a specific day.
     * @param {} projectId Project ID
     * @param {} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {} [date] yyyy-MM-dd. Defaults to today.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public getForTimeSheet(projectId: number, employeeId?: number, date?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return ActivityApiFp(this.configuration).getForTimeSheet(projectId, employeeId, date, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find activities corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [name] Containing
     * @param {} [number] Equals
     * @param {} [description] Containing
     * @param {} [isProjectActivity] Equals
     * @param {} [isGeneral] Equals
     * @param {} [isChargeable] Equals
     * @param {} [isTask] Equals
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public search(id?: string, name?: string, number?: string, description?: string, isProjectActivity?: boolean, isGeneral?: boolean, isChargeable?: boolean, isTask?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return ActivityApiFp(this.configuration).search(id, name, number, description, isProjectActivity, isGeneral, isChargeable, isTask, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * AddressApi - fetch parameter creator
 * @export
 */
export const AddressApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get address by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/address/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update address. 
         * @param {number} id Element ID
         * @param {Address} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Address, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/address/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Address" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find addresses corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [addressLine1] List of IDs
         * @param {string} [addressLine2] List of IDs
         * @param {string} [postalCode] List of IDs
         * @param {string} [city] List of IDs
         * @param {string} [name] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, addressLine1?: string, addressLine2?: string, postalCode?: string, city?: string, name?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/address`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (addressLine1 !== undefined) {
                localVarQueryParameter['addressLine1'] = addressLine1;
            }

            if (addressLine2 !== undefined) {
                localVarQueryParameter['addressLine2'] = addressLine2;
            }

            if (postalCode !== undefined) {
                localVarQueryParameter['postalCode'] = postalCode;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressApi - functional programming interface
 * @export
 */
export const AddressApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get address by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperAddress> {
            const localVarFetchArgs = AddressApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update address. 
         * @param {number} id Element ID
         * @param {Address} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Address, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperAddress> {
            const localVarFetchArgs = AddressApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find addresses corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [addressLine1] List of IDs
         * @param {string} [addressLine2] List of IDs
         * @param {string} [postalCode] List of IDs
         * @param {string} [city] List of IDs
         * @param {string} [name] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, addressLine1?: string, addressLine2?: string, postalCode?: string, city?: string, name?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseAddress> {
            const localVarFetchArgs = AddressApiFetchParamCreator(configuration).search(id, addressLine1, addressLine2, postalCode, city, name, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AddressApi - factory interface
 * @export
 */
export const AddressApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get address by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return AddressApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update address. 
         * @param {number} id Element ID
         * @param {Address} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Address, options?: any) {
            return AddressApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find addresses corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [addressLine1] List of IDs
         * @param {string} [addressLine2] List of IDs
         * @param {string} [postalCode] List of IDs
         * @param {string} [city] List of IDs
         * @param {string} [name] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, addressLine1?: string, addressLine2?: string, postalCode?: string, city?: string, name?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return AddressApiFp(configuration).search(id, addressLine1, addressLine2, postalCode, city, name, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
export class AddressApi extends BaseAPI {
    /**
     * 
     * @summary Get address by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public get(id: number, fields?: string, options?: any) {
        return AddressApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update address. 
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public put(id: number, body?: Address, options?: any) {
        return AddressApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find addresses corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [addressLine1] List of IDs
     * @param {} [addressLine2] List of IDs
     * @param {} [postalCode] List of IDs
     * @param {} [city] List of IDs
     * @param {} [name] List of IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public search(id?: string, addressLine1?: string, addressLine2?: string, postalCode?: string, city?: string, name?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return AddressApiFp(this.configuration).search(id, addressLine1, addressLine2, postalCode, city, name, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * BankApi - fetch parameter creator
 * @export
 */
export const BankApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find bank corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [registerNumbers] Bank register number (four digits)
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, registerNumbers?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/bank`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (registerNumbers !== undefined) {
                localVarQueryParameter['registerNumbers'] = registerNumbers;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankApi - functional programming interface
 * @export
 */
export const BankApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find bank corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [registerNumbers] Bank register number (four digits)
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, registerNumbers?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseBank> {
            const localVarFetchArgs = BankApiFetchParamCreator(configuration).search(id, registerNumbers, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BankApi - factory interface
 * @export
 */
export const BankApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find bank corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [registerNumbers] Bank register number (four digits)
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, registerNumbers?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return BankApiFp(configuration).search(id, registerNumbers, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * BankApi - object-oriented interface
 * @export
 * @class BankApi
 * @extends {BaseAPI}
 */
export class BankApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find bank corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [registerNumbers] Bank register number (four digits)
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    public search(id?: string, registerNumbers?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return BankApiFp(this.configuration).search(id, registerNumbers, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * BankreconciliationApi - fetch parameter creator
 * @export
 */
export const BankreconciliationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete bank reconciliation by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/bank/reconciliation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Add an adjustment to reconciliation by ID.
         * @param {number} id Element ID
         * @param {number} paymentTypeId Bank reconciliation PaymentType ID.
         * @param {string} postingDate Format is yyyy-MM-dd
         * @param {number} amount Amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustment(id: number, paymentTypeId: number, postingDate: string, amount: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling adjustment.');
            }
            // verify required parameter 'paymentTypeId' is not null or undefined
            if (paymentTypeId === null || paymentTypeId === undefined) {
                throw new RequiredError('paymentTypeId','Required parameter paymentTypeId was null or undefined when calling adjustment.');
            }
            // verify required parameter 'postingDate' is not null or undefined
            if (postingDate === null || postingDate === undefined) {
                throw new RequiredError('postingDate','Required parameter postingDate was null or undefined when calling adjustment.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling adjustment.');
            }
            const localVarPath = `/bank/reconciliation/{id}/:adjustment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (paymentTypeId !== undefined) {
                localVarQueryParameter['paymentTypeId'] = paymentTypeId;
            }

            if (postingDate !== undefined) {
                localVarQueryParameter['postingDate'] = postingDate;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get bank reconciliation.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/bank/reconciliation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get last closed reconciliation by account ID.
         * @param {number} accountId Account ID
         * @param {string} [after] Format is yyyy-MM-dd
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastClosed(accountId: number, after?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling lastClosed.');
            }
            const localVarPath = `/bank/reconciliation/>lastClosed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Post a bank reconciliation.
         * @param {BankReconciliation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: BankReconciliation, options: any = {}): FetchArgs {
            const localVarPath = `/bank/reconciliation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BankReconciliation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update a bank reconciliation.
         * @param {number} id Element ID
         * @param {BankReconciliation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: BankReconciliation, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/bank/reconciliation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BankReconciliation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find bank reconciliation corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [accountingPeriodId] List of IDs
         * @param {string} [accountId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, accountingPeriodId?: string, accountId?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/bank/reconciliation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (accountingPeriodId !== undefined) {
                localVarQueryParameter['accountingPeriodId'] = accountingPeriodId;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankreconciliationApi - functional programming interface
 * @export
 */
export const BankreconciliationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete bank reconciliation by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BankreconciliationApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Add an adjustment to reconciliation by ID.
         * @param {number} id Element ID
         * @param {number} paymentTypeId Bank reconciliation PaymentType ID.
         * @param {string} postingDate Format is yyyy-MM-dd
         * @param {number} amount Amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustment(id: number, paymentTypeId: number, postingDate: string, amount: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponsePosting> {
            const localVarFetchArgs = BankreconciliationApiFetchParamCreator(configuration).adjustment(id, paymentTypeId, postingDate, amount, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get bank reconciliation.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperBankReconciliation> {
            const localVarFetchArgs = BankreconciliationApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get last closed reconciliation by account ID.
         * @param {number} accountId Account ID
         * @param {string} [after] Format is yyyy-MM-dd
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastClosed(accountId: number, after?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperBankReconciliation> {
            const localVarFetchArgs = BankreconciliationApiFetchParamCreator(configuration).lastClosed(accountId, after, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Post a bank reconciliation.
         * @param {BankReconciliation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: BankReconciliation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperBankReconciliation> {
            const localVarFetchArgs = BankreconciliationApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update a bank reconciliation.
         * @param {number} id Element ID
         * @param {BankReconciliation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: BankReconciliation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperBankReconciliation> {
            const localVarFetchArgs = BankreconciliationApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find bank reconciliation corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [accountingPeriodId] List of IDs
         * @param {string} [accountId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, accountingPeriodId?: string, accountId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseBankReconciliation> {
            const localVarFetchArgs = BankreconciliationApiFetchParamCreator(configuration).search(id, accountingPeriodId, accountId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BankreconciliationApi - factory interface
 * @export
 */
export const BankreconciliationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete bank reconciliation by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return BankreconciliationApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Add an adjustment to reconciliation by ID.
         * @param {number} id Element ID
         * @param {number} paymentTypeId Bank reconciliation PaymentType ID.
         * @param {string} postingDate Format is yyyy-MM-dd
         * @param {number} amount Amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustment(id: number, paymentTypeId: number, postingDate: string, amount: number, options?: any) {
            return BankreconciliationApiFp(configuration).adjustment(id, paymentTypeId, postingDate, amount, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get bank reconciliation.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return BankreconciliationApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get last closed reconciliation by account ID.
         * @param {number} accountId Account ID
         * @param {string} [after] Format is yyyy-MM-dd
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastClosed(accountId: number, after?: string, fields?: string, options?: any) {
            return BankreconciliationApiFp(configuration).lastClosed(accountId, after, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Post a bank reconciliation.
         * @param {BankReconciliation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: BankReconciliation, options?: any) {
            return BankreconciliationApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update a bank reconciliation.
         * @param {number} id Element ID
         * @param {BankReconciliation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: BankReconciliation, options?: any) {
            return BankreconciliationApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find bank reconciliation corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [accountingPeriodId] List of IDs
         * @param {string} [accountId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, accountingPeriodId?: string, accountId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return BankreconciliationApiFp(configuration).search(id, accountingPeriodId, accountId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * BankreconciliationApi - object-oriented interface
 * @export
 * @class BankreconciliationApi
 * @extends {BaseAPI}
 */
export class BankreconciliationApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete bank reconciliation by ID.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    public _delete(id: number, options?: any) {
        return BankreconciliationApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Add an adjustment to reconciliation by ID.
     * @param {} id Element ID
     * @param {} paymentTypeId Bank reconciliation PaymentType ID.
     * @param {} postingDate Format is yyyy-MM-dd
     * @param {} amount Amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    public adjustment(id: number, paymentTypeId: number, postingDate: string, amount: number, options?: any) {
        return BankreconciliationApiFp(this.configuration).adjustment(id, paymentTypeId, postingDate, amount, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get bank reconciliation.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    public get(id: number, fields?: string, options?: any) {
        return BankreconciliationApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get last closed reconciliation by account ID.
     * @param {} accountId Account ID
     * @param {} [after] Format is yyyy-MM-dd
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    public lastClosed(accountId: number, after?: string, fields?: string, options?: any) {
        return BankreconciliationApiFp(this.configuration).lastClosed(accountId, after, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Post a bank reconciliation.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    public post(body?: BankReconciliation, options?: any) {
        return BankreconciliationApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update a bank reconciliation.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    public put(id: number, body?: BankReconciliation, options?: any) {
        return BankreconciliationApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find bank reconciliation corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [accountingPeriodId] List of IDs
     * @param {} [accountId] List of IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    public search(id?: string, accountingPeriodId?: string, accountId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return BankreconciliationApiFp(this.configuration).search(id, accountingPeriodId, accountId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * BankreconciliationmatchApi - fetch parameter creator
 * @export
 */
export const BankreconciliationmatchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/bank/reconciliation/match/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/bank/reconciliation/match/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create a bank reconciliation match.
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: BankReconciliationMatch, options: any = {}): FetchArgs {
            const localVarPath = `/bank/reconciliation/match`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BankReconciliationMatch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: BankReconciliationMatch, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/bank/reconciliation/match/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BankReconciliationMatch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find bank reconciliation match corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [bankReconciliationId] List of bank reconciliation IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, bankReconciliationId?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/bank/reconciliation/match`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (bankReconciliationId !== undefined) {
                localVarQueryParameter['bankReconciliationId'] = bankReconciliationId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankreconciliationmatchApi - functional programming interface
 * @export
 */
export const BankreconciliationmatchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BankreconciliationmatchApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperBankReconciliationMatch> {
            const localVarFetchArgs = BankreconciliationmatchApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create a bank reconciliation match.
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: BankReconciliationMatch, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperBankReconciliationMatch> {
            const localVarFetchArgs = BankreconciliationmatchApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: BankReconciliationMatch, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperBankReconciliationMatch> {
            const localVarFetchArgs = BankreconciliationmatchApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find bank reconciliation match corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [bankReconciliationId] List of bank reconciliation IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, bankReconciliationId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseBankReconciliationMatch> {
            const localVarFetchArgs = BankreconciliationmatchApiFetchParamCreator(configuration).search(id, bankReconciliationId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BankreconciliationmatchApi - factory interface
 * @export
 */
export const BankreconciliationmatchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return BankreconciliationmatchApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return BankreconciliationmatchApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create a bank reconciliation match.
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: BankReconciliationMatch, options?: any) {
            return BankreconciliationmatchApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: BankReconciliationMatch, options?: any) {
            return BankreconciliationmatchApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find bank reconciliation match corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [bankReconciliationId] List of bank reconciliation IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, bankReconciliationId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return BankreconciliationmatchApiFp(configuration).search(id, bankReconciliationId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * BankreconciliationmatchApi - object-oriented interface
 * @export
 * @class BankreconciliationmatchApi
 * @extends {BaseAPI}
 */
export class BankreconciliationmatchApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete a bank reconciliation match by ID.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationmatchApi
     */
    public _delete(id: number, options?: any) {
        return BankreconciliationmatchApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get bank reconciliation match by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationmatchApi
     */
    public get(id: number, fields?: string, options?: any) {
        return BankreconciliationmatchApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create a bank reconciliation match.
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationmatchApi
     */
    public post(body?: BankReconciliationMatch, options?: any) {
        return BankreconciliationmatchApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update a bank reconciliation match by ID.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationmatchApi
     */
    public put(id: number, body?: BankReconciliationMatch, options?: any) {
        return BankreconciliationmatchApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find bank reconciliation match corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [bankReconciliationId] List of bank reconciliation IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationmatchApi
     */
    public search(id?: string, bankReconciliationId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return BankreconciliationmatchApiFp(this.configuration).search(id, bankReconciliationId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * BankreconciliationpaymentTypeApi - fetch parameter creator
 * @export
 */
export const BankreconciliationpaymentTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/bank/reconciliation/paymentType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/bank/reconciliation/paymentType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankreconciliationpaymentTypeApi - functional programming interface
 * @export
 */
export const BankreconciliationpaymentTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperBankReconciliationPaymentType> {
            const localVarFetchArgs = BankreconciliationpaymentTypeApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseBankReconciliationPaymentType> {
            const localVarFetchArgs = BankreconciliationpaymentTypeApiFetchParamCreator(configuration).search(id, description, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BankreconciliationpaymentTypeApi - factory interface
 * @export
 */
export const BankreconciliationpaymentTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return BankreconciliationpaymentTypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return BankreconciliationpaymentTypeApiFp(configuration).search(id, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * BankreconciliationpaymentTypeApi - object-oriented interface
 * @export
 * @class BankreconciliationpaymentTypeApi
 * @extends {BaseAPI}
 */
export class BankreconciliationpaymentTypeApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Get payment type by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationpaymentTypeApi
     */
    public get(id: number, fields?: string, options?: any) {
        return BankreconciliationpaymentTypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find payment type corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [description] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationpaymentTypeApi
     */
    public search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return BankreconciliationpaymentTypeApiFp(this.configuration).search(id, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * BankstatementApi - fetch parameter creator
 * @export
 */
export const BankstatementApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete bank statement by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/bank/statement/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get bank statement.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/bank/statement/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Upload bank statement file.
         * @param {string} fileFormat File format
         * @param {any} file The bank statement file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importBankStatement(fileFormat: string, file: any, options: any = {}): FetchArgs {
            // verify required parameter 'fileFormat' is not null or undefined
            if (fileFormat === null || fileFormat === undefined) {
                throw new RequiredError('fileFormat','Required parameter fileFormat was null or undefined when calling importBankStatement.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling importBankStatement.');
            }
            const localVarPath = `/bank/statement/import`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fileFormat !== undefined) {
                localVarQueryParameter['fileFormat'] = fileFormat;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find bank statement corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/bank/statement`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankstatementApi - functional programming interface
 * @export
 */
export const BankstatementApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete bank statement by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BankstatementApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get bank statement.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperBankStatement> {
            const localVarFetchArgs = BankstatementApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Upload bank statement file.
         * @param {string} fileFormat File format
         * @param {any} file The bank statement file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importBankStatement(fileFormat: string, file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperBankStatement> {
            const localVarFetchArgs = BankstatementApiFetchParamCreator(configuration).importBankStatement(fileFormat, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find bank statement corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseBankStatement> {
            const localVarFetchArgs = BankstatementApiFetchParamCreator(configuration).search(id, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BankstatementApi - factory interface
 * @export
 */
export const BankstatementApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete bank statement by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return BankstatementApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get bank statement.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return BankstatementApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Upload bank statement file.
         * @param {string} fileFormat File format
         * @param {any} file The bank statement file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importBankStatement(fileFormat: string, file: any, options?: any) {
            return BankstatementApiFp(configuration).importBankStatement(fileFormat, file, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find bank statement corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return BankstatementApiFp(configuration).search(id, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * BankstatementApi - object-oriented interface
 * @export
 * @class BankstatementApi
 * @extends {BaseAPI}
 */
export class BankstatementApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete bank statement by ID.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementApi
     */
    public _delete(id: number, options?: any) {
        return BankstatementApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get bank statement.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementApi
     */
    public get(id: number, fields?: string, options?: any) {
        return BankstatementApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Upload bank statement file.
     * @param {} fileFormat File format
     * @param {} file The bank statement file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementApi
     */
    public importBankStatement(fileFormat: string, file: any, options?: any) {
        return BankstatementApiFp(this.configuration).importBankStatement(fileFormat, file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find bank statement corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementApi
     */
    public search(id?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return BankstatementApiFp(this.configuration).search(id, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * BankstatementtransactionApi - fetch parameter creator
 * @export
 */
export const BankstatementtransactionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get bank transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/bank/statement/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get additional details about transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDetails.');
            }
            const localVarPath = `/bank/statement/transaction/{id}/details`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find bank transaction corresponding with sent data.
         * @param {number} bankStatementId Bank statement ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(bankStatementId: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'bankStatementId' is not null or undefined
            if (bankStatementId === null || bankStatementId === undefined) {
                throw new RequiredError('bankStatementId','Required parameter bankStatementId was null or undefined when calling search.');
            }
            const localVarPath = `/bank/statement/transaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (bankStatementId !== undefined) {
                localVarQueryParameter['bankStatementId'] = bankStatementId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankstatementtransactionApi - functional programming interface
 * @export
 */
export const BankstatementtransactionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get bank transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperBankTransaction> {
            const localVarFetchArgs = BankstatementtransactionApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get additional details about transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperObject> {
            const localVarFetchArgs = BankstatementtransactionApiFetchParamCreator(configuration).getDetails(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find bank transaction corresponding with sent data.
         * @param {number} bankStatementId Bank statement ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(bankStatementId: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseBankTransaction> {
            const localVarFetchArgs = BankstatementtransactionApiFetchParamCreator(configuration).search(bankStatementId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BankstatementtransactionApi - factory interface
 * @export
 */
export const BankstatementtransactionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Get bank transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return BankstatementtransactionApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get additional details about transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails(id: number, fields?: string, options?: any) {
            return BankstatementtransactionApiFp(configuration).getDetails(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find bank transaction corresponding with sent data.
         * @param {number} bankStatementId Bank statement ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(bankStatementId: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return BankstatementtransactionApiFp(configuration).search(bankStatementId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * BankstatementtransactionApi - object-oriented interface
 * @export
 * @class BankstatementtransactionApi
 * @extends {BaseAPI}
 */
export class BankstatementtransactionApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Get bank transaction by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementtransactionApi
     */
    public get(id: number, fields?: string, options?: any) {
        return BankstatementtransactionApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get additional details about transaction by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementtransactionApi
     */
    public getDetails(id: number, fields?: string, options?: any) {
        return BankstatementtransactionApiFp(this.configuration).getDetails(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find bank transaction corresponding with sent data.
     * @param {} bankStatementId Bank statement ID
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementtransactionApi
     */
    public search(bankStatementId: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return BankstatementtransactionApiFp(this.configuration).search(bankStatementId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * CompanyApi - fetch parameter creator
 * @export
 */
export const CompanyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find company by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/company/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find divisions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivisions(from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/company/divisions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns client customers (with accountant/auditor relation) where the current user has login access (proxy login).
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithLoginAccess(from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/company/>withLoginAccess`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyApi - functional programming interface
 * @export
 */
export const CompanyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find company by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCompany> {
            const localVarFetchArgs = CompanyApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find divisions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivisions(from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseCompany> {
            const localVarFetchArgs = CompanyApiFetchParamCreator(configuration).getDivisions(from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns client customers (with accountant/auditor relation) where the current user has login access (proxy login).
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithLoginAccess(from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseCompany> {
            const localVarFetchArgs = CompanyApiFetchParamCreator(configuration).getWithLoginAccess(from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompanyApi - factory interface
 * @export
 */
export const CompanyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Find company by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return CompanyApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find divisions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivisions(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return CompanyApiFp(configuration).getDivisions(from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns client customers (with accountant/auditor relation) where the current user has login access (proxy login).
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithLoginAccess(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return CompanyApiFp(configuration).getWithLoginAccess(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * CompanyApi - object-oriented interface
 * @export
 * @class CompanyApi
 * @extends {BaseAPI}
 */
export class CompanyApi extends BaseAPI {
    /**
     * 
     * @summary Find company by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public get(id: number, fields?: string, options?: any) {
        return CompanyApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find divisions.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public getDivisions(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return CompanyApiFp(this.configuration).getDivisions(from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns client customers (with accountant/auditor relation) where the current user has login access (proxy login).
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public getWithLoginAccess(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return CompanyApiFp(this.configuration).getWithLoginAccess(from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * ContactApi - fetch parameter creator
 * @export
 */
export const ContactApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get contact by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/contact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create contact.
         * @param {Contact} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Contact, options: any = {}): FetchArgs {
            const localVarPath = `/contact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Contact" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find contacts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [email] Containing
         * @param {string} [customerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, firstName?: string, lastName?: string, email?: string, customerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/contact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactApi - functional programming interface
 * @export
 */
export const ContactApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get contact by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperContact> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create contact.
         * @param {Contact} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Contact, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperContact> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find contacts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [email] Containing
         * @param {string} [customerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, firstName?: string, lastName?: string, email?: string, customerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseContact> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).search(id, firstName, lastName, email, customerId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContactApi - factory interface
 * @export
 */
export const ContactApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get contact by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return ContactApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create contact.
         * @param {Contact} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Contact, options?: any) {
            return ContactApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find contacts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [email] Containing
         * @param {string} [customerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, firstName?: string, lastName?: string, email?: string, customerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return ContactApiFp(configuration).search(id, firstName, lastName, email, customerId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
export class ContactApi extends BaseAPI {
    /**
     * 
     * @summary Get contact by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public get(id: number, fields?: string, options?: any) {
        return ContactApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create contact.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public post(body?: Contact, options?: any) {
        return ContactApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find contacts corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [firstName] Containing
     * @param {} [lastName] Containing
     * @param {} [email] Containing
     * @param {} [customerId] List of IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public search(id?: string, firstName?: string, lastName?: string, email?: string, customerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return ContactApiFp(this.configuration).search(id, firstName, lastName, email, customerId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * CountryApi - fetch parameter creator
 * @export
 */
export const CountryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get country by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/country/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find countries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, code?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/country`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryApi - functional programming interface
 * @export
 */
export const CountryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get country by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCountry> {
            const localVarFetchArgs = CountryApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find countries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, code?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseCountry> {
            const localVarFetchArgs = CountryApiFetchParamCreator(configuration).search(id, code, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CountryApi - factory interface
 * @export
 */
export const CountryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get country by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return CountryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find countries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, code?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return CountryApiFp(configuration).search(id, code, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * CountryApi - object-oriented interface
 * @export
 * @class CountryApi
 * @extends {BaseAPI}
 */
export class CountryApi extends BaseAPI {
    /**
     * 
     * @summary Get country by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public get(id: number, fields?: string, options?: any) {
        return CountryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find countries corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [code] List of IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public search(id?: string, code?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return CountryApiFp(this.configuration).search(id, code, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * CrmprospectApi - fetch parameter creator
 * @export
 */
export const CrmprospectApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get prospect by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/crm/prospect/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find prospects corresponding with sent data.
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {string} [createdDateFrom] From and including
         * @param {string} [createdDateTo] To and excluding
         * @param {string} [customerId] Equals
         * @param {string} [salesEmployeeId] Equals
         * @param {boolean} [isClosed] Equals
         * @param {string} [closedReason] Equals
         * @param {string} [closedDateFrom] From and including
         * @param {string} [closedDateTo] To and excluding
         * @param {string} [competitor] Containing
         * @param {string} [prospectType] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectOfferId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(name?: string, description?: string, createdDateFrom?: string, createdDateTo?: string, customerId?: string, salesEmployeeId?: string, isClosed?: boolean, closedReason?: string, closedDateFrom?: string, closedDateTo?: string, competitor?: string, prospectType?: string, projectId?: string, projectOfferId?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/crm/prospect`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (createdDateFrom !== undefined) {
                localVarQueryParameter['createdDateFrom'] = createdDateFrom;
            }

            if (createdDateTo !== undefined) {
                localVarQueryParameter['createdDateTo'] = createdDateTo;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (salesEmployeeId !== undefined) {
                localVarQueryParameter['salesEmployeeId'] = salesEmployeeId;
            }

            if (isClosed !== undefined) {
                localVarQueryParameter['isClosed'] = isClosed;
            }

            if (closedReason !== undefined) {
                localVarQueryParameter['closedReason'] = closedReason;
            }

            if (closedDateFrom !== undefined) {
                localVarQueryParameter['closedDateFrom'] = closedDateFrom;
            }

            if (closedDateTo !== undefined) {
                localVarQueryParameter['closedDateTo'] = closedDateTo;
            }

            if (competitor !== undefined) {
                localVarQueryParameter['competitor'] = competitor;
            }

            if (prospectType !== undefined) {
                localVarQueryParameter['prospectType'] = prospectType;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (projectOfferId !== undefined) {
                localVarQueryParameter['projectOfferId'] = projectOfferId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrmprospectApi - functional programming interface
 * @export
 */
export const CrmprospectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get prospect by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperProspect> {
            const localVarFetchArgs = CrmprospectApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find prospects corresponding with sent data.
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {string} [createdDateFrom] From and including
         * @param {string} [createdDateTo] To and excluding
         * @param {string} [customerId] Equals
         * @param {string} [salesEmployeeId] Equals
         * @param {boolean} [isClosed] Equals
         * @param {string} [closedReason] Equals
         * @param {string} [closedDateFrom] From and including
         * @param {string} [closedDateTo] To and excluding
         * @param {string} [competitor] Containing
         * @param {string} [prospectType] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectOfferId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(name?: string, description?: string, createdDateFrom?: string, createdDateTo?: string, customerId?: string, salesEmployeeId?: string, isClosed?: boolean, closedReason?: string, closedDateFrom?: string, closedDateTo?: string, competitor?: string, prospectType?: string, projectId?: string, projectOfferId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseProspect> {
            const localVarFetchArgs = CrmprospectApiFetchParamCreator(configuration).search(name, description, createdDateFrom, createdDateTo, customerId, salesEmployeeId, isClosed, closedReason, closedDateFrom, closedDateTo, competitor, prospectType, projectId, projectOfferId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CrmprospectApi - factory interface
 * @export
 */
export const CrmprospectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get prospect by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return CrmprospectApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find prospects corresponding with sent data.
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {string} [createdDateFrom] From and including
         * @param {string} [createdDateTo] To and excluding
         * @param {string} [customerId] Equals
         * @param {string} [salesEmployeeId] Equals
         * @param {boolean} [isClosed] Equals
         * @param {string} [closedReason] Equals
         * @param {string} [closedDateFrom] From and including
         * @param {string} [closedDateTo] To and excluding
         * @param {string} [competitor] Containing
         * @param {string} [prospectType] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectOfferId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(name?: string, description?: string, createdDateFrom?: string, createdDateTo?: string, customerId?: string, salesEmployeeId?: string, isClosed?: boolean, closedReason?: string, closedDateFrom?: string, closedDateTo?: string, competitor?: string, prospectType?: string, projectId?: string, projectOfferId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return CrmprospectApiFp(configuration).search(name, description, createdDateFrom, createdDateTo, customerId, salesEmployeeId, isClosed, closedReason, closedDateFrom, closedDateTo, competitor, prospectType, projectId, projectOfferId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * CrmprospectApi - object-oriented interface
 * @export
 * @class CrmprospectApi
 * @extends {BaseAPI}
 */
export class CrmprospectApi extends BaseAPI {
    /**
     * 
     * @summary Get prospect by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmprospectApi
     */
    public get(id: number, fields?: string, options?: any) {
        return CrmprospectApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find prospects corresponding with sent data.
     * @param {} [name] Containing
     * @param {} [description] Containing
     * @param {} [createdDateFrom] From and including
     * @param {} [createdDateTo] To and excluding
     * @param {} [customerId] Equals
     * @param {} [salesEmployeeId] Equals
     * @param {} [isClosed] Equals
     * @param {} [closedReason] Equals
     * @param {} [closedDateFrom] From and including
     * @param {} [closedDateTo] To and excluding
     * @param {} [competitor] Containing
     * @param {} [prospectType] Equals
     * @param {} [projectId] Equals
     * @param {} [projectOfferId] Equals
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmprospectApi
     */
    public search(name?: string, description?: string, createdDateFrom?: string, createdDateTo?: string, customerId?: string, salesEmployeeId?: string, isClosed?: boolean, closedReason?: string, closedDateFrom?: string, closedDateTo?: string, competitor?: string, prospectType?: string, projectId?: string, projectOfferId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return CrmprospectApiFp(this.configuration).search(name, description, createdDateFrom, createdDateTo, customerId, salesEmployeeId, isClosed, closedReason, closedDateFrom, closedDateTo, competitor, prospectType, projectId, projectOfferId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * CurrencyApi - fetch parameter creator
 * @export
 */
export const CurrencyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get currency by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find currencies corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] Currency codes
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, code?: string, fields?: string, from?: number, count?: number, sorting?: string, options: any = {}): FetchArgs {
            const localVarPath = `/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyApi - functional programming interface
 * @export
 */
export const CurrencyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get currency by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCurrency> {
            const localVarFetchArgs = CurrencyApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find currencies corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] Currency codes
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, code?: string, fields?: string, from?: number, count?: number, sorting?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseCurrency> {
            const localVarFetchArgs = CurrencyApiFetchParamCreator(configuration).search(id, code, fields, from, count, sorting, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CurrencyApi - factory interface
 * @export
 */
export const CurrencyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get currency by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return CurrencyApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find currencies corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] Currency codes
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, code?: string, fields?: string, from?: number, count?: number, sorting?: string, options?: any) {
            return CurrencyApiFp(configuration).search(id, code, fields, from, count, sorting, options)(fetch, basePath);
        },
    };
};

/**
 * CurrencyApi - object-oriented interface
 * @export
 * @class CurrencyApi
 * @extends {BaseAPI}
 */
export class CurrencyApi extends BaseAPI {
    /**
     * 
     * @summary Get currency by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public get(id: number, fields?: string, options?: any) {
        return CurrencyApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find currencies corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [code] Currency codes
     * @param {} [fields] Fields filter pattern
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public search(id?: string, code?: string, fields?: string, from?: number, count?: number, sorting?: string, options?: any) {
        return CurrencyApiFp(this.configuration).search(id, code, fields, from, count, sorting, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerApi - fetch parameter creator
 * @export
 */
export const CustomerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get customer by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/customer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create customer. Related customer addresses may also be created.
         * @param {Customer} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Customer, options: any = {}): FetchArgs {
            const localVarPath = `/customer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create multiple customers. Related supplier addresses may also be created.
         * @param {Array&lt;Customer&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Customer>, options: any = {}): FetchArgs {
            const localVarPath = `/customer/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Customer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update customer. 
         * @param {number} id Element ID
         * @param {Customer} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Customer, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/customer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update multiple customers. Addresses can also be updated.
         * @param {Array&lt;Customer&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<Customer>, options: any = {}): FetchArgs {
            const localVarPath = `/customer/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Customer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find customers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [customerAccountNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, customerAccountNumber?: string, email?: string, invoiceEmail?: string, isInactive?: boolean, accountManagerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/customer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (customerAccountNumber !== undefined) {
                localVarQueryParameter['customerAccountNumber'] = customerAccountNumber;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (invoiceEmail !== undefined) {
                localVarQueryParameter['invoiceEmail'] = invoiceEmail;
            }

            if (isInactive !== undefined) {
                localVarQueryParameter['isInactive'] = isInactive;
            }

            if (accountManagerId !== undefined) {
                localVarQueryParameter['accountManagerId'] = accountManagerId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get customer by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCustomer> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create customer. Related customer addresses may also be created.
         * @param {Customer} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Customer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCustomer> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create multiple customers. Related supplier addresses may also be created.
         * @param {Array&lt;Customer&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Customer>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseCustomer> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).postList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update customer. 
         * @param {number} id Element ID
         * @param {Customer} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Customer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCustomer> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update multiple customers. Addresses can also be updated.
         * @param {Array&lt;Customer&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<Customer>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseCustomer> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).putList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find customers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [customerAccountNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, customerAccountNumber?: string, email?: string, invoiceEmail?: string, isInactive?: boolean, accountManagerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseCustomer> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).search(id, customerAccountNumber, email, invoiceEmail, isInactive, accountManagerId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get customer by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return CustomerApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create customer. Related customer addresses may also be created.
         * @param {Customer} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Customer, options?: any) {
            return CustomerApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create multiple customers. Related supplier addresses may also be created.
         * @param {Array&lt;Customer&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Customer>, options?: any) {
            return CustomerApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update customer. 
         * @param {number} id Element ID
         * @param {Customer} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Customer, options?: any) {
            return CustomerApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update multiple customers. Addresses can also be updated.
         * @param {Array&lt;Customer&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<Customer>, options?: any) {
            return CustomerApiFp(configuration).putList(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find customers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [customerAccountNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, customerAccountNumber?: string, email?: string, invoiceEmail?: string, isInactive?: boolean, accountManagerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return CustomerApiFp(configuration).search(id, customerAccountNumber, email, invoiceEmail, isInactive, accountManagerId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI {
    /**
     * 
     * @summary Get customer by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public get(id: number, fields?: string, options?: any) {
        return CustomerApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create customer. Related customer addresses may also be created.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public post(body?: Customer, options?: any) {
        return CustomerApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create multiple customers. Related supplier addresses may also be created.
     * @param {} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public postList(body?: Array<Customer>, options?: any) {
        return CustomerApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update customer. 
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public put(id: number, body?: Customer, options?: any) {
        return CustomerApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update multiple customers. Addresses can also be updated.
     * @param {} [body] JSON representing updates to object. Should have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public putList(body?: Array<Customer>, options?: any) {
        return CustomerApiFp(this.configuration).putList(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find customers corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [customerAccountNumber] List of IDs
     * @param {} [email] Equals
     * @param {} [invoiceEmail] Equals
     * @param {} [isInactive] Equals
     * @param {} [accountManagerId] List of IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public search(id?: string, customerAccountNumber?: string, email?: string, invoiceEmail?: string, isInactive?: boolean, accountManagerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return CustomerApiFp(this.configuration).search(id, customerAccountNumber, email, invoiceEmail, isInactive, accountManagerId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomercategoryApi - fetch parameter creator
 * @export
 */
export const CustomercategoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find customer/supplier category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/customer/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new customer/supplier category.
         * @param {CustomerCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: CustomerCategory, options: any = {}): FetchArgs {
            const localVarPath = `/customer/category`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerCategory" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update customer/supplier category.
         * @param {number} id Element ID
         * @param {CustomerCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: CustomerCategory, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/customer/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerCategory" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find customer/supplier categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {string} [type] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, description?: string, type?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/customer/category`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomercategoryApi - functional programming interface
 * @export
 */
export const CustomercategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find customer/supplier category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCustomerCategory> {
            const localVarFetchArgs = CustomercategoryApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add new customer/supplier category.
         * @param {CustomerCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: CustomerCategory, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCustomerCategory> {
            const localVarFetchArgs = CustomercategoryApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update customer/supplier category.
         * @param {number} id Element ID
         * @param {CustomerCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: CustomerCategory, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCustomerCategory> {
            const localVarFetchArgs = CustomercategoryApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find customer/supplier categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {string} [type] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, description?: string, type?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseCustomerCategory> {
            const localVarFetchArgs = CustomercategoryApiFetchParamCreator(configuration).search(id, name, number, description, type, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomercategoryApi - factory interface
 * @export
 */
export const CustomercategoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Find customer/supplier category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return CustomercategoryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add new customer/supplier category.
         * @param {CustomerCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: CustomerCategory, options?: any) {
            return CustomercategoryApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update customer/supplier category.
         * @param {number} id Element ID
         * @param {CustomerCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: CustomerCategory, options?: any) {
            return CustomercategoryApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find customer/supplier categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {string} [type] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, description?: string, type?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return CustomercategoryApiFp(configuration).search(id, name, number, description, type, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * CustomercategoryApi - object-oriented interface
 * @export
 * @class CustomercategoryApi
 * @extends {BaseAPI}
 */
export class CustomercategoryApi extends BaseAPI {
    /**
     * 
     * @summary Find customer/supplier category by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomercategoryApi
     */
    public get(id: number, fields?: string, options?: any) {
        return CustomercategoryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add new customer/supplier category.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomercategoryApi
     */
    public post(body?: CustomerCategory, options?: any) {
        return CustomercategoryApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update customer/supplier category.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomercategoryApi
     */
    public put(id: number, body?: CustomerCategory, options?: any) {
        return CustomercategoryApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find customer/supplier categories corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [name] Containing
     * @param {} [number] Equals
     * @param {} [description] Containing
     * @param {} [type] List of IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomercategoryApi
     */
    public search(id?: string, name?: string, number?: string, description?: string, type?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return CustomercategoryApiFp(this.configuration).search(id, name, number, description, type, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * DepartmentApi - fetch parameter creator
 * @export
 */
export const DepartmentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get department by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/department/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find department corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [departmentNumber] Containing
         * @param {string} [departmentManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, departmentNumber?: string, departmentManagerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/department`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (departmentNumber !== undefined) {
                localVarQueryParameter['departmentNumber'] = departmentNumber;
            }

            if (departmentManagerId !== undefined) {
                localVarQueryParameter['departmentManagerId'] = departmentManagerId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepartmentApi - functional programming interface
 * @export
 */
export const DepartmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get department by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperDepartment> {
            const localVarFetchArgs = DepartmentApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find department corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [departmentNumber] Containing
         * @param {string} [departmentManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, departmentNumber?: string, departmentManagerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseDepartment> {
            const localVarFetchArgs = DepartmentApiFetchParamCreator(configuration).search(id, name, departmentNumber, departmentManagerId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DepartmentApi - factory interface
 * @export
 */
export const DepartmentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get department by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return DepartmentApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find department corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [departmentNumber] Containing
         * @param {string} [departmentManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, departmentNumber?: string, departmentManagerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return DepartmentApiFp(configuration).search(id, name, departmentNumber, departmentManagerId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * DepartmentApi - object-oriented interface
 * @export
 * @class DepartmentApi
 * @extends {BaseAPI}
 */
export class DepartmentApi extends BaseAPI {
    /**
     * 
     * @summary Get department by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentApi
     */
    public get(id: number, fields?: string, options?: any) {
        return DepartmentApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find department corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [name] Containing
     * @param {} [departmentNumber] Containing
     * @param {} [departmentManagerId] List of IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentApi
     */
    public search(id?: string, name?: string, departmentNumber?: string, departmentManagerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return DepartmentApiFp(this.configuration).search(id, name, departmentNumber, departmentManagerId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * EmployeeApi - fetch parameter creator
 * @export
 */
export const EmployeeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get employee by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/employee/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create one employee.
         * @param {Employee} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Employee, options: any = {}): FetchArgs {
            const localVarPath = `/employee`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Employee" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create several employees.
         * @param {Array&lt;Employee&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Employee>, options: any = {}): FetchArgs {
            const localVarPath = `/employee/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Employee&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update employee.
         * @param {number} id Element ID
         * @param {Employee} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Employee, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/employee/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Employee" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find employees corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [employeeNumber] Containing
         * @param {boolean} [allowInformationRegistration] Equals
         * @param {string} [departmentId] List of IDs
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, firstName?: string, lastName?: string, employeeNumber?: string, allowInformationRegistration?: boolean, departmentId?: string, fields?: string, from?: number, count?: number, sorting?: string, options: any = {}): FetchArgs {
            const localVarPath = `/employee`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (employeeNumber !== undefined) {
                localVarQueryParameter['employeeNumber'] = employeeNumber;
            }

            if (allowInformationRegistration !== undefined) {
                localVarQueryParameter['allowInformationRegistration'] = allowInformationRegistration;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeApi - functional programming interface
 * @export
 */
export const EmployeeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get employee by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperEmployee> {
            const localVarFetchArgs = EmployeeApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create one employee.
         * @param {Employee} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Employee, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperEmployee> {
            const localVarFetchArgs = EmployeeApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create several employees.
         * @param {Array&lt;Employee&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Employee>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseEmployee> {
            const localVarFetchArgs = EmployeeApiFetchParamCreator(configuration).postList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update employee.
         * @param {number} id Element ID
         * @param {Employee} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Employee, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperEmployee> {
            const localVarFetchArgs = EmployeeApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find employees corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [employeeNumber] Containing
         * @param {boolean} [allowInformationRegistration] Equals
         * @param {string} [departmentId] List of IDs
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, firstName?: string, lastName?: string, employeeNumber?: string, allowInformationRegistration?: boolean, departmentId?: string, fields?: string, from?: number, count?: number, sorting?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseEmployee> {
            const localVarFetchArgs = EmployeeApiFetchParamCreator(configuration).search(id, firstName, lastName, employeeNumber, allowInformationRegistration, departmentId, fields, from, count, sorting, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmployeeApi - factory interface
 * @export
 */
export const EmployeeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get employee by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return EmployeeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create one employee.
         * @param {Employee} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Employee, options?: any) {
            return EmployeeApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create several employees.
         * @param {Array&lt;Employee&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Employee>, options?: any) {
            return EmployeeApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update employee.
         * @param {number} id Element ID
         * @param {Employee} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Employee, options?: any) {
            return EmployeeApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find employees corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [employeeNumber] Containing
         * @param {boolean} [allowInformationRegistration] Equals
         * @param {string} [departmentId] List of IDs
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, firstName?: string, lastName?: string, employeeNumber?: string, allowInformationRegistration?: boolean, departmentId?: string, fields?: string, from?: number, count?: number, sorting?: string, options?: any) {
            return EmployeeApiFp(configuration).search(id, firstName, lastName, employeeNumber, allowInformationRegistration, departmentId, fields, from, count, sorting, options)(fetch, basePath);
        },
    };
};

/**
 * EmployeeApi - object-oriented interface
 * @export
 * @class EmployeeApi
 * @extends {BaseAPI}
 */
export class EmployeeApi extends BaseAPI {
    /**
     * 
     * @summary Get employee by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    public get(id: number, fields?: string, options?: any) {
        return EmployeeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create one employee.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    public post(body?: Employee, options?: any) {
        return EmployeeApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create several employees.
     * @param {} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    public postList(body?: Array<Employee>, options?: any) {
        return EmployeeApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update employee.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    public put(id: number, body?: Employee, options?: any) {
        return EmployeeApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find employees corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [firstName] Containing
     * @param {} [lastName] Containing
     * @param {} [employeeNumber] Containing
     * @param {} [allowInformationRegistration] Equals
     * @param {} [departmentId] List of IDs
     * @param {} [fields] Fields filter pattern
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    public search(id?: string, firstName?: string, lastName?: string, employeeNumber?: string, allowInformationRegistration?: boolean, departmentId?: string, fields?: string, from?: number, count?: number, sorting?: string, options?: any) {
        return EmployeeApiFp(this.configuration).search(id, firstName, lastName, employeeNumber, allowInformationRegistration, departmentId, fields, from, count, sorting, options)(this.fetch, this.basePath);
    }

}

/**
 * EmployeeemploymentApi - fetch parameter creator
 * @export
 */
export const EmployeeemploymentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find employment by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/employee/employment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create employment.
         * @param {Employment} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Employment, options: any = {}): FetchArgs {
            const localVarPath = `/employee/employment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Employment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update employemnt. 
         * @param {number} id Element ID
         * @param {Employment} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Employment, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/employee/employment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Employment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all employments for employee.
         * @param {number} [employeeId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/employee/employment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeemploymentApi - functional programming interface
 * @export
 */
export const EmployeeemploymentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find employment by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperEmployment> {
            const localVarFetchArgs = EmployeeemploymentApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create employment.
         * @param {Employment} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Employment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperEmployment> {
            const localVarFetchArgs = EmployeeemploymentApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update employemnt. 
         * @param {number} id Element ID
         * @param {Employment} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Employment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperEmployment> {
            const localVarFetchArgs = EmployeeemploymentApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all employments for employee.
         * @param {number} [employeeId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseEmployment> {
            const localVarFetchArgs = EmployeeemploymentApiFetchParamCreator(configuration).search(employeeId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmployeeemploymentApi - factory interface
 * @export
 */
export const EmployeeemploymentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Find employment by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return EmployeeemploymentApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create employment.
         * @param {Employment} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Employment, options?: any) {
            return EmployeeemploymentApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update employemnt. 
         * @param {number} id Element ID
         * @param {Employment} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Employment, options?: any) {
            return EmployeeemploymentApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all employments for employee.
         * @param {number} [employeeId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return EmployeeemploymentApiFp(configuration).search(employeeId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * EmployeeemploymentApi - object-oriented interface
 * @export
 * @class EmployeeemploymentApi
 * @extends {BaseAPI}
 */
export class EmployeeemploymentApi extends BaseAPI {
    /**
     * 
     * @summary Find employment by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentApi
     */
    public get(id: number, fields?: string, options?: any) {
        return EmployeeemploymentApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create employment.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentApi
     */
    public post(body?: Employment, options?: any) {
        return EmployeeemploymentApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update employemnt. 
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentApi
     */
    public put(id: number, body?: Employment, options?: any) {
        return EmployeeemploymentApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all employments for employee.
     * @param {} [employeeId] Element ID
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentApi
     */
    public search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return EmployeeemploymentApiFp(this.configuration).search(employeeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * EmployeeemploymentdetailsApi - fetch parameter creator
 * @export
 */
export const EmployeeemploymentdetailsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find employment details by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/employee/employment/details/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create employment details.
         * @param {EmploymentDetails} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: EmploymentDetails, options: any = {}): FetchArgs {
            const localVarPath = `/employee/employment/details`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmploymentDetails" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update employment details. 
         * @param {number} id Element ID
         * @param {EmploymentDetails} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: EmploymentDetails, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/employee/employment/details/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmploymentDetails" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find all employmentdetails for employment.
         * @param {number} [employmentId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employmentId?: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/employee/employment/details`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employmentId !== undefined) {
                localVarQueryParameter['employmentId'] = employmentId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeemploymentdetailsApi - functional programming interface
 * @export
 */
export const EmployeeemploymentdetailsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find employment details by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperEmploymentDetails> {
            const localVarFetchArgs = EmployeeemploymentdetailsApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create employment details.
         * @param {EmploymentDetails} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: EmploymentDetails, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperEmploymentDetails> {
            const localVarFetchArgs = EmployeeemploymentdetailsApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update employment details. 
         * @param {number} id Element ID
         * @param {EmploymentDetails} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: EmploymentDetails, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperEmploymentDetails> {
            const localVarFetchArgs = EmployeeemploymentdetailsApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find all employmentdetails for employment.
         * @param {number} [employmentId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employmentId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseEmploymentDetails> {
            const localVarFetchArgs = EmployeeemploymentdetailsApiFetchParamCreator(configuration).search(employmentId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmployeeemploymentdetailsApi - factory interface
 * @export
 */
export const EmployeeemploymentdetailsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find employment details by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return EmployeeemploymentdetailsApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create employment details.
         * @param {EmploymentDetails} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: EmploymentDetails, options?: any) {
            return EmployeeemploymentdetailsApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update employment details. 
         * @param {number} id Element ID
         * @param {EmploymentDetails} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: EmploymentDetails, options?: any) {
            return EmployeeemploymentdetailsApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find all employmentdetails for employment.
         * @param {number} [employmentId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employmentId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return EmployeeemploymentdetailsApiFp(configuration).search(employmentId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * EmployeeemploymentdetailsApi - object-oriented interface
 * @export
 * @class EmployeeemploymentdetailsApi
 * @extends {BaseAPI}
 */
export class EmployeeemploymentdetailsApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find employment details by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentdetailsApi
     */
    public get(id: number, fields?: string, options?: any) {
        return EmployeeemploymentdetailsApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create employment details.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentdetailsApi
     */
    public post(body?: EmploymentDetails, options?: any) {
        return EmployeeemploymentdetailsApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update employment details. 
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentdetailsApi
     */
    public put(id: number, body?: EmploymentDetails, options?: any) {
        return EmployeeemploymentdetailsApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find all employmentdetails for employment.
     * @param {} [employmentId] Element ID
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentdetailsApi
     */
    public search(employmentId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return EmployeeemploymentdetailsApiFp(this.configuration).search(employmentId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * EmployeeemploymentemploymentTypeApi - fetch parameter creator
 * @export
 */
export const EmployeeemploymentemploymentTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find all employment type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/employee/employment/employmentType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeemploymentemploymentTypeApi - functional programming interface
 * @export
 */
export const EmployeeemploymentemploymentTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find all employment type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseEmploymentType> {
            const localVarFetchArgs = EmployeeemploymentemploymentTypeApiFetchParamCreator(configuration).search(from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmployeeemploymentemploymentTypeApi - factory interface
 * @export
 */
export const EmployeeemploymentemploymentTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find all employment type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return EmployeeemploymentemploymentTypeApiFp(configuration).search(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * EmployeeemploymentemploymentTypeApi - object-oriented interface
 * @export
 * @class EmployeeemploymentemploymentTypeApi
 * @extends {BaseAPI}
 */
export class EmployeeemploymentemploymentTypeApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find all employment type IDs.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentemploymentTypeApi
     */
    public search(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return EmployeeemploymentemploymentTypeApiFp(this.configuration).search(from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * EmployeeemploymentleaveOfAbsenceApi - fetch parameter creator
 * @export
 */
export const EmployeeemploymentleaveOfAbsenceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find leave of absence by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/employee/employment/leaveOfAbsence/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create leave of absence.
         * @param {LeaveOfAbsence} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: LeaveOfAbsence, options: any = {}): FetchArgs {
            const localVarPath = `/employee/employment/leaveOfAbsence`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LeaveOfAbsence" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update leave of absence. 
         * @param {number} id Element ID
         * @param {LeaveOfAbsence} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: LeaveOfAbsence, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/employee/employment/leaveOfAbsence/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LeaveOfAbsence" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeemploymentleaveOfAbsenceApi - functional programming interface
 * @export
 */
export const EmployeeemploymentleaveOfAbsenceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find leave of absence by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperLeaveOfAbsence> {
            const localVarFetchArgs = EmployeeemploymentleaveOfAbsenceApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create leave of absence.
         * @param {LeaveOfAbsence} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: LeaveOfAbsence, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperLeaveOfAbsence> {
            const localVarFetchArgs = EmployeeemploymentleaveOfAbsenceApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update leave of absence. 
         * @param {number} id Element ID
         * @param {LeaveOfAbsence} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: LeaveOfAbsence, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperLeaveOfAbsence> {
            const localVarFetchArgs = EmployeeemploymentleaveOfAbsenceApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmployeeemploymentleaveOfAbsenceApi - factory interface
 * @export
 */
export const EmployeeemploymentleaveOfAbsenceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find leave of absence by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return EmployeeemploymentleaveOfAbsenceApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create leave of absence.
         * @param {LeaveOfAbsence} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: LeaveOfAbsence, options?: any) {
            return EmployeeemploymentleaveOfAbsenceApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update leave of absence. 
         * @param {number} id Element ID
         * @param {LeaveOfAbsence} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: LeaveOfAbsence, options?: any) {
            return EmployeeemploymentleaveOfAbsenceApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * EmployeeemploymentleaveOfAbsenceApi - object-oriented interface
 * @export
 * @class EmployeeemploymentleaveOfAbsenceApi
 * @extends {BaseAPI}
 */
export class EmployeeemploymentleaveOfAbsenceApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find leave of absence by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentleaveOfAbsenceApi
     */
    public get(id: number, fields?: string, options?: any) {
        return EmployeeemploymentleaveOfAbsenceApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create leave of absence.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentleaveOfAbsenceApi
     */
    public post(body?: LeaveOfAbsence, options?: any) {
        return EmployeeemploymentleaveOfAbsenceApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update leave of absence. 
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentleaveOfAbsenceApi
     */
    public put(id: number, body?: LeaveOfAbsence, options?: any) {
        return EmployeeemploymentleaveOfAbsenceApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * EmployeeemploymentleaveOfAbsenceTypeApi - fetch parameter creator
 * @export
 */
export const EmployeeemploymentleaveOfAbsenceTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find all leave of absence type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/employee/employment/leaveOfAbsenceType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeemploymentleaveOfAbsenceTypeApi - functional programming interface
 * @export
 */
export const EmployeeemploymentleaveOfAbsenceTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find all leave of absence type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseLeaveOfAbsenceType> {
            const localVarFetchArgs = EmployeeemploymentleaveOfAbsenceTypeApiFetchParamCreator(configuration).search(from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmployeeemploymentleaveOfAbsenceTypeApi - factory interface
 * @export
 */
export const EmployeeemploymentleaveOfAbsenceTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find all leave of absence type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return EmployeeemploymentleaveOfAbsenceTypeApiFp(configuration).search(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * EmployeeemploymentleaveOfAbsenceTypeApi - object-oriented interface
 * @export
 * @class EmployeeemploymentleaveOfAbsenceTypeApi
 * @extends {BaseAPI}
 */
export class EmployeeemploymentleaveOfAbsenceTypeApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find all leave of absence type IDs.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentleaveOfAbsenceTypeApi
     */
    public search(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return EmployeeemploymentleaveOfAbsenceTypeApiFp(this.configuration).search(from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * EmployeeemploymentoccupationCodeApi - fetch parameter creator
 * @export
 */
export const EmployeeemploymentoccupationCodeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find all profession codes.
         * @param {string} [nameNO] Containing
         * @param {string} [code] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(nameNO?: string, code?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/employee/employment/occupationCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (nameNO !== undefined) {
                localVarQueryParameter['nameNO'] = nameNO;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeemploymentoccupationCodeApi - functional programming interface
 * @export
 */
export const EmployeeemploymentoccupationCodeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find all profession codes.
         * @param {string} [nameNO] Containing
         * @param {string} [code] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(nameNO?: string, code?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseOccupationCode> {
            const localVarFetchArgs = EmployeeemploymentoccupationCodeApiFetchParamCreator(configuration).search(nameNO, code, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmployeeemploymentoccupationCodeApi - factory interface
 * @export
 */
export const EmployeeemploymentoccupationCodeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find all profession codes.
         * @param {string} [nameNO] Containing
         * @param {string} [code] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(nameNO?: string, code?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return EmployeeemploymentoccupationCodeApiFp(configuration).search(nameNO, code, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * EmployeeemploymentoccupationCodeApi - object-oriented interface
 * @export
 * @class EmployeeemploymentoccupationCodeApi
 * @extends {BaseAPI}
 */
export class EmployeeemploymentoccupationCodeApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find all profession codes.
     * @param {} [nameNO] Containing
     * @param {} [code] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentoccupationCodeApi
     */
    public search(nameNO?: string, code?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return EmployeeemploymentoccupationCodeApiFp(this.configuration).search(nameNO, code, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * EmployeeemploymentremunerationTypeApi - fetch parameter creator
 * @export
 */
export const EmployeeemploymentremunerationTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find all remuneration type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/employee/employment/remunerationType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeemploymentremunerationTypeApi - functional programming interface
 * @export
 */
export const EmployeeemploymentremunerationTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find all remuneration type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseRemunerationType> {
            const localVarFetchArgs = EmployeeemploymentremunerationTypeApiFetchParamCreator(configuration).search(from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmployeeemploymentremunerationTypeApi - factory interface
 * @export
 */
export const EmployeeemploymentremunerationTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find all remuneration type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return EmployeeemploymentremunerationTypeApiFp(configuration).search(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * EmployeeemploymentremunerationTypeApi - object-oriented interface
 * @export
 * @class EmployeeemploymentremunerationTypeApi
 * @extends {BaseAPI}
 */
export class EmployeeemploymentremunerationTypeApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find all remuneration type IDs.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentremunerationTypeApi
     */
    public search(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return EmployeeemploymentremunerationTypeApiFp(this.configuration).search(from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * EmployeeemploymentworkingHoursSchemeApi - fetch parameter creator
 * @export
 */
export const EmployeeemploymentworkingHoursSchemeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find working hours scheme ID.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/employee/employment/workingHoursScheme`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeemploymentworkingHoursSchemeApi - functional programming interface
 * @export
 */
export const EmployeeemploymentworkingHoursSchemeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find working hours scheme ID.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseWorkingHoursScheme> {
            const localVarFetchArgs = EmployeeemploymentworkingHoursSchemeApiFetchParamCreator(configuration).search(from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmployeeemploymentworkingHoursSchemeApi - factory interface
 * @export
 */
export const EmployeeemploymentworkingHoursSchemeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find working hours scheme ID.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return EmployeeemploymentworkingHoursSchemeApiFp(configuration).search(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * EmployeeemploymentworkingHoursSchemeApi - object-oriented interface
 * @export
 * @class EmployeeemploymentworkingHoursSchemeApi
 * @extends {BaseAPI}
 */
export class EmployeeemploymentworkingHoursSchemeApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find working hours scheme ID.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentworkingHoursSchemeApi
     */
    public search(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return EmployeeemploymentworkingHoursSchemeApiFp(this.configuration).search(from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * EmployeeentitlementApi - fetch parameter creator
 * @export
 */
export const EmployeeentitlementApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find all entitlements at client for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [customerId] Client ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        client(employeeId?: number, customerId?: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/employee/entitlement/client`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entitlement by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/employee/entitlement/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update employee entitlements in client account.
         * @param {number} employeeId Employee ID
         * @param {number} customerId Client ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantClientEntitlementsByTemplate(employeeId: number, customerId: number, template: string, options: any = {}): FetchArgs {
            // verify required parameter 'employeeId' is not null or undefined
            if (employeeId === null || employeeId === undefined) {
                throw new RequiredError('employeeId','Required parameter employeeId was null or undefined when calling grantClientEntitlementsByTemplate.');
            }
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling grantClientEntitlementsByTemplate.');
            }
            // verify required parameter 'template' is not null or undefined
            if (template === null || template === undefined) {
                throw new RequiredError('template','Required parameter template was null or undefined when calling grantClientEntitlementsByTemplate.');
            }
            const localVarPath = `/employee/entitlement/:grantClientEntitlementsByTemplate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (template !== undefined) {
                localVarQueryParameter['template'] = template;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The user will only receive the entitlements which are possible with the registered user type
         * @summary [BETA] Update employee entitlements.
         * @param {number} employeeId Employee ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantEntitlementsByTemplate(employeeId: number, template: string, options: any = {}): FetchArgs {
            // verify required parameter 'employeeId' is not null or undefined
            if (employeeId === null || employeeId === undefined) {
                throw new RequiredError('employeeId','Required parameter employeeId was null or undefined when calling grantEntitlementsByTemplate.');
            }
            // verify required parameter 'template' is not null or undefined
            if (template === null || template === undefined) {
                throw new RequiredError('template','Required parameter template was null or undefined when calling grantEntitlementsByTemplate.');
            }
            const localVarPath = `/employee/entitlement/:grantEntitlementsByTemplate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (template !== undefined) {
                localVarQueryParameter['template'] = template;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all entitlements for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/employee/entitlement`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeentitlementApi - functional programming interface
 * @export
 */
export const EmployeeentitlementApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find all entitlements at client for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [customerId] Client ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        client(employeeId?: number, customerId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseEntitlement> {
            const localVarFetchArgs = EmployeeentitlementApiFetchParamCreator(configuration).client(employeeId, customerId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get entitlement by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperEntitlement> {
            const localVarFetchArgs = EmployeeentitlementApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update employee entitlements in client account.
         * @param {number} employeeId Employee ID
         * @param {number} customerId Client ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantClientEntitlementsByTemplate(employeeId: number, customerId: number, template: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmployeeentitlementApiFetchParamCreator(configuration).grantClientEntitlementsByTemplate(employeeId, customerId, template, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The user will only receive the entitlements which are possible with the registered user type
         * @summary [BETA] Update employee entitlements.
         * @param {number} employeeId Employee ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantEntitlementsByTemplate(employeeId: number, template: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmployeeentitlementApiFetchParamCreator(configuration).grantEntitlementsByTemplate(employeeId, template, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all entitlements for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseEntitlement> {
            const localVarFetchArgs = EmployeeentitlementApiFetchParamCreator(configuration).search(employeeId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmployeeentitlementApi - factory interface
 * @export
 */
export const EmployeeentitlementApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find all entitlements at client for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [customerId] Client ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        client(employeeId?: number, customerId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return EmployeeentitlementApiFp(configuration).client(employeeId, customerId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get entitlement by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return EmployeeentitlementApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update employee entitlements in client account.
         * @param {number} employeeId Employee ID
         * @param {number} customerId Client ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantClientEntitlementsByTemplate(employeeId: number, customerId: number, template: string, options?: any) {
            return EmployeeentitlementApiFp(configuration).grantClientEntitlementsByTemplate(employeeId, customerId, template, options)(fetch, basePath);
        },
        /**
         * The user will only receive the entitlements which are possible with the registered user type
         * @summary [BETA] Update employee entitlements.
         * @param {number} employeeId Employee ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantEntitlementsByTemplate(employeeId: number, template: string, options?: any) {
            return EmployeeentitlementApiFp(configuration).grantEntitlementsByTemplate(employeeId, template, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all entitlements for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return EmployeeentitlementApiFp(configuration).search(employeeId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * EmployeeentitlementApi - object-oriented interface
 * @export
 * @class EmployeeentitlementApi
 * @extends {BaseAPI}
 */
export class EmployeeentitlementApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find all entitlements at client for user.
     * @param {} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {} [customerId] Client ID
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeentitlementApi
     */
    public client(employeeId?: number, customerId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return EmployeeentitlementApiFp(this.configuration).client(employeeId, customerId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get entitlement by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeentitlementApi
     */
    public get(id: number, fields?: string, options?: any) {
        return EmployeeentitlementApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update employee entitlements in client account.
     * @param {} employeeId Employee ID
     * @param {} customerId Client ID
     * @param {} template Template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeentitlementApi
     */
    public grantClientEntitlementsByTemplate(employeeId: number, customerId: number, template: string, options?: any) {
        return EmployeeentitlementApiFp(this.configuration).grantClientEntitlementsByTemplate(employeeId, customerId, template, options)(this.fetch, this.basePath);
    }

    /**
     * The user will only receive the entitlements which are possible with the registered user type
     * @summary [BETA] Update employee entitlements.
     * @param {} employeeId Employee ID
     * @param {} template Template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeentitlementApi
     */
    public grantEntitlementsByTemplate(employeeId: number, template: string, options?: any) {
        return EmployeeentitlementApiFp(this.configuration).grantEntitlementsByTemplate(employeeId, template, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all entitlements for user.
     * @param {} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeentitlementApi
     */
    public search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return EmployeeentitlementApiFp(this.configuration).search(employeeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * EmployeestandardTimeApi - fetch parameter creator
 * @export
 */
export const EmployeestandardTimeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find standard time by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/employee/standardTime/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create standard time.
         * @param {StandardTime} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: StandardTime, options: any = {}): FetchArgs {
            const localVarPath = `/employee/standardTime`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StandardTime" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update standard time. 
         * @param {number} id Element ID
         * @param {StandardTime} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: StandardTime, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/employee/standardTime/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StandardTime" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find all standard times for employee.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/employee/standardTime`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeestandardTimeApi - functional programming interface
 * @export
 */
export const EmployeestandardTimeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find standard time by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperStandardTime> {
            const localVarFetchArgs = EmployeestandardTimeApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create standard time.
         * @param {StandardTime} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: StandardTime, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperStandardTime> {
            const localVarFetchArgs = EmployeestandardTimeApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update standard time. 
         * @param {number} id Element ID
         * @param {StandardTime} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: StandardTime, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperStandardTime> {
            const localVarFetchArgs = EmployeestandardTimeApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find all standard times for employee.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseStandardTime> {
            const localVarFetchArgs = EmployeestandardTimeApiFetchParamCreator(configuration).search(employeeId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmployeestandardTimeApi - factory interface
 * @export
 */
export const EmployeestandardTimeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find standard time by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return EmployeestandardTimeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create standard time.
         * @param {StandardTime} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: StandardTime, options?: any) {
            return EmployeestandardTimeApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update standard time. 
         * @param {number} id Element ID
         * @param {StandardTime} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: StandardTime, options?: any) {
            return EmployeestandardTimeApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find all standard times for employee.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return EmployeestandardTimeApiFp(configuration).search(employeeId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * EmployeestandardTimeApi - object-oriented interface
 * @export
 * @class EmployeestandardTimeApi
 * @extends {BaseAPI}
 */
export class EmployeestandardTimeApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find standard time by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeestandardTimeApi
     */
    public get(id: number, fields?: string, options?: any) {
        return EmployeestandardTimeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create standard time.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeestandardTimeApi
     */
    public post(body?: StandardTime, options?: any) {
        return EmployeestandardTimeApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update standard time. 
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeestandardTimeApi
     */
    public put(id: number, body?: StandardTime, options?: any) {
        return EmployeestandardTimeApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find all standard times for employee.
     * @param {} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeestandardTimeApi
     */
    public search(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return EmployeestandardTimeApiFp(this.configuration).search(employeeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * EventApi - fetch parameter creator
 * @export
 */
export const EventApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get all (WebHook) event keys.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/event`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get all (WebHook) event keys.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperMapStringEventInfoDescription> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).get(fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Get all (WebHook) event keys.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(fields?: string, options?: any) {
            return EventApiFp(configuration).get(fields, options)(fetch, basePath);
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Get all (WebHook) event keys.
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public get(fields?: string, options?: any) {
        return EventApiFp(this.configuration).get(fields, options)(this.fetch, this.basePath);
    }

}

/**
 * EventsubscriptionApi - fetch parameter creator
 * @export
 */
export const EventsubscriptionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete the given subscription.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/event/subscription/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get subscription by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/event/subscription/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create a new subscription for current EmployeeToken.
         * @param {Subscription} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Subscription, options: any = {}): FetchArgs {
            const localVarPath = `/event/subscription`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Subscription" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Change a current subscription, based on id.
         * @param {number} id Element ID
         * @param {Subscription} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Subscription, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/event/subscription/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Subscription" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find all ongoing subscriptions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/event/subscription`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsubscriptionApi - functional programming interface
 * @export
 */
export const EventsubscriptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete the given subscription.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventsubscriptionApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get subscription by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperSubscription> {
            const localVarFetchArgs = EventsubscriptionApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create a new subscription for current EmployeeToken.
         * @param {Subscription} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Subscription, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperSubscription> {
            const localVarFetchArgs = EventsubscriptionApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Change a current subscription, based on id.
         * @param {number} id Element ID
         * @param {Subscription} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Subscription, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperSubscription> {
            const localVarFetchArgs = EventsubscriptionApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find all ongoing subscriptions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseSubscription> {
            const localVarFetchArgs = EventsubscriptionApiFetchParamCreator(configuration).search(from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventsubscriptionApi - factory interface
 * @export
 */
export const EventsubscriptionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete the given subscription.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return EventsubscriptionApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get subscription by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return EventsubscriptionApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create a new subscription for current EmployeeToken.
         * @param {Subscription} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Subscription, options?: any) {
            return EventsubscriptionApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Change a current subscription, based on id.
         * @param {number} id Element ID
         * @param {Subscription} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Subscription, options?: any) {
            return EventsubscriptionApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find all ongoing subscriptions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return EventsubscriptionApiFp(configuration).search(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * EventsubscriptionApi - object-oriented interface
 * @export
 * @class EventsubscriptionApi
 * @extends {BaseAPI}
 */
export class EventsubscriptionApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete the given subscription.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsubscriptionApi
     */
    public _delete(id: number, options?: any) {
        return EventsubscriptionApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get subscription by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsubscriptionApi
     */
    public get(id: number, fields?: string, options?: any) {
        return EventsubscriptionApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create a new subscription for current EmployeeToken.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsubscriptionApi
     */
    public post(body?: Subscription, options?: any) {
        return EventsubscriptionApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Change a current subscription, based on id.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsubscriptionApi
     */
    public put(id: number, body?: Subscription, options?: any) {
        return EventsubscriptionApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find all ongoing subscriptions.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsubscriptionApi
     */
    public search(from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return EventsubscriptionApiFp(this.configuration).search(from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * InventoryApi - fetch parameter creator
 * @export
 */
export const InventoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get inventory by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/inventory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find inventory corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {boolean} [isMainInventory] Equals
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, isMainInventory?: boolean, isInactive?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/inventory`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (isMainInventory !== undefined) {
                localVarQueryParameter['isMainInventory'] = isMainInventory;
            }

            if (isInactive !== undefined) {
                localVarQueryParameter['isInactive'] = isInactive;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoryApi - functional programming interface
 * @export
 */
export const InventoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get inventory by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperInventory> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find inventory corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {boolean} [isMainInventory] Equals
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, isMainInventory?: boolean, isInactive?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseInventory> {
            const localVarFetchArgs = InventoryApiFetchParamCreator(configuration).search(id, name, isMainInventory, isInactive, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InventoryApi - factory interface
 * @export
 */
export const InventoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get inventory by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return InventoryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find inventory corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {boolean} [isMainInventory] Equals
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, isMainInventory?: boolean, isInactive?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return InventoryApiFp(configuration).search(id, name, isMainInventory, isInactive, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
export class InventoryApi extends BaseAPI {
    /**
     * 
     * @summary Get inventory by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public get(id: number, fields?: string, options?: any) {
        return InventoryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find inventory corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [name] Containing
     * @param {} [isMainInventory] Equals
     * @param {} [isInactive] Equals
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public search(id?: string, name?: string, isMainInventory?: boolean, isInactive?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return InventoryApiFp(this.configuration).search(id, name, isMainInventory, isInactive, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * InvoiceApi - fetch parameter creator
 * @export
 */
export const InvoiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get invoice document by invoice ID.
         * @param {number} invoiceId Invoice ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf(invoiceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling downloadPdf.');
            }
            const localVarPath = `/invoice/{invoiceId}/pdf`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invoice by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/invoice/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update invoice. The invoice is updated with payment information. The amount is in the invoice’s currency.
         * @param {number} id Invoice id
         * @param {string} paymentDate Payment date
         * @param {number} paymentTypeId PaymentType id
         * @param {number} paidAmount Amount paid by customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payment(id: number, paymentDate: string, paymentTypeId: number, paidAmount: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling payment.');
            }
            // verify required parameter 'paymentDate' is not null or undefined
            if (paymentDate === null || paymentDate === undefined) {
                throw new RequiredError('paymentDate','Required parameter paymentDate was null or undefined when calling payment.');
            }
            // verify required parameter 'paymentTypeId' is not null or undefined
            if (paymentTypeId === null || paymentTypeId === undefined) {
                throw new RequiredError('paymentTypeId','Required parameter paymentTypeId was null or undefined when calling payment.');
            }
            // verify required parameter 'paidAmount' is not null or undefined
            if (paidAmount === null || paidAmount === undefined) {
                throw new RequiredError('paidAmount','Required parameter paidAmount was null or undefined when calling payment.');
            }
            const localVarPath = `/invoice/{id}/:payment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (paymentDate !== undefined) {
                localVarQueryParameter['paymentDate'] = paymentDate;
            }

            if (paymentTypeId !== undefined) {
                localVarQueryParameter['paymentTypeId'] = paymentTypeId;
            }

            if (paidAmount !== undefined) {
                localVarQueryParameter['paidAmount'] = paidAmount;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create invoice.
         * @param {Invoice} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {boolean} [sendToCustomer] Equals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Invoice, sendToCustomer?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/invoice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (sendToCustomer !== undefined) {
                localVarQueryParameter['sendToCustomer'] = sendToCustomer;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Invoice" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find invoices corresponding with sent data.
         * @param {string} invoiceDateFrom From and including
         * @param {string} invoiceDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [invoiceNumber] Equals
         * @param {string} [kid] Equals
         * @param {string} [voucherId] Equals
         * @param {string} [customerId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(invoiceDateFrom: string, invoiceDateTo: string, id?: string, invoiceNumber?: string, kid?: string, voucherId?: string, customerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceDateFrom' is not null or undefined
            if (invoiceDateFrom === null || invoiceDateFrom === undefined) {
                throw new RequiredError('invoiceDateFrom','Required parameter invoiceDateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'invoiceDateTo' is not null or undefined
            if (invoiceDateTo === null || invoiceDateTo === undefined) {
                throw new RequiredError('invoiceDateTo','Required parameter invoiceDateTo was null or undefined when calling search.');
            }
            const localVarPath = `/invoice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (invoiceDateFrom !== undefined) {
                localVarQueryParameter['invoiceDateFrom'] = invoiceDateFrom;
            }

            if (invoiceDateTo !== undefined) {
                localVarQueryParameter['invoiceDateTo'] = invoiceDateTo;
            }

            if (invoiceNumber !== undefined) {
                localVarQueryParameter['invoiceNumber'] = invoiceNumber;
            }

            if (kid !== undefined) {
                localVarQueryParameter['kid'] = kid;
            }

            if (voucherId !== undefined) {
                localVarQueryParameter['voucherId'] = voucherId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Send invoice by ID and sendType. Optionally override email recipient.
         * @param {number} id Element ID
         * @param {string} sendType SendType
         * @param {string} [overrideEmailAddress] Will override email address if sendType &#x3D; EMAIL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send(id: number, sendType: string, overrideEmailAddress?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling send.');
            }
            // verify required parameter 'sendType' is not null or undefined
            if (sendType === null || sendType === undefined) {
                throw new RequiredError('sendType','Required parameter sendType was null or undefined when calling send.');
            }
            const localVarPath = `/invoice/{id}/:send`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (sendType !== undefined) {
                localVarQueryParameter['sendType'] = sendType;
            }

            if (overrideEmailAddress !== undefined) {
                localVarQueryParameter['overrideEmailAddress'] = overrideEmailAddress;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceApi - functional programming interface
 * @export
 */
export const InvoiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get invoice document by invoice ID.
         * @param {number} invoiceId Invoice ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf(invoiceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).downloadPdf(invoiceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get invoice by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update invoice. The invoice is updated with payment information. The amount is in the invoice’s currency.
         * @param {number} id Invoice id
         * @param {string} paymentDate Payment date
         * @param {number} paymentTypeId PaymentType id
         * @param {number} paidAmount Amount paid by customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payment(id: number, paymentDate: string, paymentTypeId: number, paidAmount: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).payment(id, paymentDate, paymentTypeId, paidAmount, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create invoice.
         * @param {Invoice} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {boolean} [sendToCustomer] Equals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Invoice, sendToCustomer?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).post(body, sendToCustomer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find invoices corresponding with sent data.
         * @param {string} invoiceDateFrom From and including
         * @param {string} invoiceDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [invoiceNumber] Equals
         * @param {string} [kid] Equals
         * @param {string} [voucherId] Equals
         * @param {string} [customerId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(invoiceDateFrom: string, invoiceDateTo: string, id?: string, invoiceNumber?: string, kid?: string, voucherId?: string, customerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).search(invoiceDateFrom, invoiceDateTo, id, invoiceNumber, kid, voucherId, customerId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Send invoice by ID and sendType. Optionally override email recipient.
         * @param {number} id Element ID
         * @param {string} sendType SendType
         * @param {string} [overrideEmailAddress] Will override email address if sendType &#x3D; EMAIL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send(id: number, sendType: string, overrideEmailAddress?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).send(id, sendType, overrideEmailAddress, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InvoiceApi - factory interface
 * @export
 */
export const InvoiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get invoice document by invoice ID.
         * @param {number} invoiceId Invoice ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf(invoiceId: number, options?: any) {
            return InvoiceApiFp(configuration).downloadPdf(invoiceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get invoice by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return InvoiceApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update invoice. The invoice is updated with payment information. The amount is in the invoice’s currency.
         * @param {number} id Invoice id
         * @param {string} paymentDate Payment date
         * @param {number} paymentTypeId PaymentType id
         * @param {number} paidAmount Amount paid by customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payment(id: number, paymentDate: string, paymentTypeId: number, paidAmount: number, options?: any) {
            return InvoiceApiFp(configuration).payment(id, paymentDate, paymentTypeId, paidAmount, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create invoice.
         * @param {Invoice} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {boolean} [sendToCustomer] Equals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Invoice, sendToCustomer?: boolean, options?: any) {
            return InvoiceApiFp(configuration).post(body, sendToCustomer, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find invoices corresponding with sent data.
         * @param {string} invoiceDateFrom From and including
         * @param {string} invoiceDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [invoiceNumber] Equals
         * @param {string} [kid] Equals
         * @param {string} [voucherId] Equals
         * @param {string} [customerId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(invoiceDateFrom: string, invoiceDateTo: string, id?: string, invoiceNumber?: string, kid?: string, voucherId?: string, customerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return InvoiceApiFp(configuration).search(invoiceDateFrom, invoiceDateTo, id, invoiceNumber, kid, voucherId, customerId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Send invoice by ID and sendType. Optionally override email recipient.
         * @param {number} id Element ID
         * @param {string} sendType SendType
         * @param {string} [overrideEmailAddress] Will override email address if sendType &#x3D; EMAIL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send(id: number, sendType: string, overrideEmailAddress?: string, options?: any) {
            return InvoiceApiFp(configuration).send(id, sendType, overrideEmailAddress, options)(fetch, basePath);
        },
    };
};

/**
 * InvoiceApi - object-oriented interface
 * @export
 * @class InvoiceApi
 * @extends {BaseAPI}
 */
export class InvoiceApi extends BaseAPI {
    /**
     * 
     * @summary Get invoice document by invoice ID.
     * @param {} invoiceId Invoice ID from which PDF is downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public downloadPdf(invoiceId: number, options?: any) {
        return InvoiceApiFp(this.configuration).downloadPdf(invoiceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get invoice by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public get(id: number, fields?: string, options?: any) {
        return InvoiceApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update invoice. The invoice is updated with payment information. The amount is in the invoice’s currency.
     * @param {} id Invoice id
     * @param {} paymentDate Payment date
     * @param {} paymentTypeId PaymentType id
     * @param {} paidAmount Amount paid by customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public payment(id: number, paymentDate: string, paymentTypeId: number, paidAmount: number, options?: any) {
        return InvoiceApiFp(this.configuration).payment(id, paymentDate, paymentTypeId, paidAmount, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create invoice.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {} [sendToCustomer] Equals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public post(body?: Invoice, sendToCustomer?: boolean, options?: any) {
        return InvoiceApiFp(this.configuration).post(body, sendToCustomer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find invoices corresponding with sent data.
     * @param {} invoiceDateFrom From and including
     * @param {} invoiceDateTo To and excluding
     * @param {} [id] List of IDs
     * @param {} [invoiceNumber] Equals
     * @param {} [kid] Equals
     * @param {} [voucherId] Equals
     * @param {} [customerId] Equals
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public search(invoiceDateFrom: string, invoiceDateTo: string, id?: string, invoiceNumber?: string, kid?: string, voucherId?: string, customerId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return InvoiceApiFp(this.configuration).search(invoiceDateFrom, invoiceDateTo, id, invoiceNumber, kid, voucherId, customerId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Send invoice by ID and sendType. Optionally override email recipient.
     * @param {} id Element ID
     * @param {} sendType SendType
     * @param {} [overrideEmailAddress] Will override email address if sendType &#x3D; EMAIL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public send(id: number, sendType: string, overrideEmailAddress?: string, options?: any) {
        return InvoiceApiFp(this.configuration).send(id, sendType, overrideEmailAddress, options)(this.fetch, this.basePath);
    }

}

/**
 * InvoicepaymentTypeApi - fetch parameter creator
 * @export
 */
export const InvoicepaymentTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/invoice/paymentType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/invoice/paymentType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicepaymentTypeApi - functional programming interface
 * @export
 */
export const InvoicepaymentTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPaymentType> {
            const localVarFetchArgs = InvoicepaymentTypeApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponsePaymentType> {
            const localVarFetchArgs = InvoicepaymentTypeApiFetchParamCreator(configuration).search(id, description, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InvoicepaymentTypeApi - factory interface
 * @export
 */
export const InvoicepaymentTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return InvoicepaymentTypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return InvoicepaymentTypeApiFp(configuration).search(id, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * InvoicepaymentTypeApi - object-oriented interface
 * @export
 * @class InvoicepaymentTypeApi
 * @extends {BaseAPI}
 */
export class InvoicepaymentTypeApi extends BaseAPI {
    /**
     * 
     * @summary Get payment type by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicepaymentTypeApi
     */
    public get(id: number, fields?: string, options?: any) {
        return InvoicepaymentTypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find payment type corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [description] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicepaymentTypeApi
     */
    public search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return InvoicepaymentTypeApiFp(this.configuration).search(id, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * LedgerApi - fetch parameter creator
 * @export
 */
export const LedgerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost(date: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, fields?: string, from?: number, count?: number, sorting?: string, options: any = {}): FetchArgs {
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling openPost.');
            }
            const localVarPath = `/ledger/openPost`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (supplierId !== undefined) {
                localVarQueryParameter['supplierId'] = supplierId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get ledger (hovedbok).
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, openPostings?: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, fields?: string, from?: number, count?: number, sorting?: string, options: any = {}): FetchArgs {
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom','Required parameter dateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'dateTo' is not null or undefined
            if (dateTo === null || dateTo === undefined) {
                throw new RequiredError('dateTo','Required parameter dateTo was null or undefined when calling search.');
            }
            const localVarPath = `/ledger`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            if (openPostings !== undefined) {
                localVarQueryParameter['openPostings'] = openPostings;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (supplierId !== undefined) {
                localVarQueryParameter['supplierId'] = supplierId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgerApi - functional programming interface
 * @export
 */
export const LedgerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost(date: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, fields?: string, from?: number, count?: number, sorting?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseLedgerAccount> {
            const localVarFetchArgs = LedgerApiFetchParamCreator(configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get ledger (hovedbok).
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, openPostings?: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, fields?: string, from?: number, count?: number, sorting?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseLedgerAccount> {
            const localVarFetchArgs = LedgerApiFetchParamCreator(configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LedgerApi - factory interface
 * @export
 */
export const LedgerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost(date: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, fields?: string, from?: number, count?: number, sorting?: string, options?: any) {
            return LedgerApiFp(configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get ledger (hovedbok).
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, openPostings?: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, fields?: string, from?: number, count?: number, sorting?: string, options?: any) {
            return LedgerApiFp(configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options)(fetch, basePath);
        },
    };
};

/**
 * LedgerApi - object-oriented interface
 * @export
 * @class LedgerApi
 * @extends {BaseAPI}
 */
export class LedgerApi extends BaseAPI {
    /**
     * 
     * @summary Find open posts corresponding with sent data.
     * @param {} date Invoice date. Format is yyyy-MM-dd (to and excl.).
     * @param {} [accountId] Element ID
     * @param {} [supplierId] Element ID
     * @param {} [customerId] Element ID
     * @param {} [employeeId] Element ID
     * @param {} [departmentId] Element ID
     * @param {} [projectId] Element ID
     * @param {} [productId] Element ID
     * @param {} [fields] Fields filter pattern
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerApi
     */
    public openPost(date: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, fields?: string, from?: number, count?: number, sorting?: string, options?: any) {
        return LedgerApiFp(this.configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get ledger (hovedbok).
     * @param {} dateFrom Format is yyyy-MM-dd (from and incl.).
     * @param {} dateTo Format is yyyy-MM-dd (to and excl.).
     * @param {} [openPostings] Deprecated
     * @param {} [accountId] Element ID
     * @param {} [supplierId] Element ID
     * @param {} [customerId] Element ID
     * @param {} [employeeId] Element ID
     * @param {} [departmentId] Element ID
     * @param {} [projectId] Element ID
     * @param {} [productId] Element ID
     * @param {} [fields] Fields filter pattern
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerApi
     */
    public search(dateFrom: string, dateTo: string, openPostings?: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, fields?: string, from?: number, count?: number, sorting?: string, options?: any) {
        return LedgerApiFp(this.configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options)(this.fetch, this.basePath);
    }

}

/**
 * LedgeraccountApi - fetch parameter creator
 * @export
 */
export const LedgeraccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete account.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/ledger/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Delete multiple accounts.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteByIds.');
            }
            const localVarPath = `/ledger/account/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/ledger/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create a new account.
         * @param {Account} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Account, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Account" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create several accounts.
         * @param {Array&lt;Account&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Account>, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/account/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Account&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update account.
         * @param {number} id Element ID
         * @param {Account} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Account, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/ledger/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Account" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update multiple accounts.
         * @param {Array&lt;Account&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<Account>, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/account/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Account&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {boolean} [isBankAccount] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, number?: string, isBankAccount?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (isBankAccount !== undefined) {
                localVarQueryParameter['isBankAccount'] = isBankAccount;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgeraccountApi - functional programming interface
 * @export
 */
export const LedgeraccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete account.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LedgeraccountApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Delete multiple accounts.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LedgeraccountApiFetchParamCreator(configuration).deleteByIds(ids, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperAccount> {
            const localVarFetchArgs = LedgeraccountApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create a new account.
         * @param {Account} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Account, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperAccount> {
            const localVarFetchArgs = LedgeraccountApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create several accounts.
         * @param {Array&lt;Account&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Account>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseAccount> {
            const localVarFetchArgs = LedgeraccountApiFetchParamCreator(configuration).postList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update account.
         * @param {number} id Element ID
         * @param {Account} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Account, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperAccount> {
            const localVarFetchArgs = LedgeraccountApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update multiple accounts.
         * @param {Array&lt;Account&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<Account>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseAccount> {
            const localVarFetchArgs = LedgeraccountApiFetchParamCreator(configuration).putList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {boolean} [isBankAccount] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, number?: string, isBankAccount?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseAccount> {
            const localVarFetchArgs = LedgeraccountApiFetchParamCreator(configuration).search(id, number, isBankAccount, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LedgeraccountApi - factory interface
 * @export
 */
export const LedgeraccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete account.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return LedgeraccountApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Delete multiple accounts.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds(ids: string, options?: any) {
            return LedgeraccountApiFp(configuration).deleteByIds(ids, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return LedgeraccountApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create a new account.
         * @param {Account} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Account, options?: any) {
            return LedgeraccountApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create several accounts.
         * @param {Array&lt;Account&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Account>, options?: any) {
            return LedgeraccountApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update account.
         * @param {number} id Element ID
         * @param {Account} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Account, options?: any) {
            return LedgeraccountApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update multiple accounts.
         * @param {Array&lt;Account&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<Account>, options?: any) {
            return LedgeraccountApiFp(configuration).putList(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {boolean} [isBankAccount] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, number?: string, isBankAccount?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return LedgeraccountApiFp(configuration).search(id, number, isBankAccount, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * LedgeraccountApi - object-oriented interface
 * @export
 * @class LedgeraccountApi
 * @extends {BaseAPI}
 */
export class LedgeraccountApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete account.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    public _delete(id: number, options?: any) {
        return LedgeraccountApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Delete multiple accounts.
     * @param {} ids ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    public deleteByIds(ids: string, options?: any) {
        return LedgeraccountApiFp(this.configuration).deleteByIds(ids, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get account by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    public get(id: number, fields?: string, options?: any) {
        return LedgeraccountApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create a new account.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    public post(body?: Account, options?: any) {
        return LedgeraccountApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create several accounts.
     * @param {} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    public postList(body?: Array<Account>, options?: any) {
        return LedgeraccountApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update account.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    public put(id: number, body?: Account, options?: any) {
        return LedgeraccountApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update multiple accounts.
     * @param {} [body] JSON representing updates to object. Should have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    public putList(body?: Array<Account>, options?: any) {
        return LedgeraccountApiFp(this.configuration).putList(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find accounts corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [number] List of IDs
     * @param {} [isBankAccount] Equals
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    public search(id?: string, number?: string, isBankAccount?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return LedgeraccountApiFp(this.configuration).search(id, number, isBankAccount, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * LedgeraccountingPeriodApi - fetch parameter creator
 * @export
 */
export const LedgeraccountingPeriodApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get accounting period by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/ledger/accountingPeriod/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find accounting periods corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [startFrom] From and including
         * @param {string} [startTo] To and excluding
         * @param {string} [endFrom] From and including
         * @param {string} [endTo] To and excluding
         * @param {number} [count] Number of elements to return
         * @param {number} [from] From index
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, numberFrom?: number, numberTo?: number, startFrom?: string, startTo?: string, endFrom?: string, endTo?: string, count?: number, from?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/accountingPeriod`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (numberFrom !== undefined) {
                localVarQueryParameter['numberFrom'] = numberFrom;
            }

            if (numberTo !== undefined) {
                localVarQueryParameter['numberTo'] = numberTo;
            }

            if (startFrom !== undefined) {
                localVarQueryParameter['startFrom'] = startFrom;
            }

            if (startTo !== undefined) {
                localVarQueryParameter['startTo'] = startTo;
            }

            if (endFrom !== undefined) {
                localVarQueryParameter['endFrom'] = endFrom;
            }

            if (endTo !== undefined) {
                localVarQueryParameter['endTo'] = endTo;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgeraccountingPeriodApi - functional programming interface
 * @export
 */
export const LedgeraccountingPeriodApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get accounting period by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperAccountingPeriod> {
            const localVarFetchArgs = LedgeraccountingPeriodApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find accounting periods corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [startFrom] From and including
         * @param {string} [startTo] To and excluding
         * @param {string} [endFrom] From and including
         * @param {string} [endTo] To and excluding
         * @param {number} [count] Number of elements to return
         * @param {number} [from] From index
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, numberFrom?: number, numberTo?: number, startFrom?: string, startTo?: string, endFrom?: string, endTo?: string, count?: number, from?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseAccountingPeriod> {
            const localVarFetchArgs = LedgeraccountingPeriodApiFetchParamCreator(configuration).search(id, numberFrom, numberTo, startFrom, startTo, endFrom, endTo, count, from, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LedgeraccountingPeriodApi - factory interface
 * @export
 */
export const LedgeraccountingPeriodApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get accounting period by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return LedgeraccountingPeriodApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find accounting periods corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [startFrom] From and including
         * @param {string} [startTo] To and excluding
         * @param {string} [endFrom] From and including
         * @param {string} [endTo] To and excluding
         * @param {number} [count] Number of elements to return
         * @param {number} [from] From index
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, numberFrom?: number, numberTo?: number, startFrom?: string, startTo?: string, endFrom?: string, endTo?: string, count?: number, from?: number, sorting?: string, fields?: string, options?: any) {
            return LedgeraccountingPeriodApiFp(configuration).search(id, numberFrom, numberTo, startFrom, startTo, endFrom, endTo, count, from, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * LedgeraccountingPeriodApi - object-oriented interface
 * @export
 * @class LedgeraccountingPeriodApi
 * @extends {BaseAPI}
 */
export class LedgeraccountingPeriodApi extends BaseAPI {
    /**
     * 
     * @summary Get accounting period by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountingPeriodApi
     */
    public get(id: number, fields?: string, options?: any) {
        return LedgeraccountingPeriodApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find accounting periods corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [numberFrom] From and including
     * @param {} [numberTo] To and excluding
     * @param {} [startFrom] From and including
     * @param {} [startTo] To and excluding
     * @param {} [endFrom] From and including
     * @param {} [endTo] To and excluding
     * @param {} [count] Number of elements to return
     * @param {} [from] From index
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountingPeriodApi
     */
    public search(id?: string, numberFrom?: number, numberTo?: number, startFrom?: string, startTo?: string, endFrom?: string, endTo?: string, count?: number, from?: number, sorting?: string, fields?: string, options?: any) {
        return LedgeraccountingPeriodApiFp(this.configuration).search(id, numberFrom, numberTo, startFrom, startTo, endFrom, endTo, count, from, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * LedgerannualAccountApi - fetch parameter creator
 * @export
 */
export const LedgerannualAccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get annual account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/ledger/annualAccount/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find annual accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, yearFrom?: number, yearTo?: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/annualAccount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (yearFrom !== undefined) {
                localVarQueryParameter['yearFrom'] = yearFrom;
            }

            if (yearTo !== undefined) {
                localVarQueryParameter['yearTo'] = yearTo;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgerannualAccountApi - functional programming interface
 * @export
 */
export const LedgerannualAccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get annual account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperAnnualAccount> {
            const localVarFetchArgs = LedgerannualAccountApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find annual accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, yearFrom?: number, yearTo?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseAnnualAccount> {
            const localVarFetchArgs = LedgerannualAccountApiFetchParamCreator(configuration).search(id, yearFrom, yearTo, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LedgerannualAccountApi - factory interface
 * @export
 */
export const LedgerannualAccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get annual account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return LedgerannualAccountApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find annual accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, yearFrom?: number, yearTo?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return LedgerannualAccountApiFp(configuration).search(id, yearFrom, yearTo, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * LedgerannualAccountApi - object-oriented interface
 * @export
 * @class LedgerannualAccountApi
 * @extends {BaseAPI}
 */
export class LedgerannualAccountApi extends BaseAPI {
    /**
     * 
     * @summary Get annual account by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerannualAccountApi
     */
    public get(id: number, fields?: string, options?: any) {
        return LedgerannualAccountApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find annual accounts corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [yearFrom] From and including
     * @param {} [yearTo] To and excluding
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerannualAccountApi
     */
    public search(id?: string, yearFrom?: number, yearTo?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return LedgerannualAccountApiFp(this.configuration).search(id, yearFrom, yearTo, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * LedgercloseGroupApi - fetch parameter creator
 * @export
 */
export const LedgercloseGroupApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get close group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/ledger/closeGroup/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find close groups corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, id?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom','Required parameter dateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'dateTo' is not null or undefined
            if (dateTo === null || dateTo === undefined) {
                throw new RequiredError('dateTo','Required parameter dateTo was null or undefined when calling search.');
            }
            const localVarPath = `/ledger/closeGroup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgercloseGroupApi - functional programming interface
 * @export
 */
export const LedgercloseGroupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get close group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCloseGroup> {
            const localVarFetchArgs = LedgercloseGroupApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find close groups corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, id?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseCloseGroup> {
            const localVarFetchArgs = LedgercloseGroupApiFetchParamCreator(configuration).search(dateFrom, dateTo, id, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LedgercloseGroupApi - factory interface
 * @export
 */
export const LedgercloseGroupApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get close group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return LedgercloseGroupApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find close groups corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, id?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return LedgercloseGroupApiFp(configuration).search(dateFrom, dateTo, id, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * LedgercloseGroupApi - object-oriented interface
 * @export
 * @class LedgercloseGroupApi
 * @extends {BaseAPI}
 */
export class LedgercloseGroupApi extends BaseAPI {
    /**
     * 
     * @summary Get close group by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgercloseGroupApi
     */
    public get(id: number, fields?: string, options?: any) {
        return LedgercloseGroupApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find close groups corresponding with sent data.
     * @param {} dateFrom From and including
     * @param {} dateTo To and excluding
     * @param {} [id] List of IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgercloseGroupApi
     */
    public search(dateFrom: string, dateTo: string, id?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return LedgercloseGroupApiFp(this.configuration).search(dateFrom, dateTo, id, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * LedgerpaymentTypeOutApi - fetch parameter creator
 * @export
 */
export const LedgerpaymentTypeOutApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/ledger/paymentTypeOut/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/ledger/paymentTypeOut/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create new payment type for outgoing payments
         * @param {PaymentTypeOut} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: PaymentTypeOut, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/paymentTypeOut`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentTypeOut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create multiple payment types for outgoing payments at once
         * @param {Array&lt;PaymentTypeOut&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<PaymentTypeOut>, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/paymentTypeOut/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;PaymentTypeOut&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update existing payment type for outgoing payments
         * @param {number} id Element ID
         * @param {PaymentTypeOut} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: PaymentTypeOut, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/ledger/paymentTypeOut/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentTypeOut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update multiple payment types for outgoing payments at once
         * @param {Array&lt;PaymentTypeOut&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<PaymentTypeOut>, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/paymentTypeOut/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;PaymentTypeOut&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is an API endpoint for getting payment types for outgoing payments. This is equivalent to the section 'Outgoing Payments' under Accounts Settings in Tripletex. These are the payment types listed in supplier invoices, vat returns, salary payments and Tax/ENI
         * @summary [BETA] Gets payment types for outgoing payments
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, isInactive?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/paymentTypeOut`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (isInactive !== undefined) {
                localVarQueryParameter['isInactive'] = isInactive;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgerpaymentTypeOutApi - functional programming interface
 * @export
 */
export const LedgerpaymentTypeOutApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LedgerpaymentTypeOutApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPaymentTypeOut> {
            const localVarFetchArgs = LedgerpaymentTypeOutApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create new payment type for outgoing payments
         * @param {PaymentTypeOut} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: PaymentTypeOut, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPaymentTypeOut> {
            const localVarFetchArgs = LedgerpaymentTypeOutApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create multiple payment types for outgoing payments at once
         * @param {Array&lt;PaymentTypeOut&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<PaymentTypeOut>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponsePaymentTypeOut> {
            const localVarFetchArgs = LedgerpaymentTypeOutApiFetchParamCreator(configuration).postList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update existing payment type for outgoing payments
         * @param {number} id Element ID
         * @param {PaymentTypeOut} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: PaymentTypeOut, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPaymentTypeOut> {
            const localVarFetchArgs = LedgerpaymentTypeOutApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update multiple payment types for outgoing payments at once
         * @param {Array&lt;PaymentTypeOut&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<PaymentTypeOut>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponsePaymentTypeOut> {
            const localVarFetchArgs = LedgerpaymentTypeOutApiFetchParamCreator(configuration).putList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This is an API endpoint for getting payment types for outgoing payments. This is equivalent to the section 'Outgoing Payments' under Accounts Settings in Tripletex. These are the payment types listed in supplier invoices, vat returns, salary payments and Tax/ENI
         * @summary [BETA] Gets payment types for outgoing payments
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, isInactive?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponsePaymentTypeOut> {
            const localVarFetchArgs = LedgerpaymentTypeOutApiFetchParamCreator(configuration).search(id, description, isInactive, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LedgerpaymentTypeOutApi - factory interface
 * @export
 */
export const LedgerpaymentTypeOutApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return LedgerpaymentTypeOutApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return LedgerpaymentTypeOutApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create new payment type for outgoing payments
         * @param {PaymentTypeOut} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: PaymentTypeOut, options?: any) {
            return LedgerpaymentTypeOutApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create multiple payment types for outgoing payments at once
         * @param {Array&lt;PaymentTypeOut&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<PaymentTypeOut>, options?: any) {
            return LedgerpaymentTypeOutApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update existing payment type for outgoing payments
         * @param {number} id Element ID
         * @param {PaymentTypeOut} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: PaymentTypeOut, options?: any) {
            return LedgerpaymentTypeOutApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update multiple payment types for outgoing payments at once
         * @param {Array&lt;PaymentTypeOut&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<PaymentTypeOut>, options?: any) {
            return LedgerpaymentTypeOutApiFp(configuration).putList(body, options)(fetch, basePath);
        },
        /**
         * This is an API endpoint for getting payment types for outgoing payments. This is equivalent to the section 'Outgoing Payments' under Accounts Settings in Tripletex. These are the payment types listed in supplier invoices, vat returns, salary payments and Tax/ENI
         * @summary [BETA] Gets payment types for outgoing payments
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, isInactive?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return LedgerpaymentTypeOutApiFp(configuration).search(id, description, isInactive, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * LedgerpaymentTypeOutApi - object-oriented interface
 * @export
 * @class LedgerpaymentTypeOutApi
 * @extends {BaseAPI}
 */
export class LedgerpaymentTypeOutApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete payment type for outgoing payments by ID.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    public _delete(id: number, options?: any) {
        return LedgerpaymentTypeOutApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get payment type for outgoing payments by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    public get(id: number, fields?: string, options?: any) {
        return LedgerpaymentTypeOutApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create new payment type for outgoing payments
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    public post(body?: PaymentTypeOut, options?: any) {
        return LedgerpaymentTypeOutApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create multiple payment types for outgoing payments at once
     * @param {} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    public postList(body?: Array<PaymentTypeOut>, options?: any) {
        return LedgerpaymentTypeOutApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update existing payment type for outgoing payments
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    public put(id: number, body?: PaymentTypeOut, options?: any) {
        return LedgerpaymentTypeOutApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update multiple payment types for outgoing payments at once
     * @param {} [body] JSON representing updates to object. Should have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    public putList(body?: Array<PaymentTypeOut>, options?: any) {
        return LedgerpaymentTypeOutApiFp(this.configuration).putList(body, options)(this.fetch, this.basePath);
    }

    /**
     * This is an API endpoint for getting payment types for outgoing payments. This is equivalent to the section 'Outgoing Payments' under Accounts Settings in Tripletex. These are the payment types listed in supplier invoices, vat returns, salary payments and Tax/ENI
     * @summary [BETA] Gets payment types for outgoing payments
     * @param {} [id] List of IDs
     * @param {} [description] Containing
     * @param {} [isInactive] Equals
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    public search(id?: string, description?: string, isInactive?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return LedgerpaymentTypeOutApiFp(this.configuration).search(id, description, isInactive, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * LedgerpostingApi - fetch parameter creator
 * @export
 */
export const LedgerpostingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find postings by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/ledger/posting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost(date: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling openPost.');
            }
            const localVarPath = `/ledger/posting/openPost`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (supplierId !== undefined) {
                localVarQueryParameter['supplierId'] = supplierId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find postings corresponding with sent data.
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, openPostings?: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom','Required parameter dateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'dateTo' is not null or undefined
            if (dateTo === null || dateTo === undefined) {
                throw new RequiredError('dateTo','Required parameter dateTo was null or undefined when calling search.');
            }
            const localVarPath = `/ledger/posting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            if (openPostings !== undefined) {
                localVarQueryParameter['openPostings'] = openPostings;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (supplierId !== undefined) {
                localVarQueryParameter['supplierId'] = supplierId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgerpostingApi - functional programming interface
 * @export
 */
export const LedgerpostingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find postings by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPosting> {
            const localVarFetchArgs = LedgerpostingApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost(date: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponsePosting> {
            const localVarFetchArgs = LedgerpostingApiFetchParamCreator(configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find postings corresponding with sent data.
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, openPostings?: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponsePosting> {
            const localVarFetchArgs = LedgerpostingApiFetchParamCreator(configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LedgerpostingApi - factory interface
 * @export
 */
export const LedgerpostingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Find postings by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return LedgerpostingApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost(date: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return LedgerpostingApiFp(configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find postings corresponding with sent data.
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, openPostings?: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return LedgerpostingApiFp(configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * LedgerpostingApi - object-oriented interface
 * @export
 * @class LedgerpostingApi
 * @extends {BaseAPI}
 */
export class LedgerpostingApi extends BaseAPI {
    /**
     * 
     * @summary Find postings by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpostingApi
     */
    public get(id: number, fields?: string, options?: any) {
        return LedgerpostingApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find open posts corresponding with sent data.
     * @param {} date Invoice date. Format is yyyy-MM-dd (to and excl.).
     * @param {} [accountId] Element ID
     * @param {} [supplierId] Element ID
     * @param {} [customerId] Element ID
     * @param {} [employeeId] Element ID
     * @param {} [departmentId] Element ID
     * @param {} [projectId] Element ID
     * @param {} [productId] Element ID
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpostingApi
     */
    public openPost(date: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return LedgerpostingApiFp(this.configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find postings corresponding with sent data.
     * @param {} dateFrom Format is yyyy-MM-dd (from and incl.).
     * @param {} dateTo Format is yyyy-MM-dd (to and excl.).
     * @param {} [openPostings] Deprecated
     * @param {} [accountId] Element ID
     * @param {} [supplierId] Element ID
     * @param {} [customerId] Element ID
     * @param {} [employeeId] Element ID
     * @param {} [departmentId] Element ID
     * @param {} [projectId] Element ID
     * @param {} [productId] Element ID
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpostingApi
     */
    public search(dateFrom: string, dateTo: string, openPostings?: string, accountId?: number, supplierId?: number, customerId?: number, employeeId?: number, departmentId?: number, projectId?: number, productId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return LedgerpostingApiFp(this.configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * LedgervatTypeApi - fetch parameter creator
 * @export
 */
export const LedgervatTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get vat type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/ledger/vatType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find vat types corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, number?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/vatType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgervatTypeApi - functional programming interface
 * @export
 */
export const LedgervatTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get vat type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperVatType> {
            const localVarFetchArgs = LedgervatTypeApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find vat types corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, number?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseVatType> {
            const localVarFetchArgs = LedgervatTypeApiFetchParamCreator(configuration).search(id, number, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LedgervatTypeApi - factory interface
 * @export
 */
export const LedgervatTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get vat type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return LedgervatTypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find vat types corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, number?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return LedgervatTypeApiFp(configuration).search(id, number, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * LedgervatTypeApi - object-oriented interface
 * @export
 * @class LedgervatTypeApi
 * @extends {BaseAPI}
 */
export class LedgervatTypeApi extends BaseAPI {
    /**
     * 
     * @summary Get vat type by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervatTypeApi
     */
    public get(id: number, fields?: string, options?: any) {
        return LedgervatTypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find vat types corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [number] List of IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervatTypeApi
     */
    public search(id?: string, number?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return LedgervatTypeApiFp(this.configuration).search(id, number, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * LedgervoucherApi - fetch parameter creator
 * @export
 */
export const LedgervoucherApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get attachment by voucher ID.
         * @param {number} voucherId Voucher ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf(voucherId: number, options: any = {}): FetchArgs {
            // verify required parameter 'voucherId' is not null or undefined
            if (voucherId === null || voucherId === undefined) {
                throw new RequiredError('voucherId','Required parameter voucherId was null or undefined when calling downloadPdf.');
            }
            const localVarPath = `/ledger/voucher/{voucherId}/pdf`
                .replace(`{${"voucherId"}}`, encodeURIComponent(String(voucherId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get voucher by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/ledger/voucher/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import GBAT10. Send as multipart form.
         * @param {boolean} generateVatPostings If the import should generate VAT postings
         * @param {any} file The file
         * @param {string} [encoding] The file encoding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGbat10(generateVatPostings: boolean, file: any, encoding?: string, options: any = {}): FetchArgs {
            // verify required parameter 'generateVatPostings' is not null or undefined
            if (generateVatPostings === null || generateVatPostings === undefined) {
                throw new RequiredError('generateVatPostings','Required parameter generateVatPostings was null or undefined when calling importGbat10.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling importGbat10.');
            }
            const localVarPath = `/ledger/voucher/importGbat10`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (generateVatPostings !== undefined) {
                localVarFormParams.set('generateVatPostings', generateVatPostings as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            if (encoding !== undefined) {
                localVarFormParams.set('encoding', encoding as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find non-posted vouchers.
         * @param {boolean} includeNonApproved Include non-approved vouchers in the result.
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonPosted(includeNonApproved: boolean, dateFrom?: string, dateTo?: string, changedSince?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'includeNonApproved' is not null or undefined
            if (includeNonApproved === null || includeNonApproved === undefined) {
                throw new RequiredError('includeNonApproved','Required parameter includeNonApproved was null or undefined when calling nonPosted.');
            }
            const localVarPath = `/ledger/voucher/>nonPosted`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            if (includeNonApproved !== undefined) {
                localVarQueryParameter['includeNonApproved'] = includeNonApproved;
            }

            if (changedSince !== undefined) {
                localVarQueryParameter['changedSince'] = changedSince;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new voucher. IMPORTANT: Also creates postings. Only the gross amounts will be used
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(sendToLedger?: boolean, body?: Voucher, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/voucher`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (sendToLedger !== undefined) {
                localVarQueryParameter['sendToLedger'] = sendToLedger;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Voucher" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update voucher. Postings with guiRow==0 will be deleted and regenerated.
         * @param {number} id Element ID
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, sendToLedger?: boolean, body?: Voucher, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/ledger/voucher/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (sendToLedger !== undefined) {
                localVarQueryParameter['sendToLedger'] = sendToLedger;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Voucher" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find vouchers corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [typeId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, id?: string, number?: string, numberFrom?: number, numberTo?: number, typeId?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom','Required parameter dateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'dateTo' is not null or undefined
            if (dateTo === null || dateTo === undefined) {
                throw new RequiredError('dateTo','Required parameter dateTo was null or undefined when calling search.');
            }
            const localVarPath = `/ledger/voucher`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (numberFrom !== undefined) {
                localVarQueryParameter['numberFrom'] = numberFrom;
            }

            if (numberTo !== undefined) {
                localVarQueryParameter['numberTo'] = numberTo;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['typeId'] = typeId;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Send voucher to inbox.
         * @param {number} id ID of voucher that should be sent to inbox.
         * @param {number} [version] Version of voucher that should be sent to inbox.
         * @param {string} [comment] Description of why the voucher was rejected. This parameter is only used if the approval feature is enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToInbox(id: number, version?: number, comment?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendToInbox.');
            }
            const localVarPath = `/ledger/voucher/{id}/:sendToInbox`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Send voucher to ledger.
         * @param {number} id ID of voucher that should be sent to ledger.
         * @param {number} [version] Version of voucher that should be sent to ledger.
         * @param {number} [number] Voucher number to use. If omitted or 0 the system will assign the number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToLedger(id: number, version?: number, number?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendToLedger.');
            }
            const localVarPath = `/ledger/voucher/{id}/:sendToLedger`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload attachment to voucher. Send as multipart form.
         * @param {number} voucherId Voucher ID to upload PDF to.
         * @param {string} fileName File name to store the pdf under. Will not be the same as the filename on the file returned.
         * @param {any} file The file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPdf(voucherId: number, fileName: string, file: any, options: any = {}): FetchArgs {
            // verify required parameter 'voucherId' is not null or undefined
            if (voucherId === null || voucherId === undefined) {
                throw new RequiredError('voucherId','Required parameter voucherId was null or undefined when calling uploadPdf.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling uploadPdf.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadPdf.');
            }
            const localVarPath = `/ledger/voucher/{voucherId}/pdf/{fileName}`
                .replace(`{${"voucherId"}}`, encodeURIComponent(String(voucherId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgervoucherApi - functional programming interface
 * @export
 */
export const LedgervoucherApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get attachment by voucher ID.
         * @param {number} voucherId Voucher ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf(voucherId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = LedgervoucherApiFetchParamCreator(configuration).downloadPdf(voucherId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get voucher by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperVoucher> {
            const localVarFetchArgs = LedgervoucherApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Import GBAT10. Send as multipart form.
         * @param {boolean} generateVatPostings If the import should generate VAT postings
         * @param {any} file The file
         * @param {string} [encoding] The file encoding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGbat10(generateVatPostings: boolean, file: any, encoding?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LedgervoucherApiFetchParamCreator(configuration).importGbat10(generateVatPostings, file, encoding, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find non-posted vouchers.
         * @param {boolean} includeNonApproved Include non-approved vouchers in the result.
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonPosted(includeNonApproved: boolean, dateFrom?: string, dateTo?: string, changedSince?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseVoucher> {
            const localVarFetchArgs = LedgervoucherApiFetchParamCreator(configuration).nonPosted(includeNonApproved, dateFrom, dateTo, changedSince, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add new voucher. IMPORTANT: Also creates postings. Only the gross amounts will be used
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(sendToLedger?: boolean, body?: Voucher, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperVoucher> {
            const localVarFetchArgs = LedgervoucherApiFetchParamCreator(configuration).post(sendToLedger, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update voucher. Postings with guiRow==0 will be deleted and regenerated.
         * @param {number} id Element ID
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, sendToLedger?: boolean, body?: Voucher, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperVoucher> {
            const localVarFetchArgs = LedgervoucherApiFetchParamCreator(configuration).put(id, sendToLedger, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find vouchers corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [typeId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, id?: string, number?: string, numberFrom?: number, numberTo?: number, typeId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VoucherSearchResponse> {
            const localVarFetchArgs = LedgervoucherApiFetchParamCreator(configuration).search(dateFrom, dateTo, id, number, numberFrom, numberTo, typeId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Send voucher to inbox.
         * @param {number} id ID of voucher that should be sent to inbox.
         * @param {number} [version] Version of voucher that should be sent to inbox.
         * @param {string} [comment] Description of why the voucher was rejected. This parameter is only used if the approval feature is enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToInbox(id: number, version?: number, comment?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperVoucher> {
            const localVarFetchArgs = LedgervoucherApiFetchParamCreator(configuration).sendToInbox(id, version, comment, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Send voucher to ledger.
         * @param {number} id ID of voucher that should be sent to ledger.
         * @param {number} [version] Version of voucher that should be sent to ledger.
         * @param {number} [number] Voucher number to use. If omitted or 0 the system will assign the number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToLedger(id: number, version?: number, number?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperVoucher> {
            const localVarFetchArgs = LedgervoucherApiFetchParamCreator(configuration).sendToLedger(id, version, number, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload attachment to voucher. Send as multipart form.
         * @param {number} voucherId Voucher ID to upload PDF to.
         * @param {string} fileName File name to store the pdf under. Will not be the same as the filename on the file returned.
         * @param {any} file The file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPdf(voucherId: number, fileName: string, file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LedgervoucherApiFetchParamCreator(configuration).uploadPdf(voucherId, fileName, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LedgervoucherApi - factory interface
 * @export
 */
export const LedgervoucherApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get attachment by voucher ID.
         * @param {number} voucherId Voucher ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf(voucherId: number, options?: any) {
            return LedgervoucherApiFp(configuration).downloadPdf(voucherId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get voucher by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return LedgervoucherApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Import GBAT10. Send as multipart form.
         * @param {boolean} generateVatPostings If the import should generate VAT postings
         * @param {any} file The file
         * @param {string} [encoding] The file encoding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGbat10(generateVatPostings: boolean, file: any, encoding?: string, options?: any) {
            return LedgervoucherApiFp(configuration).importGbat10(generateVatPostings, file, encoding, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find non-posted vouchers.
         * @param {boolean} includeNonApproved Include non-approved vouchers in the result.
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonPosted(includeNonApproved: boolean, dateFrom?: string, dateTo?: string, changedSince?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return LedgervoucherApiFp(configuration).nonPosted(includeNonApproved, dateFrom, dateTo, changedSince, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add new voucher. IMPORTANT: Also creates postings. Only the gross amounts will be used
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(sendToLedger?: boolean, body?: Voucher, options?: any) {
            return LedgervoucherApiFp(configuration).post(sendToLedger, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update voucher. Postings with guiRow==0 will be deleted and regenerated.
         * @param {number} id Element ID
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, sendToLedger?: boolean, body?: Voucher, options?: any) {
            return LedgervoucherApiFp(configuration).put(id, sendToLedger, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find vouchers corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [typeId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, id?: string, number?: string, numberFrom?: number, numberTo?: number, typeId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return LedgervoucherApiFp(configuration).search(dateFrom, dateTo, id, number, numberFrom, numberTo, typeId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Send voucher to inbox.
         * @param {number} id ID of voucher that should be sent to inbox.
         * @param {number} [version] Version of voucher that should be sent to inbox.
         * @param {string} [comment] Description of why the voucher was rejected. This parameter is only used if the approval feature is enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToInbox(id: number, version?: number, comment?: string, options?: any) {
            return LedgervoucherApiFp(configuration).sendToInbox(id, version, comment, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Send voucher to ledger.
         * @param {number} id ID of voucher that should be sent to ledger.
         * @param {number} [version] Version of voucher that should be sent to ledger.
         * @param {number} [number] Voucher number to use. If omitted or 0 the system will assign the number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToLedger(id: number, version?: number, number?: number, options?: any) {
            return LedgervoucherApiFp(configuration).sendToLedger(id, version, number, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload attachment to voucher. Send as multipart form.
         * @param {number} voucherId Voucher ID to upload PDF to.
         * @param {string} fileName File name to store the pdf under. Will not be the same as the filename on the file returned.
         * @param {any} file The file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPdf(voucherId: number, fileName: string, file: any, options?: any) {
            return LedgervoucherApiFp(configuration).uploadPdf(voucherId, fileName, file, options)(fetch, basePath);
        },
    };
};

/**
 * LedgervoucherApi - object-oriented interface
 * @export
 * @class LedgervoucherApi
 * @extends {BaseAPI}
 */
export class LedgervoucherApi extends BaseAPI {
    /**
     * 
     * @summary Get attachment by voucher ID.
     * @param {} voucherId Voucher ID from which PDF is downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    public downloadPdf(voucherId: number, options?: any) {
        return LedgervoucherApiFp(this.configuration).downloadPdf(voucherId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get voucher by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    public get(id: number, fields?: string, options?: any) {
        return LedgervoucherApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Import GBAT10. Send as multipart form.
     * @param {} generateVatPostings If the import should generate VAT postings
     * @param {} file The file
     * @param {} [encoding] The file encoding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    public importGbat10(generateVatPostings: boolean, file: any, encoding?: string, options?: any) {
        return LedgervoucherApiFp(this.configuration).importGbat10(generateVatPostings, file, encoding, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find non-posted vouchers.
     * @param {} includeNonApproved Include non-approved vouchers in the result.
     * @param {} [dateFrom] From and including
     * @param {} [dateTo] To and excluding
     * @param {} [changedSince] Only return elements that have changed since this date and time
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    public nonPosted(includeNonApproved: boolean, dateFrom?: string, dateTo?: string, changedSince?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return LedgervoucherApiFp(this.configuration).nonPosted(includeNonApproved, dateFrom, dateTo, changedSince, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add new voucher. IMPORTANT: Also creates postings. Only the gross amounts will be used
     * @param {} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    public post(sendToLedger?: boolean, body?: Voucher, options?: any) {
        return LedgervoucherApiFp(this.configuration).post(sendToLedger, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update voucher. Postings with guiRow==0 will be deleted and regenerated.
     * @param {} id Element ID
     * @param {} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    public put(id: number, sendToLedger?: boolean, body?: Voucher, options?: any) {
        return LedgervoucherApiFp(this.configuration).put(id, sendToLedger, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find vouchers corresponding with sent data.
     * @param {} dateFrom From and including
     * @param {} dateTo To and excluding
     * @param {} [id] List of IDs
     * @param {} [number] List of IDs
     * @param {} [numberFrom] From and including
     * @param {} [numberTo] To and excluding
     * @param {} [typeId] List of IDs
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    public search(dateFrom: string, dateTo: string, id?: string, number?: string, numberFrom?: number, numberTo?: number, typeId?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return LedgervoucherApiFp(this.configuration).search(dateFrom, dateTo, id, number, numberFrom, numberTo, typeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Send voucher to inbox.
     * @param {} id ID of voucher that should be sent to inbox.
     * @param {} [version] Version of voucher that should be sent to inbox.
     * @param {} [comment] Description of why the voucher was rejected. This parameter is only used if the approval feature is enabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    public sendToInbox(id: number, version?: number, comment?: string, options?: any) {
        return LedgervoucherApiFp(this.configuration).sendToInbox(id, version, comment, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Send voucher to ledger.
     * @param {} id ID of voucher that should be sent to ledger.
     * @param {} [version] Version of voucher that should be sent to ledger.
     * @param {} [number] Voucher number to use. If omitted or 0 the system will assign the number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    public sendToLedger(id: number, version?: number, number?: number, options?: any) {
        return LedgervoucherApiFp(this.configuration).sendToLedger(id, version, number, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload attachment to voucher. Send as multipart form.
     * @param {} voucherId Voucher ID to upload PDF to.
     * @param {} fileName File name to store the pdf under. Will not be the same as the filename on the file returned.
     * @param {} file The file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    public uploadPdf(voucherId: number, fileName: string, file: any, options?: any) {
        return LedgervoucherApiFp(this.configuration).uploadPdf(voucherId, fileName, file, options)(this.fetch, this.basePath);
    }

}

/**
 * LedgervoucherTypeApi - fetch parameter creator
 * @export
 */
export const LedgervoucherTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get voucher type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/ledger/voucherType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find voucher types corresponding with sent data.
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(name?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/ledger/voucherType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgervoucherTypeApi - functional programming interface
 * @export
 */
export const LedgervoucherTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get voucher type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperVoucherType> {
            const localVarFetchArgs = LedgervoucherTypeApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find voucher types corresponding with sent data.
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(name?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseVoucherType> {
            const localVarFetchArgs = LedgervoucherTypeApiFetchParamCreator(configuration).search(name, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LedgervoucherTypeApi - factory interface
 * @export
 */
export const LedgervoucherTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get voucher type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return LedgervoucherTypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find voucher types corresponding with sent data.
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(name?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return LedgervoucherTypeApiFp(configuration).search(name, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * LedgervoucherTypeApi - object-oriented interface
 * @export
 * @class LedgervoucherTypeApi
 * @extends {BaseAPI}
 */
export class LedgervoucherTypeApi extends BaseAPI {
    /**
     * 
     * @summary Get voucher type by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherTypeApi
     */
    public get(id: number, fields?: string, options?: any) {
        return LedgervoucherTypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find voucher types corresponding with sent data.
     * @param {} [name] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherTypeApi
     */
    public search(name?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return LedgervoucherTypeApiFp(this.configuration).search(name, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * OrderApi - fetch parameter creator
 * @export
 */
export const OrderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get order by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/order/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new invoice from order.
         * @param {number} id ID of order to invoice.
         * @param {string} invoiceDate To and excluding
         * @param {boolean} [sendToCustomer] Send invoice to customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoice(id: number, invoiceDate: string, sendToCustomer?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoice.');
            }
            // verify required parameter 'invoiceDate' is not null or undefined
            if (invoiceDate === null || invoiceDate === undefined) {
                throw new RequiredError('invoiceDate','Required parameter invoiceDate was null or undefined when calling invoice.');
            }
            const localVarPath = `/order/{id}/:invoice`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (invoiceDate !== undefined) {
                localVarQueryParameter['invoiceDate'] = invoiceDate;
            }

            if (sendToCustomer !== undefined) {
                localVarQueryParameter['sendToCustomer'] = sendToCustomer;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create order.
         * @param {Order} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Order, options: any = {}): FetchArgs {
            const localVarPath = `/order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update order.
         * @param {number} id Element ID
         * @param {Order} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Order, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/order/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find orders corresponding with sent data.
         * @param {string} orderDateFrom From and including
         * @param {string} orderDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] Equals
         * @param {string} [customerId] List of IDs
         * @param {boolean} [isClosed] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(orderDateFrom: string, orderDateTo: string, id?: string, number?: string, customerId?: string, isClosed?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderDateFrom' is not null or undefined
            if (orderDateFrom === null || orderDateFrom === undefined) {
                throw new RequiredError('orderDateFrom','Required parameter orderDateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'orderDateTo' is not null or undefined
            if (orderDateTo === null || orderDateTo === undefined) {
                throw new RequiredError('orderDateTo','Required parameter orderDateTo was null or undefined when calling search.');
            }
            const localVarPath = `/order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (orderDateFrom !== undefined) {
                localVarQueryParameter['orderDateFrom'] = orderDateFrom;
            }

            if (orderDateTo !== undefined) {
                localVarQueryParameter['orderDateTo'] = orderDateTo;
            }

            if (isClosed !== undefined) {
                localVarQueryParameter['isClosed'] = isClosed;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get order by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new invoice from order.
         * @param {number} id ID of order to invoice.
         * @param {string} invoiceDate To and excluding
         * @param {boolean} [sendToCustomer] Send invoice to customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoice(id: number, invoiceDate: string, sendToCustomer?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperInvoice> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).invoice(id, invoiceDate, sendToCustomer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create order.
         * @param {Order} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Order, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update order.
         * @param {number} id Element ID
         * @param {Order} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Order, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find orders corresponding with sent data.
         * @param {string} orderDateFrom From and including
         * @param {string} orderDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] Equals
         * @param {string} [customerId] List of IDs
         * @param {boolean} [isClosed] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(orderDateFrom: string, orderDateTo: string, id?: string, number?: string, customerId?: string, isClosed?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).search(orderDateFrom, orderDateTo, id, number, customerId, isClosed, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get order by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return OrderApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new invoice from order.
         * @param {number} id ID of order to invoice.
         * @param {string} invoiceDate To and excluding
         * @param {boolean} [sendToCustomer] Send invoice to customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoice(id: number, invoiceDate: string, sendToCustomer?: boolean, options?: any) {
            return OrderApiFp(configuration).invoice(id, invoiceDate, sendToCustomer, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create order.
         * @param {Order} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Order, options?: any) {
            return OrderApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update order.
         * @param {number} id Element ID
         * @param {Order} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Order, options?: any) {
            return OrderApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find orders corresponding with sent data.
         * @param {string} orderDateFrom From and including
         * @param {string} orderDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] Equals
         * @param {string} [customerId] List of IDs
         * @param {boolean} [isClosed] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(orderDateFrom: string, orderDateTo: string, id?: string, number?: string, customerId?: string, isClosed?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return OrderApiFp(configuration).search(orderDateFrom, orderDateTo, id, number, customerId, isClosed, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * 
     * @summary Get order by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public get(id: number, fields?: string, options?: any) {
        return OrderApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new invoice from order.
     * @param {} id ID of order to invoice.
     * @param {} invoiceDate To and excluding
     * @param {} [sendToCustomer] Send invoice to customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public invoice(id: number, invoiceDate: string, sendToCustomer?: boolean, options?: any) {
        return OrderApiFp(this.configuration).invoice(id, invoiceDate, sendToCustomer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create order.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public post(body?: Order, options?: any) {
        return OrderApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update order.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public put(id: number, body?: Order, options?: any) {
        return OrderApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find orders corresponding with sent data.
     * @param {} orderDateFrom From and including
     * @param {} orderDateTo To and excluding
     * @param {} [id] List of IDs
     * @param {} [number] Equals
     * @param {} [customerId] List of IDs
     * @param {} [isClosed] Equals
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public search(orderDateFrom: string, orderDateTo: string, id?: string, number?: string, customerId?: string, isClosed?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return OrderApiFp(this.configuration).search(orderDateFrom, orderDateTo, id, number, customerId, isClosed, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * OrderorderlineApi - fetch parameter creator
 * @export
 */
export const OrderorderlineApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete order line by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/order/orderline/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order line by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/order/orderline/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create order line. When creating several order lines, use /list for better performance.
         * @param {OrderLine} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: OrderLine, options: any = {}): FetchArgs {
            const localVarPath = `/order/orderline`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderLine" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create multiple order lines.
         * @param {Array&lt;OrderLine&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<OrderLine>, options: any = {}): FetchArgs {
            const localVarPath = `/order/orderline/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;OrderLine&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderorderlineApi - functional programming interface
 * @export
 */
export const OrderorderlineApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete order line by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderorderlineApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get order line by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperOrderLine> {
            const localVarFetchArgs = OrderorderlineApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create order line. When creating several order lines, use /list for better performance.
         * @param {OrderLine} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: OrderLine, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperOrderLine> {
            const localVarFetchArgs = OrderorderlineApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create multiple order lines.
         * @param {Array&lt;OrderLine&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<OrderLine>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseOrderLine> {
            const localVarFetchArgs = OrderorderlineApiFetchParamCreator(configuration).postList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrderorderlineApi - factory interface
 * @export
 */
export const OrderorderlineApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete order line by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return OrderorderlineApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get order line by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return OrderorderlineApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create order line. When creating several order lines, use /list for better performance.
         * @param {OrderLine} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: OrderLine, options?: any) {
            return OrderorderlineApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create multiple order lines.
         * @param {Array&lt;OrderLine&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<OrderLine>, options?: any) {
            return OrderorderlineApiFp(configuration).postList(body, options)(fetch, basePath);
        },
    };
};

/**
 * OrderorderlineApi - object-oriented interface
 * @export
 * @class OrderorderlineApi
 * @extends {BaseAPI}
 */
export class OrderorderlineApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete order line by ID.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderorderlineApi
     */
    public _delete(id: number, options?: any) {
        return OrderorderlineApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get order line by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderorderlineApi
     */
    public get(id: number, fields?: string, options?: any) {
        return OrderorderlineApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create order line. When creating several order lines, use /list for better performance.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderorderlineApi
     */
    public post(body?: OrderLine, options?: any) {
        return OrderorderlineApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create multiple order lines.
     * @param {} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderorderlineApi
     */
    public postList(body?: Array<OrderLine>, options?: any) {
        return OrderorderlineApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProductApi - fetch parameter creator
 * @export
 */
export const ProductApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get product by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new product.
         * @param {Product} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Product, options: any = {}): FetchArgs {
            const localVarPath = `/product`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Product" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update product.
         * @param {number} id Element ID
         * @param {Product} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Product, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Product" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find products corresponding with sent data.
         * @param {string} [number] DEPRECATED. List of product numbers (Integer only)
         * @param {Array&lt;string&gt;} [productNumber] List of valid product numbers
         * @param {string} [name] Containing
         * @param {boolean} [isInactive] Equals
         * @param {boolean} [isStockItem] Equals
         * @param {string} [currencyId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [productUnitId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [accountId] Equals
         * @param {number} [costExcludingVatCurrencyFrom] From and including
         * @param {number} [costExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceExcludingVatCurrencyFrom] From and including
         * @param {number} [priceExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceIncludingVatCurrencyFrom] From and including
         * @param {number} [priceIncludingVatCurrencyTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(number?: string, productNumber?: Array<string>, name?: string, isInactive?: boolean, isStockItem?: boolean, currencyId?: string, vatTypeId?: string, productUnitId?: string, departmentId?: string, accountId?: string, costExcludingVatCurrencyFrom?: number, costExcludingVatCurrencyTo?: number, priceExcludingVatCurrencyFrom?: number, priceExcludingVatCurrencyTo?: number, priceIncludingVatCurrencyFrom?: number, priceIncludingVatCurrencyTo?: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/product`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (productNumber) {
                localVarQueryParameter['productNumber'] = productNumber;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (isInactive !== undefined) {
                localVarQueryParameter['isInactive'] = isInactive;
            }

            if (isStockItem !== undefined) {
                localVarQueryParameter['isStockItem'] = isStockItem;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (vatTypeId !== undefined) {
                localVarQueryParameter['vatTypeId'] = vatTypeId;
            }

            if (productUnitId !== undefined) {
                localVarQueryParameter['productUnitId'] = productUnitId;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (costExcludingVatCurrencyFrom !== undefined) {
                localVarQueryParameter['costExcludingVatCurrencyFrom'] = costExcludingVatCurrencyFrom;
            }

            if (costExcludingVatCurrencyTo !== undefined) {
                localVarQueryParameter['costExcludingVatCurrencyTo'] = costExcludingVatCurrencyTo;
            }

            if (priceExcludingVatCurrencyFrom !== undefined) {
                localVarQueryParameter['priceExcludingVatCurrencyFrom'] = priceExcludingVatCurrencyFrom;
            }

            if (priceExcludingVatCurrencyTo !== undefined) {
                localVarQueryParameter['priceExcludingVatCurrencyTo'] = priceExcludingVatCurrencyTo;
            }

            if (priceIncludingVatCurrencyFrom !== undefined) {
                localVarQueryParameter['priceIncludingVatCurrencyFrom'] = priceIncludingVatCurrencyFrom;
            }

            if (priceIncludingVatCurrencyTo !== undefined) {
                localVarQueryParameter['priceIncludingVatCurrencyTo'] = priceIncludingVatCurrencyTo;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get product by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperProduct> {
            const localVarFetchArgs = ProductApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new product.
         * @param {Product} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Product, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperProduct> {
            const localVarFetchArgs = ProductApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update product.
         * @param {number} id Element ID
         * @param {Product} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Product, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperProduct> {
            const localVarFetchArgs = ProductApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find products corresponding with sent data.
         * @param {string} [number] DEPRECATED. List of product numbers (Integer only)
         * @param {Array&lt;string&gt;} [productNumber] List of valid product numbers
         * @param {string} [name] Containing
         * @param {boolean} [isInactive] Equals
         * @param {boolean} [isStockItem] Equals
         * @param {string} [currencyId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [productUnitId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [accountId] Equals
         * @param {number} [costExcludingVatCurrencyFrom] From and including
         * @param {number} [costExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceExcludingVatCurrencyFrom] From and including
         * @param {number} [priceExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceIncludingVatCurrencyFrom] From and including
         * @param {number} [priceIncludingVatCurrencyTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(number?: string, productNumber?: Array<string>, name?: string, isInactive?: boolean, isStockItem?: boolean, currencyId?: string, vatTypeId?: string, productUnitId?: string, departmentId?: string, accountId?: string, costExcludingVatCurrencyFrom?: number, costExcludingVatCurrencyTo?: number, priceExcludingVatCurrencyFrom?: number, priceExcludingVatCurrencyTo?: number, priceIncludingVatCurrencyFrom?: number, priceIncludingVatCurrencyTo?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseProduct> {
            const localVarFetchArgs = ProductApiFetchParamCreator(configuration).search(number, productNumber, name, isInactive, isStockItem, currencyId, vatTypeId, productUnitId, departmentId, accountId, costExcludingVatCurrencyFrom, costExcludingVatCurrencyTo, priceExcludingVatCurrencyFrom, priceExcludingVatCurrencyTo, priceIncludingVatCurrencyFrom, priceIncludingVatCurrencyTo, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get product by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return ProductApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new product.
         * @param {Product} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Product, options?: any) {
            return ProductApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update product.
         * @param {number} id Element ID
         * @param {Product} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Product, options?: any) {
            return ProductApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find products corresponding with sent data.
         * @param {string} [number] DEPRECATED. List of product numbers (Integer only)
         * @param {Array&lt;string&gt;} [productNumber] List of valid product numbers
         * @param {string} [name] Containing
         * @param {boolean} [isInactive] Equals
         * @param {boolean} [isStockItem] Equals
         * @param {string} [currencyId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [productUnitId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [accountId] Equals
         * @param {number} [costExcludingVatCurrencyFrom] From and including
         * @param {number} [costExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceExcludingVatCurrencyFrom] From and including
         * @param {number} [priceExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceIncludingVatCurrencyFrom] From and including
         * @param {number} [priceIncludingVatCurrencyTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(number?: string, productNumber?: Array<string>, name?: string, isInactive?: boolean, isStockItem?: boolean, currencyId?: string, vatTypeId?: string, productUnitId?: string, departmentId?: string, accountId?: string, costExcludingVatCurrencyFrom?: number, costExcludingVatCurrencyTo?: number, priceExcludingVatCurrencyFrom?: number, priceExcludingVatCurrencyTo?: number, priceIncludingVatCurrencyFrom?: number, priceIncludingVatCurrencyTo?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return ProductApiFp(configuration).search(number, productNumber, name, isInactive, isStockItem, currencyId, vatTypeId, productUnitId, departmentId, accountId, costExcludingVatCurrencyFrom, costExcludingVatCurrencyTo, priceExcludingVatCurrencyFrom, priceExcludingVatCurrencyTo, priceIncludingVatCurrencyFrom, priceIncludingVatCurrencyTo, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @summary Get product by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public get(id: number, fields?: string, options?: any) {
        return ProductApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new product.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public post(body?: Product, options?: any) {
        return ProductApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update product.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public put(id: number, body?: Product, options?: any) {
        return ProductApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find products corresponding with sent data.
     * @param {} [number] DEPRECATED. List of product numbers (Integer only)
     * @param {} [productNumber] List of valid product numbers
     * @param {} [name] Containing
     * @param {} [isInactive] Equals
     * @param {} [isStockItem] Equals
     * @param {} [currencyId] Equals
     * @param {} [vatTypeId] Equals
     * @param {} [productUnitId] Equals
     * @param {} [departmentId] Equals
     * @param {} [accountId] Equals
     * @param {} [costExcludingVatCurrencyFrom] From and including
     * @param {} [costExcludingVatCurrencyTo] To and excluding
     * @param {} [priceExcludingVatCurrencyFrom] From and including
     * @param {} [priceExcludingVatCurrencyTo] To and excluding
     * @param {} [priceIncludingVatCurrencyFrom] From and including
     * @param {} [priceIncludingVatCurrencyTo] To and excluding
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public search(number?: string, productNumber?: Array<string>, name?: string, isInactive?: boolean, isStockItem?: boolean, currencyId?: string, vatTypeId?: string, productUnitId?: string, departmentId?: string, accountId?: string, costExcludingVatCurrencyFrom?: number, costExcludingVatCurrencyTo?: number, priceExcludingVatCurrencyFrom?: number, priceExcludingVatCurrencyTo?: number, priceIncludingVatCurrencyFrom?: number, priceIncludingVatCurrencyTo?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return ProductApiFp(this.configuration).search(number, productNumber, name, isInactive, isStockItem, currencyId, vatTypeId, productUnitId, departmentId, accountId, costExcludingVatCurrencyFrom, costExcludingVatCurrencyTo, priceExcludingVatCurrencyFrom, priceExcludingVatCurrencyTo, priceIncludingVatCurrencyFrom, priceIncludingVatCurrencyTo, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * ProductunitApi - fetch parameter creator
 * @export
 */
export const ProductunitApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get product unit by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/product/unit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find product units corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Names
         * @param {string} [nameShort] Short names
         * @param {string} [commonCode] Common codes
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, nameShort?: string, commonCode?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/product/unit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameShort !== undefined) {
                localVarQueryParameter['nameShort'] = nameShort;
            }

            if (commonCode !== undefined) {
                localVarQueryParameter['commonCode'] = commonCode;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductunitApi - functional programming interface
 * @export
 */
export const ProductunitApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get product unit by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperProductUnit> {
            const localVarFetchArgs = ProductunitApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find product units corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Names
         * @param {string} [nameShort] Short names
         * @param {string} [commonCode] Common codes
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, nameShort?: string, commonCode?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseProductUnit> {
            const localVarFetchArgs = ProductunitApiFetchParamCreator(configuration).search(id, name, nameShort, commonCode, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductunitApi - factory interface
 * @export
 */
export const ProductunitApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get product unit by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return ProductunitApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find product units corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Names
         * @param {string} [nameShort] Short names
         * @param {string} [commonCode] Common codes
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, nameShort?: string, commonCode?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return ProductunitApiFp(configuration).search(id, name, nameShort, commonCode, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * ProductunitApi - object-oriented interface
 * @export
 * @class ProductunitApi
 * @extends {BaseAPI}
 */
export class ProductunitApi extends BaseAPI {
    /**
     * 
     * @summary Get product unit by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductunitApi
     */
    public get(id: number, fields?: string, options?: any) {
        return ProductunitApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find product units corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [name] Names
     * @param {} [nameShort] Short names
     * @param {} [commonCode] Common codes
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductunitApi
     */
    public search(id?: string, name?: string, nameShort?: string, commonCode?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return ProductunitApiFp(this.configuration).search(id, name, nameShort, commonCode, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectApi - fetch parameter creator
 * @export
 */
export const ProjectApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete projects.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteByIds.');
            }
            const localVarPath = `/project/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find project by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/project/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find projects applicable for time sheet registration on a specific day.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet(employeeId?: number, date?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/project/>forTimeSheet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Add new project.
         * @param {Project} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Project, options: any = {}): FetchArgs {
            const localVarPath = `/project`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Register new projects. Multiple projects for different users can be sent in the same request.
         * @param {Array&lt;Project&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Project>, options: any = {}): FetchArgs {
            const localVarPath = `/project/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Project&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update project.
         * @param {number} id Element ID
         * @param {Project} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Project, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/project/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find projects corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {boolean} [isOffer] Equals
         * @param {string} [projectManagerId] List of IDs
         * @param {string} [employeeInProjectId] List of IDs
         * @param {string} [departmentId] List of IDs
         * @param {string} [startDateFrom] From and including
         * @param {string} [startDateTo] To and excluding
         * @param {string} [endDateFrom] From and including
         * @param {string} [endDateTo] To and excluding
         * @param {boolean} [isClosed] Equals
         * @param {string} [customerId] Equals
         * @param {string} [externalAccountsNumber] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, isOffer?: boolean, projectManagerId?: string, employeeInProjectId?: string, departmentId?: string, startDateFrom?: string, startDateTo?: string, endDateFrom?: string, endDateTo?: string, isClosed?: boolean, customerId?: string, externalAccountsNumber?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/project`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (isOffer !== undefined) {
                localVarQueryParameter['isOffer'] = isOffer;
            }

            if (projectManagerId !== undefined) {
                localVarQueryParameter['projectManagerId'] = projectManagerId;
            }

            if (employeeInProjectId !== undefined) {
                localVarQueryParameter['employeeInProjectId'] = employeeInProjectId;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }

            if (startDateFrom !== undefined) {
                localVarQueryParameter['startDateFrom'] = startDateFrom;
            }

            if (startDateTo !== undefined) {
                localVarQueryParameter['startDateTo'] = startDateTo;
            }

            if (endDateFrom !== undefined) {
                localVarQueryParameter['endDateFrom'] = endDateFrom;
            }

            if (endDateTo !== undefined) {
                localVarQueryParameter['endDateTo'] = endDateTo;
            }

            if (isClosed !== undefined) {
                localVarQueryParameter['isClosed'] = isClosed;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (externalAccountsNumber !== undefined) {
                localVarQueryParameter['externalAccountsNumber'] = externalAccountsNumber;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete projects.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).deleteByIds(ids, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find project by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperProject> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find projects applicable for time sheet registration on a specific day.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet(employeeId?: number, date?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseProject> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).getForTimeSheet(employeeId, date, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Add new project.
         * @param {Project} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperProject> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Register new projects. Multiple projects for different users can be sent in the same request.
         * @param {Array&lt;Project&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Project>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseProject> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).postList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update project.
         * @param {number} id Element ID
         * @param {Project} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperProject> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find projects corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {boolean} [isOffer] Equals
         * @param {string} [projectManagerId] List of IDs
         * @param {string} [employeeInProjectId] List of IDs
         * @param {string} [departmentId] List of IDs
         * @param {string} [startDateFrom] From and including
         * @param {string} [startDateTo] To and excluding
         * @param {string} [endDateFrom] From and including
         * @param {string} [endDateTo] To and excluding
         * @param {boolean} [isClosed] Equals
         * @param {string} [customerId] Equals
         * @param {string} [externalAccountsNumber] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, isOffer?: boolean, projectManagerId?: string, employeeInProjectId?: string, departmentId?: string, startDateFrom?: string, startDateTo?: string, endDateFrom?: string, endDateTo?: string, isClosed?: boolean, customerId?: string, externalAccountsNumber?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseProject> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).search(id, name, number, isOffer, projectManagerId, employeeInProjectId, departmentId, startDateFrom, startDateTo, endDateFrom, endDateTo, isClosed, customerId, externalAccountsNumber, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete projects.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds(ids: string, options?: any) {
            return ProjectApiFp(configuration).deleteByIds(ids, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find project by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return ProjectApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find projects applicable for time sheet registration on a specific day.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet(employeeId?: number, date?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return ProjectApiFp(configuration).getForTimeSheet(employeeId, date, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Add new project.
         * @param {Project} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Project, options?: any) {
            return ProjectApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Register new projects. Multiple projects for different users can be sent in the same request.
         * @param {Array&lt;Project&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Project>, options?: any) {
            return ProjectApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update project.
         * @param {number} id Element ID
         * @param {Project} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Project, options?: any) {
            return ProjectApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find projects corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {boolean} [isOffer] Equals
         * @param {string} [projectManagerId] List of IDs
         * @param {string} [employeeInProjectId] List of IDs
         * @param {string} [departmentId] List of IDs
         * @param {string} [startDateFrom] From and including
         * @param {string} [startDateTo] To and excluding
         * @param {string} [endDateFrom] From and including
         * @param {string} [endDateTo] To and excluding
         * @param {boolean} [isClosed] Equals
         * @param {string} [customerId] Equals
         * @param {string} [externalAccountsNumber] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, isOffer?: boolean, projectManagerId?: string, employeeInProjectId?: string, departmentId?: string, startDateFrom?: string, startDateTo?: string, endDateFrom?: string, endDateTo?: string, isClosed?: boolean, customerId?: string, externalAccountsNumber?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return ProjectApiFp(configuration).search(id, name, number, isOffer, projectManagerId, employeeInProjectId, departmentId, startDateFrom, startDateTo, endDateFrom, endDateTo, isClosed, customerId, externalAccountsNumber, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete projects.
     * @param {} ids ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public deleteByIds(ids: string, options?: any) {
        return ProjectApiFp(this.configuration).deleteByIds(ids, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find project by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public get(id: number, fields?: string, options?: any) {
        return ProjectApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find projects applicable for time sheet registration on a specific day.
     * @param {} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {} [date] yyyy-MM-dd. Defaults to today.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getForTimeSheet(employeeId?: number, date?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return ProjectApiFp(this.configuration).getForTimeSheet(employeeId, date, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Add new project.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public post(body?: Project, options?: any) {
        return ProjectApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Register new projects. Multiple projects for different users can be sent in the same request.
     * @param {} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public postList(body?: Array<Project>, options?: any) {
        return ProjectApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update project.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public put(id: number, body?: Project, options?: any) {
        return ProjectApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find projects corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [name] Containing
     * @param {} [number] Equals
     * @param {} [isOffer] Equals
     * @param {} [projectManagerId] List of IDs
     * @param {} [employeeInProjectId] List of IDs
     * @param {} [departmentId] List of IDs
     * @param {} [startDateFrom] From and including
     * @param {} [startDateTo] To and excluding
     * @param {} [endDateFrom] From and including
     * @param {} [endDateTo] To and excluding
     * @param {} [isClosed] Equals
     * @param {} [customerId] Equals
     * @param {} [externalAccountsNumber] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public search(id?: string, name?: string, number?: string, isOffer?: boolean, projectManagerId?: string, employeeInProjectId?: string, departmentId?: string, startDateFrom?: string, startDateTo?: string, endDateFrom?: string, endDateTo?: string, isClosed?: boolean, customerId?: string, externalAccountsNumber?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return ProjectApiFp(this.configuration).search(id, name, number, isOffer, projectManagerId, employeeInProjectId, departmentId, startDateFrom, startDateTo, endDateFrom, endDateTo, isClosed, customerId, externalAccountsNumber, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectcategoryApi - fetch parameter creator
 * @export
 */
export const ProjectcategoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find project category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/project/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new project category.
         * @param {ProjectCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: ProjectCategory, options: any = {}): FetchArgs {
            const localVarPath = `/project/category`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectCategory" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project category.
         * @param {number} id Element ID
         * @param {ProjectCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: ProjectCategory, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/project/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectCategory" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find project categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/project/category`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectcategoryApi - functional programming interface
 * @export
 */
export const ProjectcategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find project category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperProjectCategory> {
            const localVarFetchArgs = ProjectcategoryApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add new project category.
         * @param {ProjectCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: ProjectCategory, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperProjectCategory> {
            const localVarFetchArgs = ProjectcategoryApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update project category.
         * @param {number} id Element ID
         * @param {ProjectCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: ProjectCategory, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperProjectCategory> {
            const localVarFetchArgs = ProjectcategoryApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find project categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseProjectCategory> {
            const localVarFetchArgs = ProjectcategoryApiFetchParamCreator(configuration).search(id, name, number, description, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectcategoryApi - factory interface
 * @export
 */
export const ProjectcategoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Find project category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return ProjectcategoryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add new project category.
         * @param {ProjectCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: ProjectCategory, options?: any) {
            return ProjectcategoryApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update project category.
         * @param {number} id Element ID
         * @param {ProjectCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: ProjectCategory, options?: any) {
            return ProjectcategoryApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find project categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, name?: string, number?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return ProjectcategoryApiFp(configuration).search(id, name, number, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectcategoryApi - object-oriented interface
 * @export
 * @class ProjectcategoryApi
 * @extends {BaseAPI}
 */
export class ProjectcategoryApi extends BaseAPI {
    /**
     * 
     * @summary Find project category by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectcategoryApi
     */
    public get(id: number, fields?: string, options?: any) {
        return ProjectcategoryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add new project category.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectcategoryApi
     */
    public post(body?: ProjectCategory, options?: any) {
        return ProjectcategoryApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update project category.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectcategoryApi
     */
    public put(id: number, body?: ProjectCategory, options?: any) {
        return ProjectcategoryApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find project categories corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [name] Containing
     * @param {} [number] Equals
     * @param {} [description] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectcategoryApi
     */
    public search(id?: string, name?: string, number?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return ProjectcategoryApiFp(this.configuration).search(id, name, number, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * SalarypayslipApi - fetch parameter creator
 * @export
 */
export const SalarypayslipApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find payslip (PDF document) by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadPdf.');
            }
            const localVarPath = `/salary/payslip/{id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find payslip by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/salary/payslip/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find payslips corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [wageTransactionId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [monthFrom] From and including
         * @param {number} [monthTo] To and excluding
         * @param {string} [voucherDateFrom] From and including
         * @param {string} [voucherDateTo] To and excluding
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, employeeId?: string, wageTransactionId?: string, activityId?: string, yearFrom?: number, yearTo?: number, monthFrom?: number, monthTo?: number, voucherDateFrom?: string, voucherDateTo?: string, comment?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/salary/payslip`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (wageTransactionId !== undefined) {
                localVarQueryParameter['wageTransactionId'] = wageTransactionId;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (yearFrom !== undefined) {
                localVarQueryParameter['yearFrom'] = yearFrom;
            }

            if (yearTo !== undefined) {
                localVarQueryParameter['yearTo'] = yearTo;
            }

            if (monthFrom !== undefined) {
                localVarQueryParameter['monthFrom'] = monthFrom;
            }

            if (monthTo !== undefined) {
                localVarQueryParameter['monthTo'] = monthTo;
            }

            if (voucherDateFrom !== undefined) {
                localVarQueryParameter['voucherDateFrom'] = voucherDateFrom;
            }

            if (voucherDateTo !== undefined) {
                localVarQueryParameter['voucherDateTo'] = voucherDateTo;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalarypayslipApi - functional programming interface
 * @export
 */
export const SalarypayslipApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find payslip (PDF document) by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SalarypayslipApiFetchParamCreator(configuration).downloadPdf(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find payslip by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPayslip> {
            const localVarFetchArgs = SalarypayslipApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find payslips corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [wageTransactionId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [monthFrom] From and including
         * @param {number} [monthTo] To and excluding
         * @param {string} [voucherDateFrom] From and including
         * @param {string} [voucherDateTo] To and excluding
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, employeeId?: string, wageTransactionId?: string, activityId?: string, yearFrom?: number, yearTo?: number, monthFrom?: number, monthTo?: number, voucherDateFrom?: string, voucherDateTo?: string, comment?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponsePayslip> {
            const localVarFetchArgs = SalarypayslipApiFetchParamCreator(configuration).search(id, employeeId, wageTransactionId, activityId, yearFrom, yearTo, monthFrom, monthTo, voucherDateFrom, voucherDateTo, comment, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalarypayslipApi - factory interface
 * @export
 */
export const SalarypayslipApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find payslip (PDF document) by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf(id: number, options?: any) {
            return SalarypayslipApiFp(configuration).downloadPdf(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find payslip by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return SalarypayslipApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find payslips corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [wageTransactionId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [monthFrom] From and including
         * @param {number} [monthTo] To and excluding
         * @param {string} [voucherDateFrom] From and including
         * @param {string} [voucherDateTo] To and excluding
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, employeeId?: string, wageTransactionId?: string, activityId?: string, yearFrom?: number, yearTo?: number, monthFrom?: number, monthTo?: number, voucherDateFrom?: string, voucherDateTo?: string, comment?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return SalarypayslipApiFp(configuration).search(id, employeeId, wageTransactionId, activityId, yearFrom, yearTo, monthFrom, monthTo, voucherDateFrom, voucherDateTo, comment, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * SalarypayslipApi - object-oriented interface
 * @export
 * @class SalarypayslipApi
 * @extends {BaseAPI}
 */
export class SalarypayslipApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find payslip (PDF document) by ID.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarypayslipApi
     */
    public downloadPdf(id: number, options?: any) {
        return SalarypayslipApiFp(this.configuration).downloadPdf(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find payslip by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarypayslipApi
     */
    public get(id: number, fields?: string, options?: any) {
        return SalarypayslipApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find payslips corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [employeeId] List of IDs
     * @param {} [wageTransactionId] List of IDs
     * @param {} [activityId] List of IDs
     * @param {} [yearFrom] From and including
     * @param {} [yearTo] To and excluding
     * @param {} [monthFrom] From and including
     * @param {} [monthTo] To and excluding
     * @param {} [voucherDateFrom] From and including
     * @param {} [voucherDateTo] To and excluding
     * @param {} [comment] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarypayslipApi
     */
    public search(id?: string, employeeId?: string, wageTransactionId?: string, activityId?: string, yearFrom?: number, yearTo?: number, monthFrom?: number, monthTo?: number, voucherDateFrom?: string, voucherDateTo?: string, comment?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return SalarypayslipApiFp(this.configuration).search(id, employeeId, wageTransactionId, activityId, yearFrom, yearTo, monthFrom, monthTo, voucherDateFrom, voucherDateTo, comment, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * SalarytransactionApi - fetch parameter creator
 * @export
 */
export const SalarytransactionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete salary transaction by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/salary/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find salary transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/salary/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create a new salary transaction.
         * @param {SalaryTransaction} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: SalaryTransaction, options: any = {}): FetchArgs {
            const localVarPath = `/salary/transaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalarytransactionApi - functional programming interface
 * @export
 */
export const SalarytransactionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete salary transaction by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SalarytransactionApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find salary transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperSalaryTransaction> {
            const localVarFetchArgs = SalarytransactionApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create a new salary transaction.
         * @param {SalaryTransaction} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: SalaryTransaction, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperSalaryTransaction> {
            const localVarFetchArgs = SalarytransactionApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalarytransactionApi - factory interface
 * @export
 */
export const SalarytransactionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete salary transaction by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return SalarytransactionApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find salary transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return SalarytransactionApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create a new salary transaction.
         * @param {SalaryTransaction} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: SalaryTransaction, options?: any) {
            return SalarytransactionApiFp(configuration).post(body, options)(fetch, basePath);
        },
    };
};

/**
 * SalarytransactionApi - object-oriented interface
 * @export
 * @class SalarytransactionApi
 * @extends {BaseAPI}
 */
export class SalarytransactionApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete salary transaction by ID.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarytransactionApi
     */
    public _delete(id: number, options?: any) {
        return SalarytransactionApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find salary transaction by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarytransactionApi
     */
    public get(id: number, fields?: string, options?: any) {
        return SalarytransactionApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create a new salary transaction.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarytransactionApi
     */
    public post(body?: SalaryTransaction, options?: any) {
        return SalarytransactionApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

}

/**
 * SalarytypeApi - fetch parameter creator
 * @export
 */
export const SalarytypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find salary type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/salary/type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find salary type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] Containing
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, number?: string, name?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/salary/type`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalarytypeApi - functional programming interface
 * @export
 */
export const SalarytypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Find salary type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperSalaryType> {
            const localVarFetchArgs = SalarytypeApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find salary type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] Containing
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, number?: string, name?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseSalaryType> {
            const localVarFetchArgs = SalarytypeApiFetchParamCreator(configuration).search(id, number, name, description, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalarytypeApi - factory interface
 * @export
 */
export const SalarytypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Find salary type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return SalarytypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find salary type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] Containing
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, number?: string, name?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return SalarytypeApiFp(configuration).search(id, number, name, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * SalarytypeApi - object-oriented interface
 * @export
 * @class SalarytypeApi
 * @extends {BaseAPI}
 */
export class SalarytypeApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Find salary type by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarytypeApi
     */
    public get(id: number, fields?: string, options?: any) {
        return SalarytypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find salary type corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [number] Containing
     * @param {} [name] Containing
     * @param {} [description] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarytypeApi
     */
    public search(id?: string, number?: string, name?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return SalarytypeApiFp(this.configuration).search(id, number, name, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * SupplierApi - fetch parameter creator
 * @export
 */
export const SupplierApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get supplier by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/supplier/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create supplier. Related supplier addresses may also be created.
         * @param {Supplier} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Supplier, options: any = {}): FetchArgs {
            const localVarPath = `/supplier`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Supplier" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create multiple suppliers. Related supplier addresses may also be created.
         * @param {Array&lt;Supplier&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Supplier>, options: any = {}): FetchArgs {
            const localVarPath = `/supplier/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Supplier&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update supplier. 
         * @param {number} id Element ID
         * @param {Supplier} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Supplier, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/supplier/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Supplier" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update multiple suppliers. Addresses can also be updated.
         * @param {Array&lt;Supplier&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<Supplier>, options: any = {}): FetchArgs {
            const localVarPath = `/supplier/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Supplier&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find suppliers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [supplierNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, supplierNumber?: string, email?: string, invoiceEmail?: string, isInactive?: boolean, accountManagerId?: string, changedSince?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/supplier`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (supplierNumber !== undefined) {
                localVarQueryParameter['supplierNumber'] = supplierNumber;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (invoiceEmail !== undefined) {
                localVarQueryParameter['invoiceEmail'] = invoiceEmail;
            }

            if (isInactive !== undefined) {
                localVarQueryParameter['isInactive'] = isInactive;
            }

            if (accountManagerId !== undefined) {
                localVarQueryParameter['accountManagerId'] = accountManagerId;
            }

            if (changedSince !== undefined) {
                localVarQueryParameter['changedSince'] = changedSince;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupplierApi - functional programming interface
 * @export
 */
export const SupplierApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get supplier by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperSupplier> {
            const localVarFetchArgs = SupplierApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create supplier. Related supplier addresses may also be created.
         * @param {Supplier} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Supplier, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperSupplier> {
            const localVarFetchArgs = SupplierApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create multiple suppliers. Related supplier addresses may also be created.
         * @param {Array&lt;Supplier&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Supplier>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseSupplier> {
            const localVarFetchArgs = SupplierApiFetchParamCreator(configuration).postList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update supplier. 
         * @param {number} id Element ID
         * @param {Supplier} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Supplier, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperSupplier> {
            const localVarFetchArgs = SupplierApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update multiple suppliers. Addresses can also be updated.
         * @param {Array&lt;Supplier&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<Supplier>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseSupplier> {
            const localVarFetchArgs = SupplierApiFetchParamCreator(configuration).putList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find suppliers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [supplierNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, supplierNumber?: string, email?: string, invoiceEmail?: string, isInactive?: boolean, accountManagerId?: string, changedSince?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseSupplier> {
            const localVarFetchArgs = SupplierApiFetchParamCreator(configuration).search(id, supplierNumber, email, invoiceEmail, isInactive, accountManagerId, changedSince, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SupplierApi - factory interface
 * @export
 */
export const SupplierApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get supplier by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return SupplierApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create supplier. Related supplier addresses may also be created.
         * @param {Supplier} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Supplier, options?: any) {
            return SupplierApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create multiple suppliers. Related supplier addresses may also be created.
         * @param {Array&lt;Supplier&gt;} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<Supplier>, options?: any) {
            return SupplierApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update supplier. 
         * @param {number} id Element ID
         * @param {Supplier} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Supplier, options?: any) {
            return SupplierApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update multiple suppliers. Addresses can also be updated.
         * @param {Array&lt;Supplier&gt;} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<Supplier>, options?: any) {
            return SupplierApiFp(configuration).putList(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find suppliers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [supplierNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, supplierNumber?: string, email?: string, invoiceEmail?: string, isInactive?: boolean, accountManagerId?: string, changedSince?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return SupplierApiFp(configuration).search(id, supplierNumber, email, invoiceEmail, isInactive, accountManagerId, changedSince, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * SupplierApi - object-oriented interface
 * @export
 * @class SupplierApi
 * @extends {BaseAPI}
 */
export class SupplierApi extends BaseAPI {
    /**
     * 
     * @summary Get supplier by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    public get(id: number, fields?: string, options?: any) {
        return SupplierApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create supplier. Related supplier addresses may also be created.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    public post(body?: Supplier, options?: any) {
        return SupplierApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create multiple suppliers. Related supplier addresses may also be created.
     * @param {} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    public postList(body?: Array<Supplier>, options?: any) {
        return SupplierApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update supplier. 
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    public put(id: number, body?: Supplier, options?: any) {
        return SupplierApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update multiple suppliers. Addresses can also be updated.
     * @param {} [body] JSON representing updates to object. Should have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    public putList(body?: Array<Supplier>, options?: any) {
        return SupplierApiFp(this.configuration).putList(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find suppliers corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [supplierNumber] List of IDs
     * @param {} [email] Equals
     * @param {} [invoiceEmail] Equals
     * @param {} [isInactive] Equals
     * @param {} [accountManagerId] List of IDs
     * @param {} [changedSince] Only return elements that have changed since this date and time
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    public search(id?: string, supplierNumber?: string, email?: string, invoiceEmail?: string, isInactive?: boolean, accountManagerId?: string, changedSince?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return SupplierApiFp(this.configuration).search(id, supplierNumber, email, invoiceEmail, isInactive, accountManagerId, changedSince, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TimesheetentryApi - fetch parameter creator
 * @export
 */
export const TimesheetentryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete timesheet entry by ID.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, version?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/timesheet/entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find timesheet entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/timesheet/entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find recently used timesheet activities.
         * @param {number} projectId ID of project to find activities for
         * @param {number} [employeeId] ID of employee to find activities for. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivities(projectId: number, employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling getRecentActivities.');
            }
            const localVarPath = `/timesheet/entry/>recentActivities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find projects with recent activities (timesheet entry registered).
         * @param {number} [employeeId] ID of employee with recent project hours Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProjects(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/timesheet/entry/>recentProjects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find total hours registered on an employee in a specific period.
         * @param {number} [employeeId] ID of employee to find hours for. Defaults to ID of token owner.
         * @param {string} [startDate] Format is yyyy-MM-dd (from and incl.). Defaults to today.
         * @param {string} [endDate] Format is yyyy-MM-dd (to and excl.). Defaults to tomorrow.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalHours(employeeId?: number, startDate?: string, endDate?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/timesheet/entry/>totalHours`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new timesheet entry. Only one entry per employee/date/activity/project combination is supported.
         * @param {TimesheetEntry} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: TimesheetEntry, options: any = {}): FetchArgs {
            const localVarPath = `/timesheet/entry`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TimesheetEntry" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new timesheet entry. Multiple objects for several users can be sent in the same request.
         * @param {Array&lt;TimesheetEntry&gt;} [body] List of timesheet entry objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<TimesheetEntry>, options: any = {}): FetchArgs {
            const localVarPath = `/timesheet/entry/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;TimesheetEntry&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update timesheet entry by ID. Note: Timesheet entry object fields which are present but not set, or set to 0, will be nulled.
         * @param {number} id Element ID
         * @param {TimesheetEntry} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: TimesheetEntry, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/timesheet/entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TimesheetEntry" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update timesheet entry. Multiple objects for different users can be sent in the same request.
         * @param {Array&lt;TimesheetEntry&gt;} [body] List of timesheet entry objects to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<TimesheetEntry>, options: any = {}): FetchArgs {
            const localVarPath = `/timesheet/entry/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;TimesheetEntry&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find timesheet entry corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, id?: string, employeeId?: string, projectId?: string, activityId?: string, comment?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom','Required parameter dateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'dateTo' is not null or undefined
            if (dateTo === null || dateTo === undefined) {
                throw new RequiredError('dateTo','Required parameter dateTo was null or undefined when calling search.');
            }
            const localVarPath = `/timesheet/entry`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimesheetentryApi - functional programming interface
 * @export
 */
export const TimesheetentryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete timesheet entry by ID.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, version?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TimesheetentryApiFetchParamCreator(configuration)._delete(id, version, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find timesheet entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTimesheetEntry> {
            const localVarFetchArgs = TimesheetentryApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find recently used timesheet activities.
         * @param {number} projectId ID of project to find activities for
         * @param {number} [employeeId] ID of employee to find activities for. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivities(projectId: number, employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseActivity> {
            const localVarFetchArgs = TimesheetentryApiFetchParamCreator(configuration).getRecentActivities(projectId, employeeId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find projects with recent activities (timesheet entry registered).
         * @param {number} [employeeId] ID of employee with recent project hours Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProjects(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseProject> {
            const localVarFetchArgs = TimesheetentryApiFetchParamCreator(configuration).getRecentProjects(employeeId, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find total hours registered on an employee in a specific period.
         * @param {number} [employeeId] ID of employee to find hours for. Defaults to ID of token owner.
         * @param {string} [startDate] Format is yyyy-MM-dd (from and incl.). Defaults to today.
         * @param {string} [endDate] Format is yyyy-MM-dd (to and excl.). Defaults to tomorrow.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalHours(employeeId?: number, startDate?: string, endDate?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperDouble> {
            const localVarFetchArgs = TimesheetentryApiFetchParamCreator(configuration).getTotalHours(employeeId, startDate, endDate, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add new timesheet entry. Only one entry per employee/date/activity/project combination is supported.
         * @param {TimesheetEntry} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: TimesheetEntry, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTimesheetEntry> {
            const localVarFetchArgs = TimesheetentryApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add new timesheet entry. Multiple objects for several users can be sent in the same request.
         * @param {Array&lt;TimesheetEntry&gt;} [body] List of timesheet entry objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<TimesheetEntry>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTimesheetEntry> {
            const localVarFetchArgs = TimesheetentryApiFetchParamCreator(configuration).postList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update timesheet entry by ID. Note: Timesheet entry object fields which are present but not set, or set to 0, will be nulled.
         * @param {number} id Element ID
         * @param {TimesheetEntry} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: TimesheetEntry, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTimesheetEntry> {
            const localVarFetchArgs = TimesheetentryApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update timesheet entry. Multiple objects for different users can be sent in the same request.
         * @param {Array&lt;TimesheetEntry&gt;} [body] List of timesheet entry objects to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<TimesheetEntry>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTimesheetEntry> {
            const localVarFetchArgs = TimesheetentryApiFetchParamCreator(configuration).putList(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find timesheet entry corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, id?: string, employeeId?: string, projectId?: string, activityId?: string, comment?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TimesheetEntrySearchResponse> {
            const localVarFetchArgs = TimesheetentryApiFetchParamCreator(configuration).search(dateFrom, dateTo, id, employeeId, projectId, activityId, comment, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TimesheetentryApi - factory interface
 * @export
 */
export const TimesheetentryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete timesheet entry by ID.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, version?: number, options?: any) {
            return TimesheetentryApiFp(configuration)._delete(id, version, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find timesheet entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TimesheetentryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find recently used timesheet activities.
         * @param {number} projectId ID of project to find activities for
         * @param {number} [employeeId] ID of employee to find activities for. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivities(projectId: number, employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TimesheetentryApiFp(configuration).getRecentActivities(projectId, employeeId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find projects with recent activities (timesheet entry registered).
         * @param {number} [employeeId] ID of employee with recent project hours Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProjects(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TimesheetentryApiFp(configuration).getRecentProjects(employeeId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find total hours registered on an employee in a specific period.
         * @param {number} [employeeId] ID of employee to find hours for. Defaults to ID of token owner.
         * @param {string} [startDate] Format is yyyy-MM-dd (from and incl.). Defaults to today.
         * @param {string} [endDate] Format is yyyy-MM-dd (to and excl.). Defaults to tomorrow.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalHours(employeeId?: number, startDate?: string, endDate?: string, fields?: string, options?: any) {
            return TimesheetentryApiFp(configuration).getTotalHours(employeeId, startDate, endDate, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add new timesheet entry. Only one entry per employee/date/activity/project combination is supported.
         * @param {TimesheetEntry} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: TimesheetEntry, options?: any) {
            return TimesheetentryApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add new timesheet entry. Multiple objects for several users can be sent in the same request.
         * @param {Array&lt;TimesheetEntry&gt;} [body] List of timesheet entry objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(body?: Array<TimesheetEntry>, options?: any) {
            return TimesheetentryApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update timesheet entry by ID. Note: Timesheet entry object fields which are present but not set, or set to 0, will be nulled.
         * @param {number} id Element ID
         * @param {TimesheetEntry} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: TimesheetEntry, options?: any) {
            return TimesheetentryApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update timesheet entry. Multiple objects for different users can be sent in the same request.
         * @param {Array&lt;TimesheetEntry&gt;} [body] List of timesheet entry objects to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList(body?: Array<TimesheetEntry>, options?: any) {
            return TimesheetentryApiFp(configuration).putList(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find timesheet entry corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(dateFrom: string, dateTo: string, id?: string, employeeId?: string, projectId?: string, activityId?: string, comment?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TimesheetentryApiFp(configuration).search(dateFrom, dateTo, id, employeeId, projectId, activityId, comment, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TimesheetentryApi - object-oriented interface
 * @export
 * @class TimesheetentryApi
 * @extends {BaseAPI}
 */
export class TimesheetentryApi extends BaseAPI {
    /**
     * 
     * @summary Delete timesheet entry by ID.
     * @param {} id Element ID
     * @param {} [version] Number of current version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    public _delete(id: number, version?: number, options?: any) {
        return TimesheetentryApiFp(this.configuration)._delete(id, version, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find timesheet entry by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TimesheetentryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find recently used timesheet activities.
     * @param {} projectId ID of project to find activities for
     * @param {} [employeeId] ID of employee to find activities for. Defaults to ID of token owner.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    public getRecentActivities(projectId: number, employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TimesheetentryApiFp(this.configuration).getRecentActivities(projectId, employeeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find projects with recent activities (timesheet entry registered).
     * @param {} [employeeId] ID of employee with recent project hours Defaults to ID of token owner.
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    public getRecentProjects(employeeId?: number, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TimesheetentryApiFp(this.configuration).getRecentProjects(employeeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find total hours registered on an employee in a specific period.
     * @param {} [employeeId] ID of employee to find hours for. Defaults to ID of token owner.
     * @param {} [startDate] Format is yyyy-MM-dd (from and incl.). Defaults to today.
     * @param {} [endDate] Format is yyyy-MM-dd (to and excl.). Defaults to tomorrow.
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    public getTotalHours(employeeId?: number, startDate?: string, endDate?: string, fields?: string, options?: any) {
        return TimesheetentryApiFp(this.configuration).getTotalHours(employeeId, startDate, endDate, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add new timesheet entry. Only one entry per employee/date/activity/project combination is supported.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    public post(body?: TimesheetEntry, options?: any) {
        return TimesheetentryApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add new timesheet entry. Multiple objects for several users can be sent in the same request.
     * @param {} [body] List of timesheet entry objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    public postList(body?: Array<TimesheetEntry>, options?: any) {
        return TimesheetentryApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update timesheet entry by ID. Note: Timesheet entry object fields which are present but not set, or set to 0, will be nulled.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    public put(id: number, body?: TimesheetEntry, options?: any) {
        return TimesheetentryApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update timesheet entry. Multiple objects for different users can be sent in the same request.
     * @param {} [body] List of timesheet entry objects to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    public putList(body?: Array<TimesheetEntry>, options?: any) {
        return TimesheetentryApiFp(this.configuration).putList(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find timesheet entry corresponding with sent data.
     * @param {} dateFrom From and including
     * @param {} dateTo To and excluding
     * @param {} [id] List of IDs
     * @param {} [employeeId] List of IDs
     * @param {} [projectId] List of IDs
     * @param {} [activityId] List of IDs
     * @param {} [comment] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    public search(dateFrom: string, dateTo: string, id?: string, employeeId?: string, projectId?: string, activityId?: string, comment?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TimesheetentryApiFp(this.configuration).search(dateFrom, dateTo, id, employeeId, projectId, activityId, comment, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TimesheettimeClockApi - fetch parameter creator
 * @export
 */
export const TimesheettimeClockApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find time clock entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/timesheet/timeClock/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a user’s present running time clock.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresent(employeeId?: number, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/timesheet/timeClock/present`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update time clock by ID.
         * @param {number} id Element ID
         * @param {TimeClock} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: TimeClock, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/timesheet/timeClock/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TimeClock" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find time clock entries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [hourId] List of IDs
         * @param {boolean} [isRunning] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, employeeId?: string, projectId?: string, activityId?: string, dateFrom?: string, dateTo?: string, hourId?: string, isRunning?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/timesheet/timeClock`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            if (hourId !== undefined) {
                localVarQueryParameter['hourId'] = hourId;
            }

            if (isRunning !== undefined) {
                localVarQueryParameter['isRunning'] = isRunning;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start time clock.
         * @param {number} activityId Activity ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [projectId] Project ID
         * @param {string} [date] Optional. Default is today’s date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(activityId: number, employeeId?: number, projectId?: number, date?: string, options: any = {}): FetchArgs {
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError('activityId','Required parameter activityId was null or undefined when calling start.');
            }
            const localVarPath = `/timesheet/timeClock/:start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop time clock.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop(id: number, version?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stop.');
            }
            const localVarPath = `/timesheet/timeClock/{id}/:stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimesheettimeClockApi - functional programming interface
 * @export
 */
export const TimesheettimeClockApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find time clock entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTimeClock> {
            const localVarFetchArgs = TimesheettimeClockApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a user’s present running time clock.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresent(employeeId?: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTimeClock> {
            const localVarFetchArgs = TimesheettimeClockApiFetchParamCreator(configuration).getPresent(employeeId, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update time clock by ID.
         * @param {number} id Element ID
         * @param {TimeClock} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: TimeClock, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTimeClock> {
            const localVarFetchArgs = TimesheettimeClockApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find time clock entries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [hourId] List of IDs
         * @param {boolean} [isRunning] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, employeeId?: string, projectId?: string, activityId?: string, dateFrom?: string, dateTo?: string, hourId?: string, isRunning?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTimeClock> {
            const localVarFetchArgs = TimesheettimeClockApiFetchParamCreator(configuration).search(id, employeeId, projectId, activityId, dateFrom, dateTo, hourId, isRunning, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start time clock.
         * @param {number} activityId Activity ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [projectId] Project ID
         * @param {string} [date] Optional. Default is today’s date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(activityId: number, employeeId?: number, projectId?: number, date?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTimeClock> {
            const localVarFetchArgs = TimesheettimeClockApiFetchParamCreator(configuration).start(activityId, employeeId, projectId, date, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop time clock.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop(id: number, version?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TimesheettimeClockApiFetchParamCreator(configuration).stop(id, version, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TimesheettimeClockApi - factory interface
 * @export
 */
export const TimesheettimeClockApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Find time clock entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TimesheettimeClockApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a user’s present running time clock.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresent(employeeId?: number, fields?: string, options?: any) {
            return TimesheettimeClockApiFp(configuration).getPresent(employeeId, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update time clock by ID.
         * @param {number} id Element ID
         * @param {TimeClock} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: TimeClock, options?: any) {
            return TimesheettimeClockApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find time clock entries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [hourId] List of IDs
         * @param {boolean} [isRunning] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, employeeId?: string, projectId?: string, activityId?: string, dateFrom?: string, dateTo?: string, hourId?: string, isRunning?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TimesheettimeClockApiFp(configuration).search(id, employeeId, projectId, activityId, dateFrom, dateTo, hourId, isRunning, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start time clock.
         * @param {number} activityId Activity ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [projectId] Project ID
         * @param {string} [date] Optional. Default is today’s date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(activityId: number, employeeId?: number, projectId?: number, date?: string, options?: any) {
            return TimesheettimeClockApiFp(configuration).start(activityId, employeeId, projectId, date, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop time clock.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop(id: number, version?: number, options?: any) {
            return TimesheettimeClockApiFp(configuration).stop(id, version, options)(fetch, basePath);
        },
    };
};

/**
 * TimesheettimeClockApi - object-oriented interface
 * @export
 * @class TimesheettimeClockApi
 * @extends {BaseAPI}
 */
export class TimesheettimeClockApi extends BaseAPI {
    /**
     * 
     * @summary Find time clock entry by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TimesheettimeClockApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a user’s present running time clock.
     * @param {} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    public getPresent(employeeId?: number, fields?: string, options?: any) {
        return TimesheettimeClockApiFp(this.configuration).getPresent(employeeId, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update time clock by ID.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    public put(id: number, body?: TimeClock, options?: any) {
        return TimesheettimeClockApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find time clock entries corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [employeeId] List of IDs
     * @param {} [projectId] List of IDs
     * @param {} [activityId] List of IDs
     * @param {} [dateFrom] From and including
     * @param {} [dateTo] To and excluding
     * @param {} [hourId] List of IDs
     * @param {} [isRunning] Equals
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    public search(id?: string, employeeId?: string, projectId?: string, activityId?: string, dateFrom?: string, dateTo?: string, hourId?: string, isRunning?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TimesheettimeClockApiFp(this.configuration).search(id, employeeId, projectId, activityId, dateFrom, dateTo, hourId, isRunning, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start time clock.
     * @param {} activityId Activity ID
     * @param {} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {} [projectId] Project ID
     * @param {} [date] Optional. Default is today’s date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    public start(activityId: number, employeeId?: number, projectId?: number, date?: string, options?: any) {
        return TimesheettimeClockApiFp(this.configuration).start(activityId, employeeId, projectId, date, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop time clock.
     * @param {} id Element ID
     * @param {} [version] Number of current version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    public stop(id: number, version?: number, options?: any) {
        return TimesheettimeClockApiFp(this.configuration).stop(id, version, options)(this.fetch, this.basePath);
    }

}

/**
 * TokenconsumerApi - fetch parameter creator
 * @export
 */
export const TokenconsumerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get consumer token by token string.
         * @param {string} token Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getByToken.');
            }
            const localVarPath = `/token/consumer/byToken`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenconsumerApi - functional programming interface
 * @export
 */
export const TokenconsumerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get consumer token by token string.
         * @param {string} token Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperConsumerToken> {
            const localVarFetchArgs = TokenconsumerApiFetchParamCreator(configuration).getByToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TokenconsumerApi - factory interface
 * @export
 */
export const TokenconsumerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get consumer token by token string.
         * @param {string} token Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByToken(token: string, fields?: string, options?: any) {
            return TokenconsumerApiFp(configuration).getByToken(token, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TokenconsumerApi - object-oriented interface
 * @export
 * @class TokenconsumerApi
 * @extends {BaseAPI}
 */
export class TokenconsumerApi extends BaseAPI {
    /**
     * 
     * @summary Get consumer token by token string.
     * @param {} token Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenconsumerApi
     */
    public getByToken(token: string, fields?: string, options?: any) {
        return TokenconsumerApiFp(this.configuration).getByToken(token, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TokenemployeeApi - fetch parameter creator
 * @export
 */
export const TokenemployeeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an employee token. Only selected consumers are allowed
         * @param {string} tokenName A user defined name for the new token
         * @param {string} consumerName The name of the consumer
         * @param {number} employeeId The id of the employee
         * @param {boolean} companyOwned Is the key company owned
         * @param {string} expirationDate Expiration date for the employeeToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(tokenName: string, consumerName: string, employeeId: number, companyOwned: boolean, expirationDate: string, options: any = {}): FetchArgs {
            // verify required parameter 'tokenName' is not null or undefined
            if (tokenName === null || tokenName === undefined) {
                throw new RequiredError('tokenName','Required parameter tokenName was null or undefined when calling create.');
            }
            // verify required parameter 'consumerName' is not null or undefined
            if (consumerName === null || consumerName === undefined) {
                throw new RequiredError('consumerName','Required parameter consumerName was null or undefined when calling create.');
            }
            // verify required parameter 'employeeId' is not null or undefined
            if (employeeId === null || employeeId === undefined) {
                throw new RequiredError('employeeId','Required parameter employeeId was null or undefined when calling create.');
            }
            // verify required parameter 'companyOwned' is not null or undefined
            if (companyOwned === null || companyOwned === undefined) {
                throw new RequiredError('companyOwned','Required parameter companyOwned was null or undefined when calling create.');
            }
            // verify required parameter 'expirationDate' is not null or undefined
            if (expirationDate === null || expirationDate === undefined) {
                throw new RequiredError('expirationDate','Required parameter expirationDate was null or undefined when calling create.');
            }
            const localVarPath = `/token/employee/:create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['tokenName'] = tokenName;
            }

            if (consumerName !== undefined) {
                localVarQueryParameter['consumerName'] = consumerName;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (companyOwned !== undefined) {
                localVarQueryParameter['companyOwned'] = companyOwned;
            }

            if (expirationDate !== undefined) {
                localVarQueryParameter['expirationDate'] = expirationDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenemployeeApi - functional programming interface
 * @export
 */
export const TokenemployeeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an employee token. Only selected consumers are allowed
         * @param {string} tokenName A user defined name for the new token
         * @param {string} consumerName The name of the consumer
         * @param {number} employeeId The id of the employee
         * @param {boolean} companyOwned Is the key company owned
         * @param {string} expirationDate Expiration date for the employeeToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(tokenName: string, consumerName: string, employeeId: number, companyOwned: boolean, expirationDate: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperEmployeeToken> {
            const localVarFetchArgs = TokenemployeeApiFetchParamCreator(configuration).create(tokenName, consumerName, employeeId, companyOwned, expirationDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TokenemployeeApi - factory interface
 * @export
 */
export const TokenemployeeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create an employee token. Only selected consumers are allowed
         * @param {string} tokenName A user defined name for the new token
         * @param {string} consumerName The name of the consumer
         * @param {number} employeeId The id of the employee
         * @param {boolean} companyOwned Is the key company owned
         * @param {string} expirationDate Expiration date for the employeeToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(tokenName: string, consumerName: string, employeeId: number, companyOwned: boolean, expirationDate: string, options?: any) {
            return TokenemployeeApiFp(configuration).create(tokenName, consumerName, employeeId, companyOwned, expirationDate, options)(fetch, basePath);
        },
    };
};

/**
 * TokenemployeeApi - object-oriented interface
 * @export
 * @class TokenemployeeApi
 * @extends {BaseAPI}
 */
export class TokenemployeeApi extends BaseAPI {
    /**
     * 
     * @summary Create an employee token. Only selected consumers are allowed
     * @param {} tokenName A user defined name for the new token
     * @param {} consumerName The name of the consumer
     * @param {} employeeId The id of the employee
     * @param {} companyOwned Is the key company owned
     * @param {} expirationDate Expiration date for the employeeToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenemployeeApi
     */
    public create(tokenName: string, consumerName: string, employeeId: number, companyOwned: boolean, expirationDate: string, options?: any) {
        return TokenemployeeApiFp(this.configuration).create(tokenName, consumerName, employeeId, companyOwned, expirationDate, options)(this.fetch, this.basePath);
    }

}

/**
 * TokensessionApi - fetch parameter creator
 * @export
 */
export const TokensessionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete session token.
         * @param {string} token The login token string to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling _delete.');
            }
            const localVarPath = `/token/session/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create session token.
         * @param {string} consumerToken Token of the API consumer
         * @param {string} employeeToken The employees token
         * @param {string} expirationDate Expiration date for the combined token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(consumerToken: string, employeeToken: string, expirationDate: string, options: any = {}): FetchArgs {
            // verify required parameter 'consumerToken' is not null or undefined
            if (consumerToken === null || consumerToken === undefined) {
                throw new RequiredError('consumerToken','Required parameter consumerToken was null or undefined when calling create.');
            }
            // verify required parameter 'employeeToken' is not null or undefined
            if (employeeToken === null || employeeToken === undefined) {
                throw new RequiredError('employeeToken','Required parameter employeeToken was null or undefined when calling create.');
            }
            // verify required parameter 'expirationDate' is not null or undefined
            if (expirationDate === null || expirationDate === undefined) {
                throw new RequiredError('expirationDate','Required parameter expirationDate was null or undefined when calling create.');
            }
            const localVarPath = `/token/session/:create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (consumerToken !== undefined) {
                localVarQueryParameter['consumerToken'] = consumerToken;
            }

            if (employeeToken !== undefined) {
                localVarQueryParameter['employeeToken'] = employeeToken;
            }

            if (expirationDate !== undefined) {
                localVarQueryParameter['expirationDate'] = expirationDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find information about the current user.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoAmI(fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/token/session/>whoAmI`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensessionApi - functional programming interface
 * @export
 */
export const TokensessionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete session token.
         * @param {string} token The login token string to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TokensessionApiFetchParamCreator(configuration)._delete(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create session token.
         * @param {string} consumerToken Token of the API consumer
         * @param {string} employeeToken The employees token
         * @param {string} expirationDate Expiration date for the combined token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(consumerToken: string, employeeToken: string, expirationDate: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperSessionToken> {
            const localVarFetchArgs = TokensessionApiFetchParamCreator(configuration).create(consumerToken, employeeToken, expirationDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find information about the current user.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoAmI(fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperLoggedInUserInfoDTO> {
            const localVarFetchArgs = TokensessionApiFetchParamCreator(configuration).whoAmI(fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TokensessionApi - factory interface
 * @export
 */
export const TokensessionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete session token.
         * @param {string} token The login token string to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(token: string, options?: any) {
            return TokensessionApiFp(configuration)._delete(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create session token.
         * @param {string} consumerToken Token of the API consumer
         * @param {string} employeeToken The employees token
         * @param {string} expirationDate Expiration date for the combined token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(consumerToken: string, employeeToken: string, expirationDate: string, options?: any) {
            return TokensessionApiFp(configuration).create(consumerToken, employeeToken, expirationDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find information about the current user.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoAmI(fields?: string, options?: any) {
            return TokensessionApiFp(configuration).whoAmI(fields, options)(fetch, basePath);
        },
    };
};

/**
 * TokensessionApi - object-oriented interface
 * @export
 * @class TokensessionApi
 * @extends {BaseAPI}
 */
export class TokensessionApi extends BaseAPI {
    /**
     * 
     * @summary Delete session token.
     * @param {} token The login token string to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensessionApi
     */
    public _delete(token: string, options?: any) {
        return TokensessionApiFp(this.configuration)._delete(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create session token.
     * @param {} consumerToken Token of the API consumer
     * @param {} employeeToken The employees token
     * @param {} expirationDate Expiration date for the combined token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensessionApi
     */
    public create(consumerToken: string, employeeToken: string, expirationDate: string, options?: any) {
        return TokensessionApiFp(this.configuration).create(consumerToken, employeeToken, expirationDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find information about the current user.
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensessionApi
     */
    public whoAmI(fields?: string, options?: any) {
        return TokensessionApiFp(this.configuration).whoAmI(fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TravelExpenseApi - fetch parameter creator
 * @export
 */
export const TravelExpenseApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/travelExpense/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Approve travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve(id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/:approve`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Copy travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copy(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling copy.');
            }
            const localVarPath = `/travelExpense/:copy`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Deliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliver(id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/:deliver`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get travel expense by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/travelExpense/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create travel expense.
         * @param {TravelExpense} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: TravelExpense, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TravelExpense" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update travel expense.
         * @param {number} id Element ID
         * @param {TravelExpense} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: TravelExpense, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/travelExpense/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TravelExpense" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find travel expenses corresponding with sent data.
         * @param {string} [employeeId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectManagerId] Equals
         * @param {string} [departureDateFrom] From and including
         * @param {string} [returnDateTo] To and excluding
         * @param {string} [state] category
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: string, departmentId?: string, projectId?: string, projectManagerId?: string, departureDateFrom?: string, returnDateTo?: string, state?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (projectManagerId !== undefined) {
                localVarQueryParameter['projectManagerId'] = projectManagerId;
            }

            if (departureDateFrom !== undefined) {
                localVarQueryParameter['departureDateFrom'] = departureDateFrom;
            }

            if (returnDateTo !== undefined) {
                localVarQueryParameter['returnDateTo'] = returnDateTo;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Unapprove travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unapprove(id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/:unapprove`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Undeliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeliver(id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/:undeliver`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelExpenseApi - functional programming interface
 * @export
 */
export const TravelExpenseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TravelExpenseApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Approve travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve(id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTravelExpense> {
            const localVarFetchArgs = TravelExpenseApiFetchParamCreator(configuration).approve(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Copy travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copy(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTravelExpense> {
            const localVarFetchArgs = TravelExpenseApiFetchParamCreator(configuration).copy(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Deliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliver(id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTravelExpense> {
            const localVarFetchArgs = TravelExpenseApiFetchParamCreator(configuration).deliver(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get travel expense by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTravelExpense> {
            const localVarFetchArgs = TravelExpenseApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create travel expense.
         * @param {TravelExpense} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: TravelExpense, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTravelExpense> {
            const localVarFetchArgs = TravelExpenseApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update travel expense.
         * @param {number} id Element ID
         * @param {TravelExpense} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: TravelExpense, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTravelExpense> {
            const localVarFetchArgs = TravelExpenseApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find travel expenses corresponding with sent data.
         * @param {string} [employeeId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectManagerId] Equals
         * @param {string} [departureDateFrom] From and including
         * @param {string} [returnDateTo] To and excluding
         * @param {string} [state] category
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: string, departmentId?: string, projectId?: string, projectManagerId?: string, departureDateFrom?: string, returnDateTo?: string, state?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTravelExpense> {
            const localVarFetchArgs = TravelExpenseApiFetchParamCreator(configuration).search(employeeId, departmentId, projectId, projectManagerId, departureDateFrom, returnDateTo, state, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Unapprove travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unapprove(id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTravelExpense> {
            const localVarFetchArgs = TravelExpenseApiFetchParamCreator(configuration).unapprove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Undeliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeliver(id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTravelExpense> {
            const localVarFetchArgs = TravelExpenseApiFetchParamCreator(configuration).undeliver(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TravelExpenseApi - factory interface
 * @export
 */
export const TravelExpenseApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return TravelExpenseApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Approve travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve(id?: string, options?: any) {
            return TravelExpenseApiFp(configuration).approve(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Copy travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copy(id: number, options?: any) {
            return TravelExpenseApiFp(configuration).copy(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Deliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliver(id?: string, options?: any) {
            return TravelExpenseApiFp(configuration).deliver(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get travel expense by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TravelExpenseApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create travel expense.
         * @param {TravelExpense} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: TravelExpense, options?: any) {
            return TravelExpenseApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update travel expense.
         * @param {number} id Element ID
         * @param {TravelExpense} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: TravelExpense, options?: any) {
            return TravelExpenseApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find travel expenses corresponding with sent data.
         * @param {string} [employeeId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectManagerId] Equals
         * @param {string} [departureDateFrom] From and including
         * @param {string} [returnDateTo] To and excluding
         * @param {string} [state] category
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(employeeId?: string, departmentId?: string, projectId?: string, projectManagerId?: string, departureDateFrom?: string, returnDateTo?: string, state?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TravelExpenseApiFp(configuration).search(employeeId, departmentId, projectId, projectManagerId, departureDateFrom, returnDateTo, state, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Unapprove travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unapprove(id?: string, options?: any) {
            return TravelExpenseApiFp(configuration).unapprove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Undeliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeliver(id?: string, options?: any) {
            return TravelExpenseApiFp(configuration).undeliver(id, options)(fetch, basePath);
        },
    };
};

/**
 * TravelExpenseApi - object-oriented interface
 * @export
 * @class TravelExpenseApi
 * @extends {BaseAPI}
 */
export class TravelExpenseApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete travel expense.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    public _delete(id: number, options?: any) {
        return TravelExpenseApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Approve travel expenses.
     * @param {} [id] ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    public approve(id?: string, options?: any) {
        return TravelExpenseApiFp(this.configuration).approve(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Copy travel expense.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    public copy(id: number, options?: any) {
        return TravelExpenseApiFp(this.configuration).copy(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Deliver travel expenses.
     * @param {} [id] ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    public deliver(id?: string, options?: any) {
        return TravelExpenseApiFp(this.configuration).deliver(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get travel expense by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TravelExpenseApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create travel expense.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    public post(body?: TravelExpense, options?: any) {
        return TravelExpenseApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update travel expense.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    public put(id: number, body?: TravelExpense, options?: any) {
        return TravelExpenseApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find travel expenses corresponding with sent data.
     * @param {} [employeeId] Equals
     * @param {} [departmentId] Equals
     * @param {} [projectId] Equals
     * @param {} [projectManagerId] Equals
     * @param {} [departureDateFrom] From and including
     * @param {} [returnDateTo] To and excluding
     * @param {} [state] category
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    public search(employeeId?: string, departmentId?: string, projectId?: string, projectManagerId?: string, departureDateFrom?: string, returnDateTo?: string, state?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TravelExpenseApiFp(this.configuration).search(employeeId, departmentId, projectId, projectManagerId, departureDateFrom, returnDateTo, state, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Unapprove travel expenses.
     * @param {} [id] ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    public unapprove(id?: string, options?: any) {
        return TravelExpenseApiFp(this.configuration).unapprove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Undeliver travel expenses.
     * @param {} [id] ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    public undeliver(id?: string, options?: any) {
        return TravelExpenseApiFp(this.configuration).undeliver(id, options)(this.fetch, this.basePath);
    }

}

/**
 * TravelExpenseaccommodationAllowanceApi - fetch parameter creator
 * @export
 */
export const TravelExpenseaccommodationAllowanceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete accommodation allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/travelExpense/accommodationAllowance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get travel accommodation allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/travelExpense/accommodationAllowance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create accommodation allowance.
         * @param {AccommodationAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: AccommodationAllowance, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/accommodationAllowance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccommodationAllowance" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update accommodation allowance.
         * @param {number} id Element ID
         * @param {AccommodationAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: AccommodationAllowance, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/travelExpense/accommodationAllowance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccommodationAllowance" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find accommodation allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, rateFrom?: number, rateTo?: number, countFrom?: number, countTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/accommodationAllowance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (travelExpenseId !== undefined) {
                localVarQueryParameter['travelExpenseId'] = travelExpenseId;
            }

            if (rateTypeId !== undefined) {
                localVarQueryParameter['rateTypeId'] = rateTypeId;
            }

            if (rateCategoryId !== undefined) {
                localVarQueryParameter['rateCategoryId'] = rateCategoryId;
            }

            if (rateFrom !== undefined) {
                localVarQueryParameter['rateFrom'] = rateFrom;
            }

            if (rateTo !== undefined) {
                localVarQueryParameter['rateTo'] = rateTo;
            }

            if (countFrom !== undefined) {
                localVarQueryParameter['countFrom'] = countFrom;
            }

            if (countTo !== undefined) {
                localVarQueryParameter['countTo'] = countTo;
            }

            if (amountFrom !== undefined) {
                localVarQueryParameter['amountFrom'] = amountFrom;
            }

            if (amountTo !== undefined) {
                localVarQueryParameter['amountTo'] = amountTo;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelExpenseaccommodationAllowanceApi - functional programming interface
 * @export
 */
export const TravelExpenseaccommodationAllowanceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete accommodation allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TravelExpenseaccommodationAllowanceApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get travel accommodation allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperAccommodationAllowance> {
            const localVarFetchArgs = TravelExpenseaccommodationAllowanceApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create accommodation allowance.
         * @param {AccommodationAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: AccommodationAllowance, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperAccommodationAllowance> {
            const localVarFetchArgs = TravelExpenseaccommodationAllowanceApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update accommodation allowance.
         * @param {number} id Element ID
         * @param {AccommodationAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: AccommodationAllowance, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperAccommodationAllowance> {
            const localVarFetchArgs = TravelExpenseaccommodationAllowanceApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find accommodation allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, rateFrom?: number, rateTo?: number, countFrom?: number, countTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseAccommodationAllowance> {
            const localVarFetchArgs = TravelExpenseaccommodationAllowanceApiFetchParamCreator(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TravelExpenseaccommodationAllowanceApi - factory interface
 * @export
 */
export const TravelExpenseaccommodationAllowanceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete accommodation allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return TravelExpenseaccommodationAllowanceApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get travel accommodation allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TravelExpenseaccommodationAllowanceApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create accommodation allowance.
         * @param {AccommodationAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: AccommodationAllowance, options?: any) {
            return TravelExpenseaccommodationAllowanceApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update accommodation allowance.
         * @param {number} id Element ID
         * @param {AccommodationAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: AccommodationAllowance, options?: any) {
            return TravelExpenseaccommodationAllowanceApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find accommodation allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, rateFrom?: number, rateTo?: number, countFrom?: number, countTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TravelExpenseaccommodationAllowanceApiFp(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TravelExpenseaccommodationAllowanceApi - object-oriented interface
 * @export
 * @class TravelExpenseaccommodationAllowanceApi
 * @extends {BaseAPI}
 */
export class TravelExpenseaccommodationAllowanceApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete accommodation allowance.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseaccommodationAllowanceApi
     */
    public _delete(id: number, options?: any) {
        return TravelExpenseaccommodationAllowanceApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get travel accommodation allowance by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseaccommodationAllowanceApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TravelExpenseaccommodationAllowanceApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create accommodation allowance.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseaccommodationAllowanceApi
     */
    public post(body?: AccommodationAllowance, options?: any) {
        return TravelExpenseaccommodationAllowanceApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update accommodation allowance.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseaccommodationAllowanceApi
     */
    public put(id: number, body?: AccommodationAllowance, options?: any) {
        return TravelExpenseaccommodationAllowanceApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find accommodation allowances corresponding with sent data.
     * @param {} [travelExpenseId] Equals
     * @param {} [rateTypeId] Equals
     * @param {} [rateCategoryId] Equals
     * @param {} [rateFrom] From and including
     * @param {} [rateTo] To and excluding
     * @param {} [countFrom] From and including
     * @param {} [countTo] To and excluding
     * @param {} [amountFrom] From and including
     * @param {} [amountTo] To and excluding
     * @param {} [location] Containing
     * @param {} [address] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseaccommodationAllowanceApi
     */
    public search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, rateFrom?: number, rateTo?: number, countFrom?: number, countTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TravelExpenseaccommodationAllowanceApiFp(this.configuration).search(travelExpenseId, rateTypeId, rateCategoryId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TravelExpensecostApi - fetch parameter creator
 * @export
 */
export const TravelExpensecostApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete cost.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/travelExpense/cost/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get cost by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/travelExpense/cost/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create cost.
         * @param {Cost} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Cost, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/cost`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update cost.
         * @param {number} id Element ID
         * @param {Cost} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Cost, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/travelExpense/cost/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find costs corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [currencyId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, vatTypeId?: string, currencyId?: string, rateFrom?: number, rateTo?: number, countFrom?: number, countTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/cost`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (travelExpenseId !== undefined) {
                localVarQueryParameter['travelExpenseId'] = travelExpenseId;
            }

            if (vatTypeId !== undefined) {
                localVarQueryParameter['vatTypeId'] = vatTypeId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (rateFrom !== undefined) {
                localVarQueryParameter['rateFrom'] = rateFrom;
            }

            if (rateTo !== undefined) {
                localVarQueryParameter['rateTo'] = rateTo;
            }

            if (countFrom !== undefined) {
                localVarQueryParameter['countFrom'] = countFrom;
            }

            if (countTo !== undefined) {
                localVarQueryParameter['countTo'] = countTo;
            }

            if (amountFrom !== undefined) {
                localVarQueryParameter['amountFrom'] = amountFrom;
            }

            if (amountTo !== undefined) {
                localVarQueryParameter['amountTo'] = amountTo;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelExpensecostApi - functional programming interface
 * @export
 */
export const TravelExpensecostApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete cost.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TravelExpensecostApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get cost by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCost> {
            const localVarFetchArgs = TravelExpensecostApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create cost.
         * @param {Cost} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Cost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCost> {
            const localVarFetchArgs = TravelExpensecostApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update cost.
         * @param {number} id Element ID
         * @param {Cost} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Cost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperCost> {
            const localVarFetchArgs = TravelExpensecostApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find costs corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [currencyId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, vatTypeId?: string, currencyId?: string, rateFrom?: number, rateTo?: number, countFrom?: number, countTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseCost> {
            const localVarFetchArgs = TravelExpensecostApiFetchParamCreator(configuration).search(travelExpenseId, vatTypeId, currencyId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TravelExpensecostApi - factory interface
 * @export
 */
export const TravelExpensecostApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete cost.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return TravelExpensecostApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get cost by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TravelExpensecostApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create cost.
         * @param {Cost} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Cost, options?: any) {
            return TravelExpensecostApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update cost.
         * @param {number} id Element ID
         * @param {Cost} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Cost, options?: any) {
            return TravelExpensecostApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find costs corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [currencyId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, vatTypeId?: string, currencyId?: string, rateFrom?: number, rateTo?: number, countFrom?: number, countTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TravelExpensecostApiFp(configuration).search(travelExpenseId, vatTypeId, currencyId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TravelExpensecostApi - object-oriented interface
 * @export
 * @class TravelExpensecostApi
 * @extends {BaseAPI}
 */
export class TravelExpensecostApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete cost.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostApi
     */
    public _delete(id: number, options?: any) {
        return TravelExpensecostApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get cost by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TravelExpensecostApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create cost.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostApi
     */
    public post(body?: Cost, options?: any) {
        return TravelExpensecostApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update cost.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostApi
     */
    public put(id: number, body?: Cost, options?: any) {
        return TravelExpensecostApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find costs corresponding with sent data.
     * @param {} [travelExpenseId] Equals
     * @param {} [vatTypeId] Equals
     * @param {} [currencyId] Equals
     * @param {} [rateFrom] From and including
     * @param {} [rateTo] To and excluding
     * @param {} [countFrom] From and including
     * @param {} [countTo] To and excluding
     * @param {} [amountFrom] From and including
     * @param {} [amountTo] To and excluding
     * @param {} [location] Containing
     * @param {} [address] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostApi
     */
    public search(travelExpenseId?: string, vatTypeId?: string, currencyId?: string, rateFrom?: number, rateTo?: number, countFrom?: number, countTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TravelExpensecostApiFp(this.configuration).search(travelExpenseId, vatTypeId, currencyId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TravelExpensecostCategoryApi - fetch parameter creator
 * @export
 */
export const TravelExpensecostCategoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get cost category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/travelExpense/costCategory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find cost category corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/costCategory`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelExpensecostCategoryApi - functional programming interface
 * @export
 */
export const TravelExpensecostCategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get cost category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTravelCostCategory> {
            const localVarFetchArgs = TravelExpensecostCategoryApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find cost category corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTravelCostCategory> {
            const localVarFetchArgs = TravelExpensecostCategoryApiFetchParamCreator(configuration).search(id, description, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TravelExpensecostCategoryApi - factory interface
 * @export
 */
export const TravelExpensecostCategoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Get cost category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TravelExpensecostCategoryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find cost category corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TravelExpensecostCategoryApiFp(configuration).search(id, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TravelExpensecostCategoryApi - object-oriented interface
 * @export
 * @class TravelExpensecostCategoryApi
 * @extends {BaseAPI}
 */
export class TravelExpensecostCategoryApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Get cost category by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostCategoryApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TravelExpensecostCategoryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find cost category corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [description] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostCategoryApi
     */
    public search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TravelExpensecostCategoryApiFp(this.configuration).search(id, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TravelExpensemileageAllowanceApi - fetch parameter creator
 * @export
 */
export const TravelExpensemileageAllowanceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete mileage allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/travelExpense/mileageAllowance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get mileage allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/travelExpense/mileageAllowance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create mileage allowance.
         * @param {MileageAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: MileageAllowance, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/mileageAllowance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MileageAllowance" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update mileage allowance.
         * @param {number} id Element ID
         * @param {MileageAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: MileageAllowance, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/travelExpense/mileageAllowance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MileageAllowance" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find mileage allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [kmFrom] From and including
         * @param {number} [kmTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [departureLocation] Containing
         * @param {string} [destination] Containing
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {boolean} [isCompanyCar] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, kmFrom?: number, kmTo?: number, rateFrom?: number, rateTo?: number, amountFrom?: number, amountTo?: number, departureLocation?: string, destination?: string, dateFrom?: string, dateTo?: string, isCompanyCar?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/mileageAllowance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (travelExpenseId !== undefined) {
                localVarQueryParameter['travelExpenseId'] = travelExpenseId;
            }

            if (rateTypeId !== undefined) {
                localVarQueryParameter['rateTypeId'] = rateTypeId;
            }

            if (rateCategoryId !== undefined) {
                localVarQueryParameter['rateCategoryId'] = rateCategoryId;
            }

            if (kmFrom !== undefined) {
                localVarQueryParameter['kmFrom'] = kmFrom;
            }

            if (kmTo !== undefined) {
                localVarQueryParameter['kmTo'] = kmTo;
            }

            if (rateFrom !== undefined) {
                localVarQueryParameter['rateFrom'] = rateFrom;
            }

            if (rateTo !== undefined) {
                localVarQueryParameter['rateTo'] = rateTo;
            }

            if (amountFrom !== undefined) {
                localVarQueryParameter['amountFrom'] = amountFrom;
            }

            if (amountTo !== undefined) {
                localVarQueryParameter['amountTo'] = amountTo;
            }

            if (departureLocation !== undefined) {
                localVarQueryParameter['departureLocation'] = departureLocation;
            }

            if (destination !== undefined) {
                localVarQueryParameter['destination'] = destination;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            if (isCompanyCar !== undefined) {
                localVarQueryParameter['isCompanyCar'] = isCompanyCar;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelExpensemileageAllowanceApi - functional programming interface
 * @export
 */
export const TravelExpensemileageAllowanceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete mileage allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TravelExpensemileageAllowanceApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get mileage allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperMileageAllowance> {
            const localVarFetchArgs = TravelExpensemileageAllowanceApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create mileage allowance.
         * @param {MileageAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: MileageAllowance, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperMileageAllowance> {
            const localVarFetchArgs = TravelExpensemileageAllowanceApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update mileage allowance.
         * @param {number} id Element ID
         * @param {MileageAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: MileageAllowance, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperMileageAllowance> {
            const localVarFetchArgs = TravelExpensemileageAllowanceApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find mileage allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [kmFrom] From and including
         * @param {number} [kmTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [departureLocation] Containing
         * @param {string} [destination] Containing
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {boolean} [isCompanyCar] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, kmFrom?: number, kmTo?: number, rateFrom?: number, rateTo?: number, amountFrom?: number, amountTo?: number, departureLocation?: string, destination?: string, dateFrom?: string, dateTo?: string, isCompanyCar?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseMileageAllowance> {
            const localVarFetchArgs = TravelExpensemileageAllowanceApiFetchParamCreator(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, kmFrom, kmTo, rateFrom, rateTo, amountFrom, amountTo, departureLocation, destination, dateFrom, dateTo, isCompanyCar, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TravelExpensemileageAllowanceApi - factory interface
 * @export
 */
export const TravelExpensemileageAllowanceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete mileage allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return TravelExpensemileageAllowanceApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get mileage allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TravelExpensemileageAllowanceApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create mileage allowance.
         * @param {MileageAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: MileageAllowance, options?: any) {
            return TravelExpensemileageAllowanceApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update mileage allowance.
         * @param {number} id Element ID
         * @param {MileageAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: MileageAllowance, options?: any) {
            return TravelExpensemileageAllowanceApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find mileage allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [kmFrom] From and including
         * @param {number} [kmTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [departureLocation] Containing
         * @param {string} [destination] Containing
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {boolean} [isCompanyCar] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, kmFrom?: number, kmTo?: number, rateFrom?: number, rateTo?: number, amountFrom?: number, amountTo?: number, departureLocation?: string, destination?: string, dateFrom?: string, dateTo?: string, isCompanyCar?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TravelExpensemileageAllowanceApiFp(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, kmFrom, kmTo, rateFrom, rateTo, amountFrom, amountTo, departureLocation, destination, dateFrom, dateTo, isCompanyCar, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TravelExpensemileageAllowanceApi - object-oriented interface
 * @export
 * @class TravelExpensemileageAllowanceApi
 * @extends {BaseAPI}
 */
export class TravelExpensemileageAllowanceApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete mileage allowance.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensemileageAllowanceApi
     */
    public _delete(id: number, options?: any) {
        return TravelExpensemileageAllowanceApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get mileage allowance by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensemileageAllowanceApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TravelExpensemileageAllowanceApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create mileage allowance.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensemileageAllowanceApi
     */
    public post(body?: MileageAllowance, options?: any) {
        return TravelExpensemileageAllowanceApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update mileage allowance.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensemileageAllowanceApi
     */
    public put(id: number, body?: MileageAllowance, options?: any) {
        return TravelExpensemileageAllowanceApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find mileage allowances corresponding with sent data.
     * @param {} [travelExpenseId] Equals
     * @param {} [rateTypeId] Equals
     * @param {} [rateCategoryId] Equals
     * @param {} [kmFrom] From and including
     * @param {} [kmTo] To and excluding
     * @param {} [rateFrom] From and including
     * @param {} [rateTo] To and excluding
     * @param {} [amountFrom] From and including
     * @param {} [amountTo] To and excluding
     * @param {} [departureLocation] Containing
     * @param {} [destination] Containing
     * @param {} [dateFrom] From and including
     * @param {} [dateTo] To and excluding
     * @param {} [isCompanyCar] Equals
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensemileageAllowanceApi
     */
    public search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, kmFrom?: number, kmTo?: number, rateFrom?: number, rateTo?: number, amountFrom?: number, amountTo?: number, departureLocation?: string, destination?: string, dateFrom?: string, dateTo?: string, isCompanyCar?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TravelExpensemileageAllowanceApiFp(this.configuration).search(travelExpenseId, rateTypeId, rateCategoryId, kmFrom, kmTo, rateFrom, rateTo, amountFrom, amountTo, departureLocation, destination, dateFrom, dateTo, isCompanyCar, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TravelExpensepassengerApi - fetch parameter creator
 * @export
 */
export const TravelExpensepassengerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete passenger.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/travelExpense/passenger/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get passenger by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/travelExpense/passenger/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create passenger.
         * @param {Passenger} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Passenger, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/passenger`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Passenger" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update passenger.
         * @param {number} id Element ID
         * @param {Passenger} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Passenger, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/travelExpense/passenger/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Passenger" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find passengers corresponding with sent data.
         * @param {string} [mileageAllowance] Equals
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(mileageAllowance?: string, name?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/passenger`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (mileageAllowance !== undefined) {
                localVarQueryParameter['mileageAllowance'] = mileageAllowance;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelExpensepassengerApi - functional programming interface
 * @export
 */
export const TravelExpensepassengerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete passenger.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TravelExpensepassengerApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get passenger by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPassenger> {
            const localVarFetchArgs = TravelExpensepassengerApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create passenger.
         * @param {Passenger} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Passenger, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPassenger> {
            const localVarFetchArgs = TravelExpensepassengerApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update passenger.
         * @param {number} id Element ID
         * @param {Passenger} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Passenger, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPassenger> {
            const localVarFetchArgs = TravelExpensepassengerApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find passengers corresponding with sent data.
         * @param {string} [mileageAllowance] Equals
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(mileageAllowance?: string, name?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponsePassenger> {
            const localVarFetchArgs = TravelExpensepassengerApiFetchParamCreator(configuration).search(mileageAllowance, name, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TravelExpensepassengerApi - factory interface
 * @export
 */
export const TravelExpensepassengerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete passenger.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return TravelExpensepassengerApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get passenger by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TravelExpensepassengerApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create passenger.
         * @param {Passenger} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: Passenger, options?: any) {
            return TravelExpensepassengerApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update passenger.
         * @param {number} id Element ID
         * @param {Passenger} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: Passenger, options?: any) {
            return TravelExpensepassengerApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find passengers corresponding with sent data.
         * @param {string} [mileageAllowance] Equals
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(mileageAllowance?: string, name?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TravelExpensepassengerApiFp(configuration).search(mileageAllowance, name, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TravelExpensepassengerApi - object-oriented interface
 * @export
 * @class TravelExpensepassengerApi
 * @extends {BaseAPI}
 */
export class TravelExpensepassengerApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete passenger.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepassengerApi
     */
    public _delete(id: number, options?: any) {
        return TravelExpensepassengerApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get passenger by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepassengerApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TravelExpensepassengerApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create passenger.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepassengerApi
     */
    public post(body?: Passenger, options?: any) {
        return TravelExpensepassengerApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update passenger.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepassengerApi
     */
    public put(id: number, body?: Passenger, options?: any) {
        return TravelExpensepassengerApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find passengers corresponding with sent data.
     * @param {} [mileageAllowance] Equals
     * @param {} [name] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepassengerApi
     */
    public search(mileageAllowance?: string, name?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TravelExpensepassengerApiFp(this.configuration).search(mileageAllowance, name, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TravelExpensepaymentTypeApi - fetch parameter creator
 * @export
 */
export const TravelExpensepaymentTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/travelExpense/paymentType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/paymentType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelExpensepaymentTypeApi - functional programming interface
 * @export
 */
export const TravelExpensepaymentTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTravelPaymentType> {
            const localVarFetchArgs = TravelExpensepaymentTypeApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTravelPaymentType> {
            const localVarFetchArgs = TravelExpensepaymentTypeApiFetchParamCreator(configuration).search(id, description, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TravelExpensepaymentTypeApi - factory interface
 * @export
 */
export const TravelExpensepaymentTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TravelExpensepaymentTypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TravelExpensepaymentTypeApiFp(configuration).search(id, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TravelExpensepaymentTypeApi - object-oriented interface
 * @export
 * @class TravelExpensepaymentTypeApi
 * @extends {BaseAPI}
 */
export class TravelExpensepaymentTypeApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Get payment type by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepaymentTypeApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TravelExpensepaymentTypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find payment type corresponding with sent data.
     * @param {} [id] List of IDs
     * @param {} [description] Containing
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepaymentTypeApi
     */
    public search(id?: string, description?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TravelExpensepaymentTypeApiFp(this.configuration).search(id, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TravelExpenseperDiemCompensationApi - fetch parameter creator
 * @export
 */
export const TravelExpenseperDiemCompensationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete per diem compensation.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/travelExpense/perDiemCompensation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Get per diem compensation by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/travelExpense/perDiemCompensation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Create per diem compensation.
         * @param {PerDiemCompensation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: PerDiemCompensation, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/perDiemCompensation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PerDiemCompensation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Update per diem compensation.
         * @param {number} id Element ID
         * @param {PerDiemCompensation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: PerDiemCompensation, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/travelExpense/perDiemCompensation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PerDiemCompensation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find per diem compensations corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {string} [overnightAccommodation] Equals
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {boolean} [isDeductionForBreakfast] Equals
         * @param {boolean} [isLunchDeduction] Equals
         * @param {boolean} [isDinnerDeduction] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, overnightAccommodation?: string, countFrom?: number, countTo?: number, rateFrom?: number, rateTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, isDeductionForBreakfast?: boolean, isLunchDeduction?: boolean, isDinnerDeduction?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/perDiemCompensation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (travelExpenseId !== undefined) {
                localVarQueryParameter['travelExpenseId'] = travelExpenseId;
            }

            if (rateTypeId !== undefined) {
                localVarQueryParameter['rateTypeId'] = rateTypeId;
            }

            if (rateCategoryId !== undefined) {
                localVarQueryParameter['rateCategoryId'] = rateCategoryId;
            }

            if (overnightAccommodation !== undefined) {
                localVarQueryParameter['overnightAccommodation'] = overnightAccommodation;
            }

            if (countFrom !== undefined) {
                localVarQueryParameter['countFrom'] = countFrom;
            }

            if (countTo !== undefined) {
                localVarQueryParameter['countTo'] = countTo;
            }

            if (rateFrom !== undefined) {
                localVarQueryParameter['rateFrom'] = rateFrom;
            }

            if (rateTo !== undefined) {
                localVarQueryParameter['rateTo'] = rateTo;
            }

            if (amountFrom !== undefined) {
                localVarQueryParameter['amountFrom'] = amountFrom;
            }

            if (amountTo !== undefined) {
                localVarQueryParameter['amountTo'] = amountTo;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (isDeductionForBreakfast !== undefined) {
                localVarQueryParameter['isDeductionForBreakfast'] = isDeductionForBreakfast;
            }

            if (isLunchDeduction !== undefined) {
                localVarQueryParameter['isLunchDeduction'] = isLunchDeduction;
            }

            if (isDinnerDeduction !== undefined) {
                localVarQueryParameter['isDinnerDeduction'] = isDinnerDeduction;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelExpenseperDiemCompensationApi - functional programming interface
 * @export
 */
export const TravelExpenseperDiemCompensationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Delete per diem compensation.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TravelExpenseperDiemCompensationApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Get per diem compensation by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPerDiemCompensation> {
            const localVarFetchArgs = TravelExpenseperDiemCompensationApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Create per diem compensation.
         * @param {PerDiemCompensation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: PerDiemCompensation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPerDiemCompensation> {
            const localVarFetchArgs = TravelExpenseperDiemCompensationApiFetchParamCreator(configuration).post(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Update per diem compensation.
         * @param {number} id Element ID
         * @param {PerDiemCompensation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: PerDiemCompensation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperPerDiemCompensation> {
            const localVarFetchArgs = TravelExpenseperDiemCompensationApiFetchParamCreator(configuration).put(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find per diem compensations corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {string} [overnightAccommodation] Equals
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {boolean} [isDeductionForBreakfast] Equals
         * @param {boolean} [isLunchDeduction] Equals
         * @param {boolean} [isDinnerDeduction] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, overnightAccommodation?: string, countFrom?: number, countTo?: number, rateFrom?: number, rateTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, isDeductionForBreakfast?: boolean, isLunchDeduction?: boolean, isDinnerDeduction?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponsePerDiemCompensation> {
            const localVarFetchArgs = TravelExpenseperDiemCompensationApiFetchParamCreator(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, overnightAccommodation, countFrom, countTo, rateFrom, rateTo, amountFrom, amountTo, location, address, isDeductionForBreakfast, isLunchDeduction, isDinnerDeduction, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TravelExpenseperDiemCompensationApi - factory interface
 * @export
 */
export const TravelExpenseperDiemCompensationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Delete per diem compensation.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return TravelExpenseperDiemCompensationApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Get per diem compensation by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TravelExpenseperDiemCompensationApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Create per diem compensation.
         * @param {PerDiemCompensation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(body?: PerDiemCompensation, options?: any) {
            return TravelExpenseperDiemCompensationApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Update per diem compensation.
         * @param {number} id Element ID
         * @param {PerDiemCompensation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, body?: PerDiemCompensation, options?: any) {
            return TravelExpenseperDiemCompensationApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find per diem compensations corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {string} [overnightAccommodation] Equals
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {boolean} [isDeductionForBreakfast] Equals
         * @param {boolean} [isLunchDeduction] Equals
         * @param {boolean} [isDinnerDeduction] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, overnightAccommodation?: string, countFrom?: number, countTo?: number, rateFrom?: number, rateTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, isDeductionForBreakfast?: boolean, isLunchDeduction?: boolean, isDinnerDeduction?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TravelExpenseperDiemCompensationApiFp(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, overnightAccommodation, countFrom, countTo, rateFrom, rateTo, amountFrom, amountTo, location, address, isDeductionForBreakfast, isLunchDeduction, isDinnerDeduction, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TravelExpenseperDiemCompensationApi - object-oriented interface
 * @export
 * @class TravelExpenseperDiemCompensationApi
 * @extends {BaseAPI}
 */
export class TravelExpenseperDiemCompensationApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Delete per diem compensation.
     * @param {} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseperDiemCompensationApi
     */
    public _delete(id: number, options?: any) {
        return TravelExpenseperDiemCompensationApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Get per diem compensation by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseperDiemCompensationApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TravelExpenseperDiemCompensationApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Create per diem compensation.
     * @param {} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseperDiemCompensationApi
     */
    public post(body?: PerDiemCompensation, options?: any) {
        return TravelExpenseperDiemCompensationApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Update per diem compensation.
     * @param {} id Element ID
     * @param {} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseperDiemCompensationApi
     */
    public put(id: number, body?: PerDiemCompensation, options?: any) {
        return TravelExpenseperDiemCompensationApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find per diem compensations corresponding with sent data.
     * @param {} [travelExpenseId] Equals
     * @param {} [rateTypeId] Equals
     * @param {} [rateCategoryId] Equals
     * @param {} [overnightAccommodation] Equals
     * @param {} [countFrom] From and including
     * @param {} [countTo] To and excluding
     * @param {} [rateFrom] From and including
     * @param {} [rateTo] To and excluding
     * @param {} [amountFrom] From and including
     * @param {} [amountTo] To and excluding
     * @param {} [location] Containing
     * @param {} [address] Containing
     * @param {} [isDeductionForBreakfast] Equals
     * @param {} [isLunchDeduction] Equals
     * @param {} [isDinnerDeduction] Equals
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseperDiemCompensationApi
     */
    public search(travelExpenseId?: string, rateTypeId?: string, rateCategoryId?: string, overnightAccommodation?: string, countFrom?: number, countTo?: number, rateFrom?: number, rateTo?: number, amountFrom?: number, amountTo?: number, location?: string, address?: string, isDeductionForBreakfast?: boolean, isLunchDeduction?: boolean, isDinnerDeduction?: boolean, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TravelExpenseperDiemCompensationApiFp(this.configuration).search(travelExpenseId, rateTypeId, rateCategoryId, overnightAccommodation, countFrom, countTo, rateFrom, rateTo, amountFrom, amountTo, location, address, isDeductionForBreakfast, isLunchDeduction, isDinnerDeduction, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TravelExpenserateApi - fetch parameter creator
 * @export
 */
export const TravelExpenserateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get travel expense rate by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/travelExpense/rate/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find rates corresponding with sent data.
         * @param {string} [rateCategoryId] Equals
         * @param {string} [type] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [isValidForeignTravel] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [requiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(rateCategoryId?: string, type?: string, isValidDayTrip?: boolean, isValidAccommodation?: boolean, isValidDomestic?: boolean, isValidForeignTravel?: boolean, requiresZone?: boolean, requiresOvernightAccommodation?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/rate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (rateCategoryId !== undefined) {
                localVarQueryParameter['rateCategoryId'] = rateCategoryId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (isValidDayTrip !== undefined) {
                localVarQueryParameter['isValidDayTrip'] = isValidDayTrip;
            }

            if (isValidAccommodation !== undefined) {
                localVarQueryParameter['isValidAccommodation'] = isValidAccommodation;
            }

            if (isValidDomestic !== undefined) {
                localVarQueryParameter['isValidDomestic'] = isValidDomestic;
            }

            if (isValidForeignTravel !== undefined) {
                localVarQueryParameter['isValidForeignTravel'] = isValidForeignTravel;
            }

            if (requiresZone !== undefined) {
                localVarQueryParameter['requiresZone'] = requiresZone;
            }

            if (requiresOvernightAccommodation !== undefined) {
                localVarQueryParameter['requiresOvernightAccommodation'] = requiresOvernightAccommodation;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelExpenserateApi - functional programming interface
 * @export
 */
export const TravelExpenserateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get travel expense rate by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTravelExpenseRate> {
            const localVarFetchArgs = TravelExpenserateApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find rates corresponding with sent data.
         * @param {string} [rateCategoryId] Equals
         * @param {string} [type] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [isValidForeignTravel] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [requiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(rateCategoryId?: string, type?: string, isValidDayTrip?: boolean, isValidAccommodation?: boolean, isValidDomestic?: boolean, isValidForeignTravel?: boolean, requiresZone?: boolean, requiresOvernightAccommodation?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTravelExpenseRate> {
            const localVarFetchArgs = TravelExpenserateApiFetchParamCreator(configuration).search(rateCategoryId, type, isValidDayTrip, isValidAccommodation, isValidDomestic, isValidForeignTravel, requiresZone, requiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TravelExpenserateApi - factory interface
 * @export
 */
export const TravelExpenserateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Get travel expense rate by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TravelExpenserateApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find rates corresponding with sent data.
         * @param {string} [rateCategoryId] Equals
         * @param {string} [type] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [isValidForeignTravel] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [requiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(rateCategoryId?: string, type?: string, isValidDayTrip?: boolean, isValidAccommodation?: boolean, isValidDomestic?: boolean, isValidForeignTravel?: boolean, requiresZone?: boolean, requiresOvernightAccommodation?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TravelExpenserateApiFp(configuration).search(rateCategoryId, type, isValidDayTrip, isValidAccommodation, isValidDomestic, isValidForeignTravel, requiresZone, requiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TravelExpenserateApi - object-oriented interface
 * @export
 * @class TravelExpenserateApi
 * @extends {BaseAPI}
 */
export class TravelExpenserateApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Get travel expense rate by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TravelExpenserateApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find rates corresponding with sent data.
     * @param {} [rateCategoryId] Equals
     * @param {} [type] Equals
     * @param {} [isValidDayTrip] Equals
     * @param {} [isValidAccommodation] Equals
     * @param {} [isValidDomestic] Equals
     * @param {} [isValidForeignTravel] Equals
     * @param {} [requiresZone] Equals
     * @param {} [requiresOvernightAccommodation] Equals
     * @param {} [dateFrom] From and including
     * @param {} [dateTo] To and excluding
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateApi
     */
    public search(rateCategoryId?: string, type?: string, isValidDayTrip?: boolean, isValidAccommodation?: boolean, isValidDomestic?: boolean, isValidForeignTravel?: boolean, requiresZone?: boolean, requiresOvernightAccommodation?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TravelExpenserateApiFp(this.configuration).search(rateCategoryId, type, isValidDayTrip, isValidAccommodation, isValidDomestic, isValidForeignTravel, requiresZone, requiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TravelExpenserateCategoryApi - fetch parameter creator
 * @export
 */
export const TravelExpenserateCategoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get travel expense rate category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/travelExpense/rateCategory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find rate categories corresponding with sent data.
         * @param {string} [type] Equals
         * @param {string} [name] Containing
         * @param {number} [travelReportRateCategoryGroupId] Equals
         * @param {string} [ameldingWageCode] Containing
         * @param {string} [wageCodeNumber] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [isRequiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(type?: string, name?: string, travelReportRateCategoryGroupId?: number, ameldingWageCode?: string, wageCodeNumber?: string, isValidDayTrip?: boolean, isValidAccommodation?: boolean, isValidDomestic?: boolean, requiresZone?: boolean, isRequiresOvernightAccommodation?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/rateCategory`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (travelReportRateCategoryGroupId !== undefined) {
                localVarQueryParameter['travelReportRateCategoryGroupId'] = travelReportRateCategoryGroupId;
            }

            if (ameldingWageCode !== undefined) {
                localVarQueryParameter['ameldingWageCode'] = ameldingWageCode;
            }

            if (wageCodeNumber !== undefined) {
                localVarQueryParameter['wageCodeNumber'] = wageCodeNumber;
            }

            if (isValidDayTrip !== undefined) {
                localVarQueryParameter['isValidDayTrip'] = isValidDayTrip;
            }

            if (isValidAccommodation !== undefined) {
                localVarQueryParameter['isValidAccommodation'] = isValidAccommodation;
            }

            if (isValidDomestic !== undefined) {
                localVarQueryParameter['isValidDomestic'] = isValidDomestic;
            }

            if (requiresZone !== undefined) {
                localVarQueryParameter['requiresZone'] = requiresZone;
            }

            if (isRequiresOvernightAccommodation !== undefined) {
                localVarQueryParameter['isRequiresOvernightAccommodation'] = isRequiresOvernightAccommodation;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelExpenserateCategoryApi - functional programming interface
 * @export
 */
export const TravelExpenserateCategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get travel expense rate category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTravelExpenseRateCategory> {
            const localVarFetchArgs = TravelExpenserateCategoryApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find rate categories corresponding with sent data.
         * @param {string} [type] Equals
         * @param {string} [name] Containing
         * @param {number} [travelReportRateCategoryGroupId] Equals
         * @param {string} [ameldingWageCode] Containing
         * @param {string} [wageCodeNumber] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [isRequiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(type?: string, name?: string, travelReportRateCategoryGroupId?: number, ameldingWageCode?: string, wageCodeNumber?: string, isValidDayTrip?: boolean, isValidAccommodation?: boolean, isValidDomestic?: boolean, requiresZone?: boolean, isRequiresOvernightAccommodation?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTravelExpenseRateCategory> {
            const localVarFetchArgs = TravelExpenserateCategoryApiFetchParamCreator(configuration).search(type, name, travelReportRateCategoryGroupId, ameldingWageCode, wageCodeNumber, isValidDayTrip, isValidAccommodation, isValidDomestic, requiresZone, isRequiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TravelExpenserateCategoryApi - factory interface
 * @export
 */
export const TravelExpenserateCategoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Get travel expense rate category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TravelExpenserateCategoryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find rate categories corresponding with sent data.
         * @param {string} [type] Equals
         * @param {string} [name] Containing
         * @param {number} [travelReportRateCategoryGroupId] Equals
         * @param {string} [ameldingWageCode] Containing
         * @param {string} [wageCodeNumber] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [isRequiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(type?: string, name?: string, travelReportRateCategoryGroupId?: number, ameldingWageCode?: string, wageCodeNumber?: string, isValidDayTrip?: boolean, isValidAccommodation?: boolean, isValidDomestic?: boolean, requiresZone?: boolean, isRequiresOvernightAccommodation?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TravelExpenserateCategoryApiFp(configuration).search(type, name, travelReportRateCategoryGroupId, ameldingWageCode, wageCodeNumber, isValidDayTrip, isValidAccommodation, isValidDomestic, requiresZone, isRequiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TravelExpenserateCategoryApi - object-oriented interface
 * @export
 * @class TravelExpenserateCategoryApi
 * @extends {BaseAPI}
 */
export class TravelExpenserateCategoryApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Get travel expense rate category by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateCategoryApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TravelExpenserateCategoryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find rate categories corresponding with sent data.
     * @param {} [type] Equals
     * @param {} [name] Containing
     * @param {} [travelReportRateCategoryGroupId] Equals
     * @param {} [ameldingWageCode] Containing
     * @param {} [wageCodeNumber] Equals
     * @param {} [isValidDayTrip] Equals
     * @param {} [isValidAccommodation] Equals
     * @param {} [isValidDomestic] Equals
     * @param {} [requiresZone] Equals
     * @param {} [isRequiresOvernightAccommodation] Equals
     * @param {} [dateFrom] From and including
     * @param {} [dateTo] To and excluding
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateCategoryApi
     */
    public search(type?: string, name?: string, travelReportRateCategoryGroupId?: number, ameldingWageCode?: string, wageCodeNumber?: string, isValidDayTrip?: boolean, isValidAccommodation?: boolean, isValidDomestic?: boolean, requiresZone?: boolean, isRequiresOvernightAccommodation?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TravelExpenserateCategoryApiFp(this.configuration).search(type, name, travelReportRateCategoryGroupId, ameldingWageCode, wageCodeNumber, isValidDayTrip, isValidAccommodation, isValidDomestic, requiresZone, isRequiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * TravelExpenserateCategoryGroupApi - fetch parameter creator
 * @export
 */
export const TravelExpenserateCategoryGroupApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get travel report rate category group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/travelExpense/rateCategoryGroup/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [BETA] Find rate categoriy groups corresponding with sent data.
         * @param {string} [name] Containing
         * @param {boolean} [isForeignTravel] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(name?: string, isForeignTravel?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/travelExpense/rateCategoryGroup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (isForeignTravel !== undefined) {
                localVarQueryParameter['isForeignTravel'] = isForeignTravel;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelExpenserateCategoryGroupApi - functional programming interface
 * @export
 */
export const TravelExpenserateCategoryGroupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary [BETA] Get travel report rate category group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseWrapperTravelExpenseRateCategoryGroup> {
            const localVarFetchArgs = TravelExpenserateCategoryGroupApiFetchParamCreator(configuration).get(id, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary [BETA] Find rate categoriy groups corresponding with sent data.
         * @param {string} [name] Containing
         * @param {boolean} [isForeignTravel] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(name?: string, isForeignTravel?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponseTravelExpenseRateCategoryGroup> {
            const localVarFetchArgs = TravelExpenserateCategoryGroupApiFetchParamCreator(configuration).search(name, isForeignTravel, dateFrom, dateTo, from, count, sorting, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TravelExpenserateCategoryGroupApi - factory interface
 * @export
 */
export const TravelExpenserateCategoryGroupApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary [BETA] Get travel report rate category group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, fields?: string, options?: any) {
            return TravelExpenserateCategoryGroupApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary [BETA] Find rate categoriy groups corresponding with sent data.
         * @param {string} [name] Containing
         * @param {boolean} [isForeignTravel] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(name?: string, isForeignTravel?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
            return TravelExpenserateCategoryGroupApiFp(configuration).search(name, isForeignTravel, dateFrom, dateTo, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};

/**
 * TravelExpenserateCategoryGroupApi - object-oriented interface
 * @export
 * @class TravelExpenserateCategoryGroupApi
 * @extends {BaseAPI}
 */
export class TravelExpenserateCategoryGroupApi extends BaseAPI {
    /**
     * 
     * @summary [BETA] Get travel report rate category group by ID.
     * @param {} id Element ID
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateCategoryGroupApi
     */
    public get(id: number, fields?: string, options?: any) {
        return TravelExpenserateCategoryGroupApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary [BETA] Find rate categoriy groups corresponding with sent data.
     * @param {} [name] Containing
     * @param {} [isForeignTravel] Equals
     * @param {} [dateFrom] From and including
     * @param {} [dateTo] To and excluding
     * @param {} [from] From index
     * @param {} [count] Number of elements to return
     * @param {} [sorting] Sorting pattern
     * @param {} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateCategoryGroupApi
     */
    public search(name?: string, isForeignTravel?: boolean, dateFrom?: string, dateTo?: string, from?: number, count?: number, sorting?: string, fields?: string, options?: any) {
        return TravelExpenserateCategoryGroupApiFp(this.configuration).search(name, isForeignTravel, dateFrom, dateTo, from, count, sorting, fields, options)(this.fetch, this.basePath);
    }

}

