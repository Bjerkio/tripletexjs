"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Tripletex API
 * The Tripletex API is a **RESTful API**, which does not implement PATCH, but uses a PUT with optional fields.  **Actions** or commands are represented in our RESTful path with a prefixed **\":\"**. Example: **\"/v2/hours/123/:approve\"**.  **Summaries** or aggregated results are represented in our RESTful path with a prefixed **\"&gt;\"**. Example: **\"/v2/hours/&gt;thisWeeksBillables\"**.  **\"requestID\"** is a key found in all validation and error responses. If additional log information is absolutely necessary, our support division can locate the key value.  **HTTPS** is used by the entire API and will throw an error on HTTP.  **Download** the [swagger.json](/v2/swagger.json) file [OpenAPI Specification](https://github.com/OAI/OpenAPI-Specification) to [generate code](https://github.com/swagger-api/swagger-codegen). This document was generated from the Swagger JSON file.  **version:** This is a versioning number found on all DB records. If included, it will prevent your PUT/POST from overriding any updates to the record since your GET.  **Date & DateTime** follows the **ISO 8601** standard. Date: YYYY-MM-DD. DateTime: YYYY-MM-DDThh:mm:ssZ  **Sorting** is done by specifying a comma separated list, where a \"-\" prefix denotes descending. You can sort by sub object with the following format: 'project.name, -date'.  **Searching:** is done by entering values in the optional fields for each API call. The values fall into the following categories: range, in, exact and like.  **Missing fields or even no response data** can occur because result objects and fields are filtered on authorization.  **See [FAQ](https://tripletex.no/execute/docViewer?articleId=906&language=0) for more additional information.**   ##Authentication: - **Tokens:** The Tripletex API uses 3 different tokens - **consumerToken**, **employeeToken** and **sessionToken**.  - **consumerToken** is a token provided to the consumer by Tripletex after the API 2.0 registration is completed.  - **employeeToken** is a token created by an administrator in your Tripletex account via the user settings and the tab \"API access\". Each employee token must be given a set of entitlements. [Read more here.](https://tripletex.no/execute/docViewer?articleId=853&language=0)  - **sessionToken** is the token from \"/tokens/session/:create\" which requires a consumerToken and an employeeToken created with the same consumer token, but not an authentication header. See how to create a sessionToken [here](https://tripletex.no/execute/docViewer?articleId=855&language=0). - The session token is used as the password in \"Basic Authentication Header\" for API calls.  - Use blank or 0 as username for accessing the account with regular employee token, or if a company owned employee token accesses \"/company/&gt;withLoginAccess\" or \"/token/session/&gt;whoAmI\".  - For company owned employee tokens (accounting offices) the ID from \"/company/&gt;withLoginAccess\" can be used as username for accessing client accounts.  - If you need to create the header yourself use \"Authorization: Basic &lt;base64encode('0:sessionToken')&gt;\".   ##Tags: - <div class=\"tag-icon-beta\"></div> **[BETA]** This is a beta endpoint and can be subject to change. - <div class=\"tag-icon-deprecated\"></div> **[DEPRECATED]** Deprecated means that we intend to remove/change this feature or capability in a future \"major\" API release. We therefore discourage all use of this feature/capability.  ##Fields: - **project,activity,hours**  returns _{project:..., activity:...., hours:...}_. - just **project** returns _\"project\" : { \"id\": 12345, \"url\": \"tripletex.no/v2/projects/12345\"  }_. - **project(*)** returns _\"project\" : { \"id\": 12345 \"name\":\"ProjectName\" \"number.....startDate\": \"2013-01-07\" }_. - **project(name)** returns _*\"project\" : { \"name\":\"ProjectName\" }*_. - All elements and some subElements :  _*,activity(name),employee(*)_.  ##Changelog: - To get the changelog for a resource, 'changes' have to be explicitly specified as part of the fields parameter, I.E '*,changes'. - There are two types of change available:  -- 'CREATE' for when the resource was created -- 'UPDATE' for when the resource was last updated   ##Rate limiting in each response header: - **X-Rate-Limit-Limit** - The number of allowed requests in the current period. - **X-Rate-Limit-Remaining** - The number of remaining requests. - **X-Rate-Limit-Reset** - The number of seconds left in the current period.   ##Response envelope: ``` {   \"fullResultSize\": ###,   \"from\": ###, // Paging starting from   \"count\": ###, // Paging count   \"versionDigest\": \"Hash of full result\",   \"values\": [...list of objects...] } {   \"value\": {...single object...} } ```   ##WebHook envelope: ``` {   \"subscriptionId\": ###,   \"key\": \"object.verb\", // As listed from /v2/event/   \"id\": ###, // Object id   \"value\": {... single object, null if object.deleted ...} } ```    ##Error/Warning envelope: ``` {   \"status\": ###, // HTTP status code   \"code\": #####, // internal status code of event   \"message\": \"Basic feedback message in your language\",   \"link\": \"Link to doc\",   \"developerMessage\": \"More technical message\",   \"validationMessages\": [ // Will be null if Error     {       \"field\": \"Name of field\",       \"message\": \"Validation failure information\"     }   ],   \"requestId\": \"UUID used in any logs\" } ```   ##Status codes / Error codes: - **200 OK** - **201 Created** - From POSTs that create something new. - **204 No Content** - When there is no answer, ex: \"/:anAction\" or DELETE. - **400 Bad request** -   - **4000** Bad Request Exception   - **11000** Illegal Filter Exception   - **12000** Path Param Exception   - **24000**   Cryptography Exception - **401 Unauthorized** - When authentication is required and has failed or has not yet been provided   -  **3000** Authentication Exception   -  **9000** Security Exception - **403 Forbidden** - When AuthorisationManager says no. - **404 Not Found** - For content/IDs that does not exist.   -  **6000** Not Found Exception - **409 Conflict** - Such as an edit conflict between multiple simultaneous updates   -  **7000** Object Exists Exception   -  **8000** Revision Exception   - **10000** Locked Exception   - **14000** Duplicate entry - **422 Bad Request** - For Required fields or things like malformed payload.   - **15000** Value Validation Exception   - **16000** Mapping Exception   - **17000** Sorting Exception   - **18000** Validation Exception   - **21000** Param Exception   - **22000** Invalid JSON Exception   - **23000**   Result Set Too Large Exception - **500 Internal Error** -  Unexpected condition was encountered and no more specific message is suitable   -  **1000** Exception
 *
 * OpenAPI spec version: 2.15.2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var url = require("url");
var btoa = require("btoa");
var portableFetch = require("portable-fetch");
var BASE_PATH = "https://tripletex.no/v2".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(configuration, basePath, fetch) {
        if (basePath === void 0) { basePath = BASE_PATH; }
        if (fetch === void 0) { fetch = portableFetch; }
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
    return BaseAPI;
}());
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
var RequiredError = /** @class */ (function (_super) {
    __extends(RequiredError, _super);
    function RequiredError(field, msg) {
        var _this = _super.call(this, msg) || this;
        _this.field = field;
        return _this;
    }
    return RequiredError;
}(Error));
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace Account
 */
var Account;
(function (Account) {
    /**
     * @export
     * @enum {string}
     */
    var TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["ASSETS"] = 'ASSETS'] = "ASSETS";
        TypeEnum[TypeEnum["EQUITY"] = 'EQUITY'] = "EQUITY";
        TypeEnum[TypeEnum["LIABILITIES"] = 'LIABILITIES'] = "LIABILITIES";
        TypeEnum[TypeEnum["OPERATINGREVENUES"] = 'OPERATING_REVENUES'] = "OPERATINGREVENUES";
        TypeEnum[TypeEnum["OPERATINGEXPENSES"] = 'OPERATING_EXPENSES'] = "OPERATINGEXPENSES";
        TypeEnum[TypeEnum["INVESTMENTINCOME"] = 'INVESTMENT_INCOME'] = "INVESTMENTINCOME";
        TypeEnum[TypeEnum["COSTOFCAPITAL"] = 'COST_OF_CAPITAL'] = "COSTOFCAPITAL";
        TypeEnum[TypeEnum["TAXONORDINARYACTIVITIES"] = 'TAX_ON_ORDINARY_ACTIVITIES'] = "TAXONORDINARYACTIVITIES";
        TypeEnum[TypeEnum["EXTRAORDINARYINCOME"] = 'EXTRAORDINARY_INCOME'] = "EXTRAORDINARYINCOME";
        TypeEnum[TypeEnum["EXTRAORDINARYCOST"] = 'EXTRAORDINARY_COST'] = "EXTRAORDINARYCOST";
        TypeEnum[TypeEnum["TAXONEXTRAORDINARYACTIVITIES"] = 'TAX_ON_EXTRAORDINARY_ACTIVITIES'] = "TAXONEXTRAORDINARYACTIVITIES";
        TypeEnum[TypeEnum["ANNUALRESULT"] = 'ANNUAL_RESULT'] = "ANNUALRESULT";
        TypeEnum[TypeEnum["TRANSFERSANDALLOCATIONS"] = 'TRANSFERS_AND_ALLOCATIONS'] = "TRANSFERSANDALLOCATIONS";
    })(TypeEnum = Account.TypeEnum || (Account.TypeEnum = {}));
})(Account = exports.Account || (exports.Account = {}));
/**
 * @export
 * @namespace Bank
 */
var Bank;
(function (Bank) {
    /**
     * @export
     * @enum {string}
     */
    var BankStatementFileFormatSupportEnum;
    (function (BankStatementFileFormatSupportEnum) {
        BankStatementFileFormatSupportEnum[BankStatementFileFormatSupportEnum["DANSKEBANKCSV"] = 'DANSKE_BANK_CSV'] = "DANSKEBANKCSV";
        BankStatementFileFormatSupportEnum[BankStatementFileFormatSupportEnum["EIKATELEPAY"] = 'EIKA_TELEPAY'] = "EIKATELEPAY";
    })(BankStatementFileFormatSupportEnum = Bank.BankStatementFileFormatSupportEnum || (Bank.BankStatementFileFormatSupportEnum = {}));
})(Bank = exports.Bank || (exports.Bank = {}));
/**
 * @export
 * @namespace Change
 */
var Change;
(function (Change) {
    /**
     * @export
     * @enum {string}
     */
    var ChangeTypeEnum;
    (function (ChangeTypeEnum) {
        ChangeTypeEnum[ChangeTypeEnum["CREATE"] = 'CREATE'] = "CREATE";
        ChangeTypeEnum[ChangeTypeEnum["UPDATE"] = 'UPDATE'] = "UPDATE";
        ChangeTypeEnum[ChangeTypeEnum["DELETE"] = 'DELETE'] = "DELETE";
    })(ChangeTypeEnum = Change.ChangeTypeEnum || (Change.ChangeTypeEnum = {}));
})(Change = exports.Change || (exports.Change = {}));
/**
 * @export
 * @namespace Company
 */
var Company;
(function (Company) {
    /**
     * @export
     * @enum {string}
     */
    var TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["NONE"] = 'NONE'] = "NONE";
        TypeEnum[TypeEnum["ENK"] = 'ENK'] = "ENK";
        TypeEnum[TypeEnum["AS"] = 'AS'] = "AS";
        TypeEnum[TypeEnum["NUF"] = 'NUF'] = "NUF";
        TypeEnum[TypeEnum["ANS"] = 'ANS'] = "ANS";
        TypeEnum[TypeEnum["DA"] = 'DA'] = "DA";
        TypeEnum[TypeEnum["PRE"] = 'PRE'] = "PRE";
        TypeEnum[TypeEnum["KS"] = 'KS'] = "KS";
        TypeEnum[TypeEnum["ASA"] = 'ASA'] = "ASA";
        TypeEnum[TypeEnum["BBL"] = 'BBL'] = "BBL";
        TypeEnum[TypeEnum["BRL"] = 'BRL'] = "BRL";
        TypeEnum[TypeEnum["GFS"] = 'GFS'] = "GFS";
        TypeEnum[TypeEnum["SPA"] = 'SPA'] = "SPA";
        TypeEnum[TypeEnum["SF"] = 'SF'] = "SF";
        TypeEnum[TypeEnum["IKS"] = 'IKS'] = "IKS";
        TypeEnum[TypeEnum["KFFKF"] = 'KF_FKF'] = "KFFKF";
        TypeEnum[TypeEnum["FCD"] = 'FCD'] = "FCD";
        TypeEnum[TypeEnum["EOFG"] = 'EOFG'] = "EOFG";
        TypeEnum[TypeEnum["BA"] = 'BA'] = "BA";
        TypeEnum[TypeEnum["STI"] = 'STI'] = "STI";
        TypeEnum[TypeEnum["ORG"] = 'ORG'] = "ORG";
        TypeEnum[TypeEnum["ESEK"] = 'ESEK'] = "ESEK";
        TypeEnum[TypeEnum["SAM"] = 'SAM'] = "SAM";
        TypeEnum[TypeEnum["BO"] = 'BO'] = "BO";
        TypeEnum[TypeEnum["VPFO"] = 'VPFO'] = "VPFO";
        TypeEnum[TypeEnum["OS"] = 'OS'] = "OS";
        TypeEnum[TypeEnum["Other"] = 'Other'] = "Other";
    })(TypeEnum = Company.TypeEnum || (Company.TypeEnum = {}));
})(Company = exports.Company || (exports.Company = {}));
/**
 * @export
 * @namespace CustomerTripletexAccount
 */
var CustomerTripletexAccount;
(function (CustomerTripletexAccount) {
    /**
     * @export
     * @enum {string}
     */
    var AccountTypeEnum;
    (function (AccountTypeEnum) {
        AccountTypeEnum[AccountTypeEnum["TEST"] = 'TEST'] = "TEST";
        AccountTypeEnum[AccountTypeEnum["PAYING"] = 'PAYING'] = "PAYING";
    })(AccountTypeEnum = CustomerTripletexAccount.AccountTypeEnum || (CustomerTripletexAccount.AccountTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["NONE"] = 'NONE'] = "NONE";
        TypeEnum[TypeEnum["ENK"] = 'ENK'] = "ENK";
        TypeEnum[TypeEnum["AS"] = 'AS'] = "AS";
        TypeEnum[TypeEnum["NUF"] = 'NUF'] = "NUF";
        TypeEnum[TypeEnum["ANS"] = 'ANS'] = "ANS";
        TypeEnum[TypeEnum["DA"] = 'DA'] = "DA";
        TypeEnum[TypeEnum["PRE"] = 'PRE'] = "PRE";
        TypeEnum[TypeEnum["KS"] = 'KS'] = "KS";
        TypeEnum[TypeEnum["ASA"] = 'ASA'] = "ASA";
        TypeEnum[TypeEnum["BBL"] = 'BBL'] = "BBL";
        TypeEnum[TypeEnum["BRL"] = 'BRL'] = "BRL";
        TypeEnum[TypeEnum["GFS"] = 'GFS'] = "GFS";
        TypeEnum[TypeEnum["SPA"] = 'SPA'] = "SPA";
        TypeEnum[TypeEnum["SF"] = 'SF'] = "SF";
        TypeEnum[TypeEnum["IKS"] = 'IKS'] = "IKS";
        TypeEnum[TypeEnum["KFFKF"] = 'KF_FKF'] = "KFFKF";
        TypeEnum[TypeEnum["FCD"] = 'FCD'] = "FCD";
        TypeEnum[TypeEnum["EOFG"] = 'EOFG'] = "EOFG";
        TypeEnum[TypeEnum["BA"] = 'BA'] = "BA";
        TypeEnum[TypeEnum["STI"] = 'STI'] = "STI";
        TypeEnum[TypeEnum["ORG"] = 'ORG'] = "ORG";
        TypeEnum[TypeEnum["ESEK"] = 'ESEK'] = "ESEK";
        TypeEnum[TypeEnum["SAM"] = 'SAM'] = "SAM";
        TypeEnum[TypeEnum["BO"] = 'BO'] = "BO";
        TypeEnum[TypeEnum["VPFO"] = 'VPFO'] = "VPFO";
        TypeEnum[TypeEnum["OS"] = 'OS'] = "OS";
        TypeEnum[TypeEnum["Other"] = 'Other'] = "Other";
    })(TypeEnum = CustomerTripletexAccount.TypeEnum || (CustomerTripletexAccount.TypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var NumberOfVouchersEnum;
    (function (NumberOfVouchersEnum) {
        NumberOfVouchersEnum[NumberOfVouchersEnum["_0100"] = 'INTERVAL_0_100'] = "_0100";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_101500"] = 'INTERVAL_101_500'] = "_101500";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_0500"] = 'INTERVAL_0_500'] = "_0500";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_5011000"] = 'INTERVAL_501_1000'] = "_5011000";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_10012000"] = 'INTERVAL_1001_2000'] = "_10012000";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_20013500"] = 'INTERVAL_2001_3500'] = "_20013500";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_35015000"] = 'INTERVAL_3501_5000'] = "_35015000";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_500110000"] = 'INTERVAL_5001_10000'] = "_500110000";
        NumberOfVouchersEnum[NumberOfVouchersEnum["UNLIMITED"] = 'INTERVAL_UNLIMITED'] = "UNLIMITED";
    })(NumberOfVouchersEnum = CustomerTripletexAccount.NumberOfVouchersEnum || (CustomerTripletexAccount.NumberOfVouchersEnum = {}));
})(CustomerTripletexAccount = exports.CustomerTripletexAccount || (exports.CustomerTripletexAccount = {}));
/**
 * @export
 * @namespace Employee
 */
var Employee;
(function (Employee) {
    /**
     * @export
     * @enum {string}
     */
    var UserTypeEnum;
    (function (UserTypeEnum) {
        UserTypeEnum[UserTypeEnum["STANDARD"] = 'STANDARD'] = "STANDARD";
        UserTypeEnum[UserTypeEnum["EXTENDED"] = 'EXTENDED'] = "EXTENDED";
        UserTypeEnum[UserTypeEnum["NOACCESS"] = 'NO_ACCESS'] = "NOACCESS";
    })(UserTypeEnum = Employee.UserTypeEnum || (Employee.UserTypeEnum = {}));
})(Employee = exports.Employee || (exports.Employee = {}));
/**
 * @export
 * @namespace EmploymentType
 */
var EmploymentType;
(function (EmploymentType) {
    /**
     * @export
     * @enum {string}
     */
    var EmploymentTypeEnum;
    (function (EmploymentTypeEnum) {
        EmploymentTypeEnum[EmploymentTypeEnum["RELATIONSHIP"] = 'TYPE_OF_EMPLOYMENT_RELATIONSHIP'] = "RELATIONSHIP";
    })(EmploymentTypeEnum = EmploymentType.EmploymentTypeEnum || (EmploymentType.EmploymentTypeEnum = {}));
})(EmploymentType = exports.EmploymentType || (exports.EmploymentType = {}));
/**
 * @export
 * @namespace Invoice
 */
var Invoice;
(function (Invoice) {
    /**
     * @export
     * @enum {string}
     */
    var EhfSendStatusEnum;
    (function (EhfSendStatusEnum) {
        EhfSendStatusEnum[EhfSendStatusEnum["DONOTSEND"] = 'DO_NOT_SEND'] = "DONOTSEND";
        EhfSendStatusEnum[EhfSendStatusEnum["SEND"] = 'SEND'] = "SEND";
        EhfSendStatusEnum[EhfSendStatusEnum["SENT"] = 'SENT'] = "SENT";
        EhfSendStatusEnum[EhfSendStatusEnum["SENDFAILURERECIPIENTNOTFOUND"] = 'SEND_FAILURE_RECIPIENT_NOT_FOUND'] = "SENDFAILURERECIPIENTNOTFOUND";
    })(EhfSendStatusEnum = Invoice.EhfSendStatusEnum || (Invoice.EhfSendStatusEnum = {}));
})(Invoice = exports.Invoice || (exports.Invoice = {}));
/**
 * @export
 * @namespace LeaveOfAbsenceType
 */
var LeaveOfAbsenceType;
(function (LeaveOfAbsenceType) {
    /**
     * @export
     * @enum {string}
     */
    var LeaveOfAbsenceTypeEnum;
    (function (LeaveOfAbsenceTypeEnum) {
        LeaveOfAbsenceTypeEnum[LeaveOfAbsenceTypeEnum["TYPE"] = 'LEAVE_OF_ABSENCE_TYPE'] = "TYPE";
    })(LeaveOfAbsenceTypeEnum = LeaveOfAbsenceType.LeaveOfAbsenceTypeEnum || (LeaveOfAbsenceType.LeaveOfAbsenceTypeEnum = {}));
})(LeaveOfAbsenceType = exports.LeaveOfAbsenceType || (exports.LeaveOfAbsenceType = {}));
/**
 * @export
 * @namespace Link
 */
var Link;
(function (Link) {
    /**
     * @export
     * @enum {string}
     */
    var TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["POST"] = 'POST'] = "POST";
        TypeEnum[TypeEnum["PUT"] = 'PUT'] = "PUT";
        TypeEnum[TypeEnum["GET"] = 'GET'] = "GET";
        TypeEnum[TypeEnum["DELETE"] = 'DELETE'] = "DELETE";
    })(TypeEnum = Link.TypeEnum || (Link.TypeEnum = {}));
})(Link = exports.Link || (exports.Link = {}));
/**
 * @export
 * @namespace Order
 */
var Order;
(function (Order) {
    /**
     * @export
     * @enum {string}
     */
    var InvoicesDueInTypeEnum;
    (function (InvoicesDueInTypeEnum) {
        InvoicesDueInTypeEnum[InvoicesDueInTypeEnum["DAYS"] = 'DAYS'] = "DAYS";
        InvoicesDueInTypeEnum[InvoicesDueInTypeEnum["MONTHS"] = 'MONTHS'] = "MONTHS";
        InvoicesDueInTypeEnum[InvoicesDueInTypeEnum["RECURRINGDAYOFMONTH"] = 'RECURRING_DAY_OF_MONTH'] = "RECURRINGDAYOFMONTH";
    })(InvoicesDueInTypeEnum = Order.InvoicesDueInTypeEnum || (Order.InvoicesDueInTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var OrderLineSortingEnum;
    (function (OrderLineSortingEnum) {
        OrderLineSortingEnum[OrderLineSortingEnum["ID"] = 'ID'] = "ID";
        OrderLineSortingEnum[OrderLineSortingEnum["PRODUCT"] = 'PRODUCT'] = "PRODUCT";
        OrderLineSortingEnum[OrderLineSortingEnum["CUSTOM"] = 'CUSTOM'] = "CUSTOM";
    })(OrderLineSortingEnum = Order.OrderLineSortingEnum || (Order.OrderLineSortingEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var SubscriptionDurationTypeEnum;
    (function (SubscriptionDurationTypeEnum) {
        SubscriptionDurationTypeEnum[SubscriptionDurationTypeEnum["MONTHS"] = 'MONTHS'] = "MONTHS";
        SubscriptionDurationTypeEnum[SubscriptionDurationTypeEnum["YEAR"] = 'YEAR'] = "YEAR";
    })(SubscriptionDurationTypeEnum = Order.SubscriptionDurationTypeEnum || (Order.SubscriptionDurationTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var SubscriptionPeriodsOnInvoiceTypeEnum;
    (function (SubscriptionPeriodsOnInvoiceTypeEnum) {
        SubscriptionPeriodsOnInvoiceTypeEnum[SubscriptionPeriodsOnInvoiceTypeEnum["MONTHS"] = 'MONTHS'] = "MONTHS";
    })(SubscriptionPeriodsOnInvoiceTypeEnum = Order.SubscriptionPeriodsOnInvoiceTypeEnum || (Order.SubscriptionPeriodsOnInvoiceTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var SubscriptionInvoicingTimeInAdvanceOrArrearsEnum;
    (function (SubscriptionInvoicingTimeInAdvanceOrArrearsEnum) {
        SubscriptionInvoicingTimeInAdvanceOrArrearsEnum[SubscriptionInvoicingTimeInAdvanceOrArrearsEnum["ADVANCE"] = 'ADVANCE'] = "ADVANCE";
        SubscriptionInvoicingTimeInAdvanceOrArrearsEnum[SubscriptionInvoicingTimeInAdvanceOrArrearsEnum["ARREARS"] = 'ARREARS'] = "ARREARS";
    })(SubscriptionInvoicingTimeInAdvanceOrArrearsEnum = Order.SubscriptionInvoicingTimeInAdvanceOrArrearsEnum || (Order.SubscriptionInvoicingTimeInAdvanceOrArrearsEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var SubscriptionInvoicingTimeTypeEnum;
    (function (SubscriptionInvoicingTimeTypeEnum) {
        SubscriptionInvoicingTimeTypeEnum[SubscriptionInvoicingTimeTypeEnum["DAYS"] = 'DAYS'] = "DAYS";
        SubscriptionInvoicingTimeTypeEnum[SubscriptionInvoicingTimeTypeEnum["MONTHS"] = 'MONTHS'] = "MONTHS";
    })(SubscriptionInvoicingTimeTypeEnum = Order.SubscriptionInvoicingTimeTypeEnum || (Order.SubscriptionInvoicingTimeTypeEnum = {}));
})(Order = exports.Order || (exports.Order = {}));
/**
 * @export
 * @namespace PerDiemCompensation
 */
var PerDiemCompensation;
(function (PerDiemCompensation) {
    /**
     * @export
     * @enum {string}
     */
    var OvernightAccommodationEnum;
    (function (OvernightAccommodationEnum) {
        OvernightAccommodationEnum[OvernightAccommodationEnum["NONE"] = 'NONE'] = "NONE";
        OvernightAccommodationEnum[OvernightAccommodationEnum["HOTEL"] = 'HOTEL'] = "HOTEL";
        OvernightAccommodationEnum[OvernightAccommodationEnum["BOARDINGHOUSEWITHOUTCOOKING"] = 'BOARDING_HOUSE_WITHOUT_COOKING'] = "BOARDINGHOUSEWITHOUTCOOKING";
        OvernightAccommodationEnum[OvernightAccommodationEnum["BOARDINGHOUSEWITHCOOKING"] = 'BOARDING_HOUSE_WITH_COOKING'] = "BOARDINGHOUSEWITHCOOKING";
    })(OvernightAccommodationEnum = PerDiemCompensation.OvernightAccommodationEnum || (PerDiemCompensation.OvernightAccommodationEnum = {}));
})(PerDiemCompensation = exports.PerDiemCompensation || (exports.PerDiemCompensation = {}));
/**
 * @export
 * @namespace Project
 */
var Project;
(function (Project) {
    /**
     * @export
     * @enum {string}
     */
    var DisplayNameFormatEnum;
    (function (DisplayNameFormatEnum) {
        DisplayNameFormatEnum[DisplayNameFormatEnum["STANDARD"] = 'NAME_STANDARD'] = "STANDARD";
        DisplayNameFormatEnum[DisplayNameFormatEnum["INCLCUSTOMERNAME"] = 'NAME_INCL_CUSTOMER_NAME'] = "INCLCUSTOMERNAME";
        DisplayNameFormatEnum[DisplayNameFormatEnum["INCLPARENTNAME"] = 'NAME_INCL_PARENT_NAME'] = "INCLPARENTNAME";
        DisplayNameFormatEnum[DisplayNameFormatEnum["INCLPARENTNUMBER"] = 'NAME_INCL_PARENT_NUMBER'] = "INCLPARENTNUMBER";
        DisplayNameFormatEnum[DisplayNameFormatEnum["INCLPARENTNAMEANDNUMBER"] = 'NAME_INCL_PARENT_NAME_AND_NUMBER'] = "INCLPARENTNAMEANDNUMBER";
    })(DisplayNameFormatEnum = Project.DisplayNameFormatEnum || (Project.DisplayNameFormatEnum = {}));
})(Project = exports.Project || (exports.Project = {}));
/**
 * @export
 * @namespace RemunerationType
 */
var RemunerationType;
(function (RemunerationType) {
    /**
     * @export
     * @enum {string}
     */
    var RemunerationTypeEnum;
    (function (RemunerationTypeEnum) {
        RemunerationTypeEnum[RemunerationTypeEnum["TYPE"] = 'REMUNERATION_TYPE'] = "TYPE";
    })(RemunerationTypeEnum = RemunerationType.RemunerationTypeEnum || (RemunerationType.RemunerationTypeEnum = {}));
})(RemunerationType = exports.RemunerationType || (exports.RemunerationType = {}));
/**
 * @export
 * @namespace Result
 */
var Result;
(function (Result) {
    /**
     * @export
     * @enum {string}
     */
    var FileEnum;
    (function (FileEnum) {
        FileEnum[FileEnum["DEPARTMENTS"] = 'DEPARTMENTS'] = "DEPARTMENTS";
        FileEnum[FileEnum["EMPLOYEES"] = 'EMPLOYEES'] = "EMPLOYEES";
        FileEnum[FileEnum["VATCODES"] = 'VATCODES'] = "VATCODES";
        FileEnum[FileEnum["ACCOUNTS"] = 'ACCOUNTS'] = "ACCOUNTS";
        FileEnum[FileEnum["CUSTOMERS"] = 'CUSTOMERS'] = "CUSTOMERS";
        FileEnum[FileEnum["CUSTOMERSCATEGORIES"] = 'CUSTOMERS_CATEGORIES'] = "CUSTOMERSCATEGORIES";
        FileEnum[FileEnum["VENDORS"] = 'VENDORS'] = "VENDORS";
        FileEnum[FileEnum["VENDORSCATEGORIES"] = 'VENDORS_CATEGORIES'] = "VENDORSCATEGORIES";
        FileEnum[FileEnum["CONTACTS"] = 'CONTACTS'] = "CONTACTS";
        FileEnum[FileEnum["DELIVERYADDRESSES"] = 'DELIVERY_ADDRESSES'] = "DELIVERYADDRESSES";
        FileEnum[FileEnum["PRODUCTS"] = 'PRODUCTS'] = "PRODUCTS";
        FileEnum[FileEnum["PRODUCTSCATEGORIES"] = 'PRODUCTS_CATEGORIES'] = "PRODUCTSCATEGORIES";
        FileEnum[FileEnum["PROJECTS"] = 'PROJECTS'] = "PROJECTS";
        FileEnum[FileEnum["PROJECTSCATEGORIES"] = 'PROJECTS_CATEGORIES'] = "PROJECTSCATEGORIES";
    })(FileEnum = Result.FileEnum || (Result.FileEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["IGNORED"] = 'IGNORED'] = "IGNORED";
        TypeEnum[TypeEnum["UPDATED"] = 'UPDATED'] = "UPDATED";
        TypeEnum[TypeEnum["CREATED"] = 'CREATED'] = "CREATED";
        TypeEnum[TypeEnum["ERROR"] = 'ERROR'] = "ERROR";
    })(TypeEnum = Result.TypeEnum || (Result.TypeEnum = {}));
})(Result = exports.Result || (exports.Result = {}));
/**
 * @export
 * @namespace Subscription
 */
var Subscription;
(function (Subscription) {
    /**
     * @export
     * @enum {string}
     */
    var StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["ACTIVE"] = 'ACTIVE'] = "ACTIVE";
        StatusEnum[StatusEnum["DISABLED"] = 'DISABLED'] = "DISABLED";
        StatusEnum[StatusEnum["DISABLEDTOOMANYERRORS"] = 'DISABLED_TOO_MANY_ERRORS'] = "DISABLEDTOOMANYERRORS";
        StatusEnum[StatusEnum["DISABLEDRATELIMITEXCEEDED"] = 'DISABLED_RATE_LIMIT_EXCEEDED'] = "DISABLEDRATELIMITEXCEEDED";
        StatusEnum[StatusEnum["DISABLEDMISUSE"] = 'DISABLED_MISUSE'] = "DISABLEDMISUSE";
    })(StatusEnum = Subscription.StatusEnum || (Subscription.StatusEnum = {}));
})(Subscription = exports.Subscription || (exports.Subscription = {}));
/**
 * @export
 * @namespace TravelExpense
 */
var TravelExpense;
(function (TravelExpense) {
    /**
     * @export
     * @enum {string}
     */
    var StateEnum;
    (function (StateEnum) {
        StateEnum[StateEnum["ALL"] = 'ALL'] = "ALL";
        StateEnum[StateEnum["OPEN"] = 'OPEN'] = "OPEN";
        StateEnum[StateEnum["APPROVED"] = 'APPROVED'] = "APPROVED";
        StateEnum[StateEnum["SALARYPAID"] = 'SALARY_PAID'] = "SALARYPAID";
        StateEnum[StateEnum["DELIVERED"] = 'DELIVERED'] = "DELIVERED";
    })(StateEnum = TravelExpense.StateEnum || (TravelExpense.StateEnum = {}));
})(TravelExpense = exports.TravelExpense || (exports.TravelExpense = {}));
/**
 * @export
 * @namespace TravelExpenseRateCategory
 */
var TravelExpenseRateCategory;
(function (TravelExpenseRateCategory) {
    /**
     * @export
     * @enum {string}
     */
    var TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["PERDIEM"] = 'PER_DIEM'] = "PERDIEM";
        TypeEnum[TypeEnum["ACCOMMODATIONALLOWANCE"] = 'ACCOMMODATION_ALLOWANCE'] = "ACCOMMODATIONALLOWANCE";
        TypeEnum[TypeEnum["MILEAGEALLOWANCE"] = 'MILEAGE_ALLOWANCE'] = "MILEAGEALLOWANCE";
    })(TypeEnum = TravelExpenseRateCategory.TypeEnum || (TravelExpenseRateCategory.TypeEnum = {}));
})(TravelExpenseRateCategory = exports.TravelExpenseRateCategory || (exports.TravelExpenseRateCategory = {}));
/**
 * @export
 * @namespace TripletexAccount
 */
var TripletexAccount;
(function (TripletexAccount) {
    /**
     * @export
     * @enum {string}
     */
    var AccountTypeEnum;
    (function (AccountTypeEnum) {
        AccountTypeEnum[AccountTypeEnum["TEST"] = 'TEST'] = "TEST";
        AccountTypeEnum[AccountTypeEnum["PAYING"] = 'PAYING'] = "PAYING";
    })(AccountTypeEnum = TripletexAccount.AccountTypeEnum || (TripletexAccount.AccountTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var NumberOfVouchersEnum;
    (function (NumberOfVouchersEnum) {
        NumberOfVouchersEnum[NumberOfVouchersEnum["_0100"] = 'INTERVAL_0_100'] = "_0100";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_101500"] = 'INTERVAL_101_500'] = "_101500";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_0500"] = 'INTERVAL_0_500'] = "_0500";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_5011000"] = 'INTERVAL_501_1000'] = "_5011000";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_10012000"] = 'INTERVAL_1001_2000'] = "_10012000";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_20013500"] = 'INTERVAL_2001_3500'] = "_20013500";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_35015000"] = 'INTERVAL_3501_5000'] = "_35015000";
        NumberOfVouchersEnum[NumberOfVouchersEnum["_500110000"] = 'INTERVAL_5001_10000'] = "_500110000";
        NumberOfVouchersEnum[NumberOfVouchersEnum["UNLIMITED"] = 'INTERVAL_UNLIMITED'] = "UNLIMITED";
    })(NumberOfVouchersEnum = TripletexAccount.NumberOfVouchersEnum || (TripletexAccount.NumberOfVouchersEnum = {}));
})(TripletexAccount = exports.TripletexAccount || (exports.TripletexAccount = {}));
/**
 * @export
 * @namespace WorkingHoursScheme
 */
var WorkingHoursScheme;
(function (WorkingHoursScheme) {
    /**
     * @export
     * @enum {string}
     */
    var WorkingHoursSchemeEnum;
    (function (WorkingHoursSchemeEnum) {
        WorkingHoursSchemeEnum[WorkingHoursSchemeEnum["SCHEME"] = 'WORKING_HOURS_SCHEME'] = "SCHEME";
    })(WorkingHoursSchemeEnum = WorkingHoursScheme.WorkingHoursSchemeEnum || (WorkingHoursScheme.WorkingHoursSchemeEnum = {}));
})(WorkingHoursScheme = exports.WorkingHoursScheme || (exports.WorkingHoursScheme = {}));
/**
 * ActivityApi - fetch parameter creator
 * @export
 */
exports.ActivityApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Find activity by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/activity/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find applicable time sheet activities for an employee on a specific day.
         * @param {number} projectId Project ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet: function (projectId, employeeId, date, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getForTimeSheet.');
            }
            var localVarPath = "/activity/>forTimeSheet";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find activities corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {boolean} [isProjectActivity] Equals
         * @param {boolean} [isGeneral] Equals
         * @param {boolean} [isChargeable] Equals
         * @param {boolean} [isTask] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, description, isProjectActivity, isGeneral, isChargeable, isTask, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/activity";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (isProjectActivity !== undefined) {
                localVarQueryParameter['isProjectActivity'] = isProjectActivity;
            }
            if (isGeneral !== undefined) {
                localVarQueryParameter['isGeneral'] = isGeneral;
            }
            if (isChargeable !== undefined) {
                localVarQueryParameter['isChargeable'] = isChargeable;
            }
            if (isTask !== undefined) {
                localVarQueryParameter['isTask'] = isTask;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivityApi - functional programming interface
 * @export
 */
exports.ActivityApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Find activity by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.ActivityApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find applicable time sheet activities for an employee on a specific day.
         * @param {number} projectId Project ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet: function (projectId, employeeId, date, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.ActivityApiFetchParamCreator(configuration).getForTimeSheet(projectId, employeeId, date, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find activities corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {boolean} [isProjectActivity] Equals
         * @param {boolean} [isGeneral] Equals
         * @param {boolean} [isChargeable] Equals
         * @param {boolean} [isTask] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, description, isProjectActivity, isGeneral, isChargeable, isTask, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.ActivityApiFetchParamCreator(configuration).search(id, name, number, description, isProjectActivity, isGeneral, isChargeable, isTask, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ActivityApi - factory interface
 * @export
 */
exports.ActivityApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Find activity by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.ActivityApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find applicable time sheet activities for an employee on a specific day.
         * @param {number} projectId Project ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet: function (projectId, employeeId, date, from, count, sorting, fields, options) {
            return exports.ActivityApiFp(configuration).getForTimeSheet(projectId, employeeId, date, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find activities corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {boolean} [isProjectActivity] Equals
         * @param {boolean} [isGeneral] Equals
         * @param {boolean} [isChargeable] Equals
         * @param {boolean} [isTask] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, description, isProjectActivity, isGeneral, isChargeable, isTask, from, count, sorting, fields, options) {
            return exports.ActivityApiFp(configuration).search(id, name, number, description, isProjectActivity, isGeneral, isChargeable, isTask, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
var ActivityApi = /** @class */ (function (_super) {
    __extends(ActivityApi, _super);
    function ActivityApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Find activity by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    ActivityApi.prototype.get = function (id, fields, options) {
        return exports.ActivityApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find applicable time sheet activities for an employee on a specific day.
     * @param {number} projectId Project ID
     * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {string} [date] yyyy-MM-dd. Defaults to today.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    ActivityApi.prototype.getForTimeSheet = function (projectId, employeeId, date, from, count, sorting, fields, options) {
        return exports.ActivityApiFp(this.configuration).getForTimeSheet(projectId, employeeId, date, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find activities corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [name] Containing
     * @param {string} [number] Equals
     * @param {string} [description] Containing
     * @param {boolean} [isProjectActivity] Equals
     * @param {boolean} [isGeneral] Equals
     * @param {boolean} [isChargeable] Equals
     * @param {boolean} [isTask] Equals
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    ActivityApi.prototype.search = function (id, name, number, description, isProjectActivity, isGeneral, isChargeable, isTask, from, count, sorting, fields, options) {
        return exports.ActivityApiFp(this.configuration).search(id, name, number, description, isProjectActivity, isGeneral, isChargeable, isTask, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return ActivityApi;
}(BaseAPI));
exports.ActivityApi = ActivityApi;
/**
 * AddressApi - fetch parameter creator
 * @export
 */
exports.AddressApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get address by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/address/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update address.
         * @param {number} id Element ID
         * @param {Address} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/address/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Address" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find addresses corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [addressLine1] List of IDs
         * @param {string} [addressLine2] List of IDs
         * @param {string} [postalCode] List of IDs
         * @param {string} [city] List of IDs
         * @param {string} [name] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, addressLine1, addressLine2, postalCode, city, name, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/address";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (addressLine1 !== undefined) {
                localVarQueryParameter['addressLine1'] = addressLine1;
            }
            if (addressLine2 !== undefined) {
                localVarQueryParameter['addressLine2'] = addressLine2;
            }
            if (postalCode !== undefined) {
                localVarQueryParameter['postalCode'] = postalCode;
            }
            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AddressApi - functional programming interface
 * @export
 */
exports.AddressApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get address by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.AddressApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update address.
         * @param {number} id Element ID
         * @param {Address} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.AddressApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find addresses corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [addressLine1] List of IDs
         * @param {string} [addressLine2] List of IDs
         * @param {string} [postalCode] List of IDs
         * @param {string} [city] List of IDs
         * @param {string} [name] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, addressLine1, addressLine2, postalCode, city, name, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.AddressApiFetchParamCreator(configuration).search(id, addressLine1, addressLine2, postalCode, city, name, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AddressApi - factory interface
 * @export
 */
exports.AddressApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get address by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.AddressApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update address.
         * @param {number} id Element ID
         * @param {Address} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.AddressApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find addresses corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [addressLine1] List of IDs
         * @param {string} [addressLine2] List of IDs
         * @param {string} [postalCode] List of IDs
         * @param {string} [city] List of IDs
         * @param {string} [name] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, addressLine1, addressLine2, postalCode, city, name, from, count, sorting, fields, options) {
            return exports.AddressApiFp(configuration).search(id, addressLine1, addressLine2, postalCode, city, name, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
var AddressApi = /** @class */ (function (_super) {
    __extends(AddressApi, _super);
    function AddressApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get address by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    AddressApi.prototype.get = function (id, fields, options) {
        return exports.AddressApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update address.
     * @param {number} id Element ID
     * @param {Address} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    AddressApi.prototype.put = function (id, body, options) {
        return exports.AddressApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find addresses corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [addressLine1] List of IDs
     * @param {string} [addressLine2] List of IDs
     * @param {string} [postalCode] List of IDs
     * @param {string} [city] List of IDs
     * @param {string} [name] List of IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    AddressApi.prototype.search = function (id, addressLine1, addressLine2, postalCode, city, name, from, count, sorting, fields, options) {
        return exports.AddressApiFp(this.configuration).search(id, addressLine1, addressLine2, postalCode, city, name, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return AddressApi;
}(BaseAPI));
exports.AddressApi = AddressApi;
/**
 * BankApi - fetch parameter creator
 * @export
 */
exports.BankApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find bank corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [registerNumbers] Bank register number (four digits)
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, registerNumbers, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/bank";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (registerNumbers !== undefined) {
                localVarQueryParameter['registerNumbers'] = registerNumbers;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BankApi - functional programming interface
 * @export
 */
exports.BankApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find bank corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [registerNumbers] Bank register number (four digits)
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, registerNumbers, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.BankApiFetchParamCreator(configuration).search(id, registerNumbers, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * BankApi - factory interface
 * @export
 */
exports.BankApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find bank corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [registerNumbers] Bank register number (four digits)
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, registerNumbers, from, count, sorting, fields, options) {
            return exports.BankApiFp(configuration).search(id, registerNumbers, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * BankApi - object-oriented interface
 * @export
 * @class BankApi
 * @extends {BaseAPI}
 */
var BankApi = /** @class */ (function (_super) {
    __extends(BankApi, _super);
    function BankApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find bank corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [registerNumbers] Bank register number (four digits)
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    BankApi.prototype.search = function (id, registerNumbers, from, count, sorting, fields, options) {
        return exports.BankApiFp(this.configuration).search(id, registerNumbers, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return BankApi;
}(BaseAPI));
exports.BankApi = BankApi;
/**
 * BankreconciliationApi - fetch parameter creator
 * @export
 */
exports.BankreconciliationApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete bank reconciliation by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/bank/reconciliation/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Add an adjustment to reconciliation by ID.
         * @param {number} id Element ID
         * @param {number} paymentTypeId Bank reconciliation PaymentType ID.
         * @param {string} postingDate Format is yyyy-MM-dd
         * @param {number} amount Amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustment: function (id, paymentTypeId, postingDate, amount, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling adjustment.');
            }
            // verify required parameter 'paymentTypeId' is not null or undefined
            if (paymentTypeId === null || paymentTypeId === undefined) {
                throw new RequiredError('paymentTypeId', 'Required parameter paymentTypeId was null or undefined when calling adjustment.');
            }
            // verify required parameter 'postingDate' is not null or undefined
            if (postingDate === null || postingDate === undefined) {
                throw new RequiredError('postingDate', 'Required parameter postingDate was null or undefined when calling adjustment.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount', 'Required parameter amount was null or undefined when calling adjustment.');
            }
            var localVarPath = "/bank/reconciliation/{id}/:adjustment"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (paymentTypeId !== undefined) {
                localVarQueryParameter['paymentTypeId'] = paymentTypeId;
            }
            if (postingDate !== undefined) {
                localVarQueryParameter['postingDate'] = postingDate;
            }
            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get bank reconciliation.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/bank/reconciliation/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get last closed reconciliation by account ID.
         * @param {number} accountId Account ID
         * @param {string} [after] Format is yyyy-MM-dd
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastClosed: function (accountId, after, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling lastClosed.');
            }
            var localVarPath = "/bank/reconciliation/>lastClosed";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Post a bank reconciliation.
         * @param {BankReconciliation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/bank/reconciliation";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("BankReconciliation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update a bank reconciliation.
         * @param {number} id Element ID
         * @param {BankReconciliation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/bank/reconciliation/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("BankReconciliation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find bank reconciliation corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [accountingPeriodId] List of IDs
         * @param {string} [accountId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, accountingPeriodId, accountId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/bank/reconciliation";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (accountingPeriodId !== undefined) {
                localVarQueryParameter['accountingPeriodId'] = accountingPeriodId;
            }
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BankreconciliationApi - functional programming interface
 * @export
 */
exports.BankreconciliationApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete bank reconciliation by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.BankreconciliationApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Add an adjustment to reconciliation by ID.
         * @param {number} id Element ID
         * @param {number} paymentTypeId Bank reconciliation PaymentType ID.
         * @param {string} postingDate Format is yyyy-MM-dd
         * @param {number} amount Amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustment: function (id, paymentTypeId, postingDate, amount, options) {
            var localVarFetchArgs = exports.BankreconciliationApiFetchParamCreator(configuration).adjustment(id, paymentTypeId, postingDate, amount, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get bank reconciliation.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.BankreconciliationApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get last closed reconciliation by account ID.
         * @param {number} accountId Account ID
         * @param {string} [after] Format is yyyy-MM-dd
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastClosed: function (accountId, after, fields, options) {
            var localVarFetchArgs = exports.BankreconciliationApiFetchParamCreator(configuration).lastClosed(accountId, after, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Post a bank reconciliation.
         * @param {BankReconciliation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.BankreconciliationApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update a bank reconciliation.
         * @param {number} id Element ID
         * @param {BankReconciliation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.BankreconciliationApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find bank reconciliation corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [accountingPeriodId] List of IDs
         * @param {string} [accountId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, accountingPeriodId, accountId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.BankreconciliationApiFetchParamCreator(configuration).search(id, accountingPeriodId, accountId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * BankreconciliationApi - factory interface
 * @export
 */
exports.BankreconciliationApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete bank reconciliation by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.BankreconciliationApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Add an adjustment to reconciliation by ID.
         * @param {number} id Element ID
         * @param {number} paymentTypeId Bank reconciliation PaymentType ID.
         * @param {string} postingDate Format is yyyy-MM-dd
         * @param {number} amount Amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustment: function (id, paymentTypeId, postingDate, amount, options) {
            return exports.BankreconciliationApiFp(configuration).adjustment(id, paymentTypeId, postingDate, amount, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get bank reconciliation.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.BankreconciliationApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get last closed reconciliation by account ID.
         * @param {number} accountId Account ID
         * @param {string} [after] Format is yyyy-MM-dd
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastClosed: function (accountId, after, fields, options) {
            return exports.BankreconciliationApiFp(configuration).lastClosed(accountId, after, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Post a bank reconciliation.
         * @param {BankReconciliation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.BankreconciliationApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update a bank reconciliation.
         * @param {number} id Element ID
         * @param {BankReconciliation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.BankreconciliationApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find bank reconciliation corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [accountingPeriodId] List of IDs
         * @param {string} [accountId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, accountingPeriodId, accountId, from, count, sorting, fields, options) {
            return exports.BankreconciliationApiFp(configuration).search(id, accountingPeriodId, accountId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * BankreconciliationApi - object-oriented interface
 * @export
 * @class BankreconciliationApi
 * @extends {BaseAPI}
 */
var BankreconciliationApi = /** @class */ (function (_super) {
    __extends(BankreconciliationApi, _super);
    function BankreconciliationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete bank reconciliation by ID.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    BankreconciliationApi.prototype._delete = function (id, options) {
        return exports.BankreconciliationApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Add an adjustment to reconciliation by ID.
     * @param {number} id Element ID
     * @param {number} paymentTypeId Bank reconciliation PaymentType ID.
     * @param {string} postingDate Format is yyyy-MM-dd
     * @param {number} amount Amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    BankreconciliationApi.prototype.adjustment = function (id, paymentTypeId, postingDate, amount, options) {
        return exports.BankreconciliationApiFp(this.configuration).adjustment(id, paymentTypeId, postingDate, amount, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get bank reconciliation.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    BankreconciliationApi.prototype.get = function (id, fields, options) {
        return exports.BankreconciliationApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get last closed reconciliation by account ID.
     * @param {number} accountId Account ID
     * @param {string} [after] Format is yyyy-MM-dd
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    BankreconciliationApi.prototype.lastClosed = function (accountId, after, fields, options) {
        return exports.BankreconciliationApiFp(this.configuration).lastClosed(accountId, after, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Post a bank reconciliation.
     * @param {BankReconciliation} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    BankreconciliationApi.prototype.post = function (body, options) {
        return exports.BankreconciliationApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update a bank reconciliation.
     * @param {number} id Element ID
     * @param {BankReconciliation} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    BankreconciliationApi.prototype.put = function (id, body, options) {
        return exports.BankreconciliationApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find bank reconciliation corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [accountingPeriodId] List of IDs
     * @param {string} [accountId] List of IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationApi
     */
    BankreconciliationApi.prototype.search = function (id, accountingPeriodId, accountId, from, count, sorting, fields, options) {
        return exports.BankreconciliationApiFp(this.configuration).search(id, accountingPeriodId, accountId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return BankreconciliationApi;
}(BaseAPI));
exports.BankreconciliationApi = BankreconciliationApi;
/**
 * BankreconciliationmatchApi - fetch parameter creator
 * @export
 */
exports.BankreconciliationmatchApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/bank/reconciliation/match/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/bank/reconciliation/match/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create a bank reconciliation match.
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/bank/reconciliation/match";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("BankReconciliationMatch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/bank/reconciliation/match/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("BankReconciliationMatch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find bank reconciliation match corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [bankReconciliationId] List of bank reconciliation IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, bankReconciliationId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/bank/reconciliation/match";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (bankReconciliationId !== undefined) {
                localVarQueryParameter['bankReconciliationId'] = bankReconciliationId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BankreconciliationmatchApi - functional programming interface
 * @export
 */
exports.BankreconciliationmatchApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.BankreconciliationmatchApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.BankreconciliationmatchApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create a bank reconciliation match.
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.BankreconciliationmatchApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.BankreconciliationmatchApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find bank reconciliation match corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [bankReconciliationId] List of bank reconciliation IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, bankReconciliationId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.BankreconciliationmatchApiFetchParamCreator(configuration).search(id, bankReconciliationId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * BankreconciliationmatchApi - factory interface
 * @export
 */
exports.BankreconciliationmatchApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.BankreconciliationmatchApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.BankreconciliationmatchApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create a bank reconciliation match.
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.BankreconciliationmatchApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update a bank reconciliation match by ID.
         * @param {number} id Element ID
         * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.BankreconciliationmatchApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find bank reconciliation match corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [bankReconciliationId] List of bank reconciliation IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, bankReconciliationId, from, count, sorting, fields, options) {
            return exports.BankreconciliationmatchApiFp(configuration).search(id, bankReconciliationId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * BankreconciliationmatchApi - object-oriented interface
 * @export
 * @class BankreconciliationmatchApi
 * @extends {BaseAPI}
 */
var BankreconciliationmatchApi = /** @class */ (function (_super) {
    __extends(BankreconciliationmatchApi, _super);
    function BankreconciliationmatchApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete a bank reconciliation match by ID.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationmatchApi
     */
    BankreconciliationmatchApi.prototype._delete = function (id, options) {
        return exports.BankreconciliationmatchApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get bank reconciliation match by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationmatchApi
     */
    BankreconciliationmatchApi.prototype.get = function (id, fields, options) {
        return exports.BankreconciliationmatchApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create a bank reconciliation match.
     * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationmatchApi
     */
    BankreconciliationmatchApi.prototype.post = function (body, options) {
        return exports.BankreconciliationmatchApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update a bank reconciliation match by ID.
     * @param {number} id Element ID
     * @param {BankReconciliationMatch} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationmatchApi
     */
    BankreconciliationmatchApi.prototype.put = function (id, body, options) {
        return exports.BankreconciliationmatchApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find bank reconciliation match corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [bankReconciliationId] List of bank reconciliation IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationmatchApi
     */
    BankreconciliationmatchApi.prototype.search = function (id, bankReconciliationId, from, count, sorting, fields, options) {
        return exports.BankreconciliationmatchApiFp(this.configuration).search(id, bankReconciliationId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return BankreconciliationmatchApi;
}(BaseAPI));
exports.BankreconciliationmatchApi = BankreconciliationmatchApi;
/**
 * BankreconciliationpaymentTypeApi - fetch parameter creator
 * @export
 */
exports.BankreconciliationpaymentTypeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/bank/reconciliation/paymentType/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/bank/reconciliation/paymentType";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BankreconciliationpaymentTypeApi - functional programming interface
 * @export
 */
exports.BankreconciliationpaymentTypeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.BankreconciliationpaymentTypeApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.BankreconciliationpaymentTypeApiFetchParamCreator(configuration).search(id, description, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * BankreconciliationpaymentTypeApi - factory interface
 * @export
 */
exports.BankreconciliationpaymentTypeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.BankreconciliationpaymentTypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            return exports.BankreconciliationpaymentTypeApiFp(configuration).search(id, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * BankreconciliationpaymentTypeApi - object-oriented interface
 * @export
 * @class BankreconciliationpaymentTypeApi
 * @extends {BaseAPI}
 */
var BankreconciliationpaymentTypeApi = /** @class */ (function (_super) {
    __extends(BankreconciliationpaymentTypeApi, _super);
    function BankreconciliationpaymentTypeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Get payment type by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationpaymentTypeApi
     */
    BankreconciliationpaymentTypeApi.prototype.get = function (id, fields, options) {
        return exports.BankreconciliationpaymentTypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find payment type corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [description] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankreconciliationpaymentTypeApi
     */
    BankreconciliationpaymentTypeApi.prototype.search = function (id, description, from, count, sorting, fields, options) {
        return exports.BankreconciliationpaymentTypeApiFp(this.configuration).search(id, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return BankreconciliationpaymentTypeApi;
}(BaseAPI));
exports.BankreconciliationpaymentTypeApi = BankreconciliationpaymentTypeApi;
/**
 * BankstatementApi - fetch parameter creator
 * @export
 */
exports.BankstatementApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete bank statement by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/bank/statement/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get bank statement.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/bank/statement/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Upload bank statement file.
         * @param {string} fileFormat File format
         * @param {any} file The bank statement file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importBankStatement: function (fileFormat, file, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'fileFormat' is not null or undefined
            if (fileFormat === null || fileFormat === undefined) {
                throw new RequiredError('fileFormat', 'Required parameter fileFormat was null or undefined when calling importBankStatement.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling importBankStatement.');
            }
            var localVarPath = "/bank/statement/import";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fileFormat !== undefined) {
                localVarQueryParameter['fileFormat'] = fileFormat;
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find bank statement corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/bank/statement";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BankstatementApi - functional programming interface
 * @export
 */
exports.BankstatementApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete bank statement by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.BankstatementApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get bank statement.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.BankstatementApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Upload bank statement file.
         * @param {string} fileFormat File format
         * @param {any} file The bank statement file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importBankStatement: function (fileFormat, file, options) {
            var localVarFetchArgs = exports.BankstatementApiFetchParamCreator(configuration).importBankStatement(fileFormat, file, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find bank statement corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.BankstatementApiFetchParamCreator(configuration).search(id, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * BankstatementApi - factory interface
 * @export
 */
exports.BankstatementApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete bank statement by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.BankstatementApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get bank statement.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.BankstatementApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Upload bank statement file.
         * @param {string} fileFormat File format
         * @param {any} file The bank statement file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importBankStatement: function (fileFormat, file, options) {
            return exports.BankstatementApiFp(configuration).importBankStatement(fileFormat, file, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find bank statement corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, from, count, sorting, fields, options) {
            return exports.BankstatementApiFp(configuration).search(id, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * BankstatementApi - object-oriented interface
 * @export
 * @class BankstatementApi
 * @extends {BaseAPI}
 */
var BankstatementApi = /** @class */ (function (_super) {
    __extends(BankstatementApi, _super);
    function BankstatementApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete bank statement by ID.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementApi
     */
    BankstatementApi.prototype._delete = function (id, options) {
        return exports.BankstatementApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get bank statement.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementApi
     */
    BankstatementApi.prototype.get = function (id, fields, options) {
        return exports.BankstatementApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Upload bank statement file.
     * @param {string} fileFormat File format
     * @param {any} file The bank statement file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementApi
     */
    BankstatementApi.prototype.importBankStatement = function (fileFormat, file, options) {
        return exports.BankstatementApiFp(this.configuration).importBankStatement(fileFormat, file, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find bank statement corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementApi
     */
    BankstatementApi.prototype.search = function (id, from, count, sorting, fields, options) {
        return exports.BankstatementApiFp(this.configuration).search(id, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return BankstatementApi;
}(BaseAPI));
exports.BankstatementApi = BankstatementApi;
/**
 * BankstatementtransactionApi - fetch parameter creator
 * @export
 */
exports.BankstatementtransactionApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get bank transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/bank/statement/transaction/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get additional details about transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getDetails.');
            }
            var localVarPath = "/bank/statement/transaction/{id}/details"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find bank transaction corresponding with sent data.
         * @param {number} bankStatementId Bank statement ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (bankStatementId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'bankStatementId' is not null or undefined
            if (bankStatementId === null || bankStatementId === undefined) {
                throw new RequiredError('bankStatementId', 'Required parameter bankStatementId was null or undefined when calling search.');
            }
            var localVarPath = "/bank/statement/transaction";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (bankStatementId !== undefined) {
                localVarQueryParameter['bankStatementId'] = bankStatementId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BankstatementtransactionApi - functional programming interface
 * @export
 */
exports.BankstatementtransactionApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get bank transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.BankstatementtransactionApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get additional details about transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails: function (id, fields, options) {
            var localVarFetchArgs = exports.BankstatementtransactionApiFetchParamCreator(configuration).getDetails(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find bank transaction corresponding with sent data.
         * @param {number} bankStatementId Bank statement ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (bankStatementId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.BankstatementtransactionApiFetchParamCreator(configuration).search(bankStatementId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * BankstatementtransactionApi - factory interface
 * @export
 */
exports.BankstatementtransactionApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Get bank transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.BankstatementtransactionApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get additional details about transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails: function (id, fields, options) {
            return exports.BankstatementtransactionApiFp(configuration).getDetails(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find bank transaction corresponding with sent data.
         * @param {number} bankStatementId Bank statement ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (bankStatementId, from, count, sorting, fields, options) {
            return exports.BankstatementtransactionApiFp(configuration).search(bankStatementId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * BankstatementtransactionApi - object-oriented interface
 * @export
 * @class BankstatementtransactionApi
 * @extends {BaseAPI}
 */
var BankstatementtransactionApi = /** @class */ (function (_super) {
    __extends(BankstatementtransactionApi, _super);
    function BankstatementtransactionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Get bank transaction by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementtransactionApi
     */
    BankstatementtransactionApi.prototype.get = function (id, fields, options) {
        return exports.BankstatementtransactionApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get additional details about transaction by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementtransactionApi
     */
    BankstatementtransactionApi.prototype.getDetails = function (id, fields, options) {
        return exports.BankstatementtransactionApiFp(this.configuration).getDetails(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find bank transaction corresponding with sent data.
     * @param {number} bankStatementId Bank statement ID
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankstatementtransactionApi
     */
    BankstatementtransactionApi.prototype.search = function (bankStatementId, from, count, sorting, fields, options) {
        return exports.BankstatementtransactionApiFp(this.configuration).search(bankStatementId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return BankstatementtransactionApi;
}(BaseAPI));
exports.BankstatementtransactionApi = BankstatementtransactionApi;
/**
 * CompanyApi - fetch parameter creator
 * @export
 */
exports.CompanyApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Find company by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/company/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find divisions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivisions: function (from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/company/divisions";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns client customers (with accountant/auditor relation) where the current user has login access (proxy login).
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithLoginAccess: function (from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/company/>withLoginAccess";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CompanyApi - functional programming interface
 * @export
 */
exports.CompanyApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Find company by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.CompanyApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find divisions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivisions: function (from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.CompanyApiFetchParamCreator(configuration).getDivisions(from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Returns client customers (with accountant/auditor relation) where the current user has login access (proxy login).
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithLoginAccess: function (from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.CompanyApiFetchParamCreator(configuration).getWithLoginAccess(from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CompanyApi - factory interface
 * @export
 */
exports.CompanyApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Find company by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.CompanyApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find divisions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivisions: function (from, count, sorting, fields, options) {
            return exports.CompanyApiFp(configuration).getDivisions(from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Returns client customers (with accountant/auditor relation) where the current user has login access (proxy login).
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithLoginAccess: function (from, count, sorting, fields, options) {
            return exports.CompanyApiFp(configuration).getWithLoginAccess(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * CompanyApi - object-oriented interface
 * @export
 * @class CompanyApi
 * @extends {BaseAPI}
 */
var CompanyApi = /** @class */ (function (_super) {
    __extends(CompanyApi, _super);
    function CompanyApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Find company by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    CompanyApi.prototype.get = function (id, fields, options) {
        return exports.CompanyApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find divisions.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    CompanyApi.prototype.getDivisions = function (from, count, sorting, fields, options) {
        return exports.CompanyApiFp(this.configuration).getDivisions(from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Returns client customers (with accountant/auditor relation) where the current user has login access (proxy login).
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    CompanyApi.prototype.getWithLoginAccess = function (from, count, sorting, fields, options) {
        return exports.CompanyApiFp(this.configuration).getWithLoginAccess(from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return CompanyApi;
}(BaseAPI));
exports.CompanyApi = CompanyApi;
/**
 * ContactApi - fetch parameter creator
 * @export
 */
exports.ContactApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get contact by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/contact/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create contact.
         * @param {Contact} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/contact";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Contact" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find contacts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [email] Containing
         * @param {string} [customerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, firstName, lastName, email, customerId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/contact";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }
            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ContactApi - functional programming interface
 * @export
 */
exports.ContactApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get contact by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.ContactApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create contact.
         * @param {Contact} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.ContactApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find contacts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [email] Containing
         * @param {string} [customerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, firstName, lastName, email, customerId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.ContactApiFetchParamCreator(configuration).search(id, firstName, lastName, email, customerId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ContactApi - factory interface
 * @export
 */
exports.ContactApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get contact by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.ContactApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create contact.
         * @param {Contact} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.ContactApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find contacts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [email] Containing
         * @param {string} [customerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, firstName, lastName, email, customerId, from, count, sorting, fields, options) {
            return exports.ContactApiFp(configuration).search(id, firstName, lastName, email, customerId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
var ContactApi = /** @class */ (function (_super) {
    __extends(ContactApi, _super);
    function ContactApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get contact by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    ContactApi.prototype.get = function (id, fields, options) {
        return exports.ContactApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create contact.
     * @param {Contact} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    ContactApi.prototype.post = function (body, options) {
        return exports.ContactApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find contacts corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [firstName] Containing
     * @param {string} [lastName] Containing
     * @param {string} [email] Containing
     * @param {string} [customerId] List of IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    ContactApi.prototype.search = function (id, firstName, lastName, email, customerId, from, count, sorting, fields, options) {
        return exports.ContactApiFp(this.configuration).search(id, firstName, lastName, email, customerId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return ContactApi;
}(BaseAPI));
exports.ContactApi = ContactApi;
/**
 * CountryApi - fetch parameter creator
 * @export
 */
exports.CountryApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get country by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/country/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find countries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, code, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/country";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CountryApi - functional programming interface
 * @export
 */
exports.CountryApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get country by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.CountryApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find countries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, code, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.CountryApiFetchParamCreator(configuration).search(id, code, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CountryApi - factory interface
 * @export
 */
exports.CountryApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get country by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.CountryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find countries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, code, from, count, sorting, fields, options) {
            return exports.CountryApiFp(configuration).search(id, code, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * CountryApi - object-oriented interface
 * @export
 * @class CountryApi
 * @extends {BaseAPI}
 */
var CountryApi = /** @class */ (function (_super) {
    __extends(CountryApi, _super);
    function CountryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get country by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    CountryApi.prototype.get = function (id, fields, options) {
        return exports.CountryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find countries corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [code] List of IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    CountryApi.prototype.search = function (id, code, from, count, sorting, fields, options) {
        return exports.CountryApiFp(this.configuration).search(id, code, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return CountryApi;
}(BaseAPI));
exports.CountryApi = CountryApi;
/**
 * CrmprospectApi - fetch parameter creator
 * @export
 */
exports.CrmprospectApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get prospect by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/crm/prospect/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find prospects corresponding with sent data.
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {string} [createdDateFrom] From and including
         * @param {string} [createdDateTo] To and excluding
         * @param {string} [customerId] Equals
         * @param {string} [salesEmployeeId] Equals
         * @param {boolean} [isClosed] Equals
         * @param {string} [closedReason] Equals
         * @param {string} [closedDateFrom] From and including
         * @param {string} [closedDateTo] To and excluding
         * @param {string} [competitor] Containing
         * @param {string} [prospectType] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectOfferId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (name, description, createdDateFrom, createdDateTo, customerId, salesEmployeeId, isClosed, closedReason, closedDateFrom, closedDateTo, competitor, prospectType, projectId, projectOfferId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/crm/prospect";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (createdDateFrom !== undefined) {
                localVarQueryParameter['createdDateFrom'] = createdDateFrom;
            }
            if (createdDateTo !== undefined) {
                localVarQueryParameter['createdDateTo'] = createdDateTo;
            }
            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }
            if (salesEmployeeId !== undefined) {
                localVarQueryParameter['salesEmployeeId'] = salesEmployeeId;
            }
            if (isClosed !== undefined) {
                localVarQueryParameter['isClosed'] = isClosed;
            }
            if (closedReason !== undefined) {
                localVarQueryParameter['closedReason'] = closedReason;
            }
            if (closedDateFrom !== undefined) {
                localVarQueryParameter['closedDateFrom'] = closedDateFrom;
            }
            if (closedDateTo !== undefined) {
                localVarQueryParameter['closedDateTo'] = closedDateTo;
            }
            if (competitor !== undefined) {
                localVarQueryParameter['competitor'] = competitor;
            }
            if (prospectType !== undefined) {
                localVarQueryParameter['prospectType'] = prospectType;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (projectOfferId !== undefined) {
                localVarQueryParameter['projectOfferId'] = projectOfferId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CrmprospectApi - functional programming interface
 * @export
 */
exports.CrmprospectApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get prospect by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.CrmprospectApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find prospects corresponding with sent data.
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {string} [createdDateFrom] From and including
         * @param {string} [createdDateTo] To and excluding
         * @param {string} [customerId] Equals
         * @param {string} [salesEmployeeId] Equals
         * @param {boolean} [isClosed] Equals
         * @param {string} [closedReason] Equals
         * @param {string} [closedDateFrom] From and including
         * @param {string} [closedDateTo] To and excluding
         * @param {string} [competitor] Containing
         * @param {string} [prospectType] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectOfferId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (name, description, createdDateFrom, createdDateTo, customerId, salesEmployeeId, isClosed, closedReason, closedDateFrom, closedDateTo, competitor, prospectType, projectId, projectOfferId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.CrmprospectApiFetchParamCreator(configuration).search(name, description, createdDateFrom, createdDateTo, customerId, salesEmployeeId, isClosed, closedReason, closedDateFrom, closedDateTo, competitor, prospectType, projectId, projectOfferId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CrmprospectApi - factory interface
 * @export
 */
exports.CrmprospectApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get prospect by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.CrmprospectApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find prospects corresponding with sent data.
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {string} [createdDateFrom] From and including
         * @param {string} [createdDateTo] To and excluding
         * @param {string} [customerId] Equals
         * @param {string} [salesEmployeeId] Equals
         * @param {boolean} [isClosed] Equals
         * @param {string} [closedReason] Equals
         * @param {string} [closedDateFrom] From and including
         * @param {string} [closedDateTo] To and excluding
         * @param {string} [competitor] Containing
         * @param {string} [prospectType] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectOfferId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (name, description, createdDateFrom, createdDateTo, customerId, salesEmployeeId, isClosed, closedReason, closedDateFrom, closedDateTo, competitor, prospectType, projectId, projectOfferId, from, count, sorting, fields, options) {
            return exports.CrmprospectApiFp(configuration).search(name, description, createdDateFrom, createdDateTo, customerId, salesEmployeeId, isClosed, closedReason, closedDateFrom, closedDateTo, competitor, prospectType, projectId, projectOfferId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * CrmprospectApi - object-oriented interface
 * @export
 * @class CrmprospectApi
 * @extends {BaseAPI}
 */
var CrmprospectApi = /** @class */ (function (_super) {
    __extends(CrmprospectApi, _super);
    function CrmprospectApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get prospect by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmprospectApi
     */
    CrmprospectApi.prototype.get = function (id, fields, options) {
        return exports.CrmprospectApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find prospects corresponding with sent data.
     * @param {string} [name] Containing
     * @param {string} [description] Containing
     * @param {string} [createdDateFrom] From and including
     * @param {string} [createdDateTo] To and excluding
     * @param {string} [customerId] Equals
     * @param {string} [salesEmployeeId] Equals
     * @param {boolean} [isClosed] Equals
     * @param {string} [closedReason] Equals
     * @param {string} [closedDateFrom] From and including
     * @param {string} [closedDateTo] To and excluding
     * @param {string} [competitor] Containing
     * @param {string} [prospectType] Equals
     * @param {string} [projectId] Equals
     * @param {string} [projectOfferId] Equals
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmprospectApi
     */
    CrmprospectApi.prototype.search = function (name, description, createdDateFrom, createdDateTo, customerId, salesEmployeeId, isClosed, closedReason, closedDateFrom, closedDateTo, competitor, prospectType, projectId, projectOfferId, from, count, sorting, fields, options) {
        return exports.CrmprospectApiFp(this.configuration).search(name, description, createdDateFrom, createdDateTo, customerId, salesEmployeeId, isClosed, closedReason, closedDateFrom, closedDateTo, competitor, prospectType, projectId, projectOfferId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return CrmprospectApi;
}(BaseAPI));
exports.CrmprospectApi = CrmprospectApi;
/**
 * CurrencyApi - fetch parameter creator
 * @export
 */
exports.CurrencyApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get currency by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/currency/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find currencies corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] Currency codes
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, code, fields, from, count, sorting, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/currency";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CurrencyApi - functional programming interface
 * @export
 */
exports.CurrencyApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get currency by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.CurrencyApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find currencies corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] Currency codes
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, code, fields, from, count, sorting, options) {
            var localVarFetchArgs = exports.CurrencyApiFetchParamCreator(configuration).search(id, code, fields, from, count, sorting, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CurrencyApi - factory interface
 * @export
 */
exports.CurrencyApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get currency by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.CurrencyApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find currencies corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [code] Currency codes
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, code, fields, from, count, sorting, options) {
            return exports.CurrencyApiFp(configuration).search(id, code, fields, from, count, sorting, options)(fetch, basePath);
        },
    };
};
/**
 * CurrencyApi - object-oriented interface
 * @export
 * @class CurrencyApi
 * @extends {BaseAPI}
 */
var CurrencyApi = /** @class */ (function (_super) {
    __extends(CurrencyApi, _super);
    function CurrencyApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get currency by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    CurrencyApi.prototype.get = function (id, fields, options) {
        return exports.CurrencyApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find currencies corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [code] Currency codes
     * @param {string} [fields] Fields filter pattern
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    CurrencyApi.prototype.search = function (id, code, fields, from, count, sorting, options) {
        return exports.CurrencyApiFp(this.configuration).search(id, code, fields, from, count, sorting, options)(this.fetch, this.basePath);
    };
    return CurrencyApi;
}(BaseAPI));
exports.CurrencyApi = CurrencyApi;
/**
 * CustomerApi - fetch parameter creator
 * @export
 */
exports.CustomerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get customer by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/customer/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create customer. Related customer addresses may also be created.
         * @param {Customer} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/customer";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create multiple customers. Related supplier addresses may also be created.
         * @param {Array<Customer>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/customer/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;Customer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update customer.
         * @param {number} id Element ID
         * @param {Customer} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/customer/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update multiple customers. Addresses can also be updated.
         * @param {Array<Customer>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/customer/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;Customer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find customers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [customerAccountNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, customerAccountNumber, email, invoiceEmail, isInactive, accountManagerId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/customer";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (customerAccountNumber !== undefined) {
                localVarQueryParameter['customerAccountNumber'] = customerAccountNumber;
            }
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            if (invoiceEmail !== undefined) {
                localVarQueryParameter['invoiceEmail'] = invoiceEmail;
            }
            if (isInactive !== undefined) {
                localVarQueryParameter['isInactive'] = isInactive;
            }
            if (accountManagerId !== undefined) {
                localVarQueryParameter['accountManagerId'] = accountManagerId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CustomerApi - functional programming interface
 * @export
 */
exports.CustomerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get customer by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.CustomerApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create customer. Related customer addresses may also be created.
         * @param {Customer} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.CustomerApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create multiple customers. Related supplier addresses may also be created.
         * @param {Array<Customer>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            var localVarFetchArgs = exports.CustomerApiFetchParamCreator(configuration).postList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update customer.
         * @param {number} id Element ID
         * @param {Customer} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.CustomerApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update multiple customers. Addresses can also be updated.
         * @param {Array<Customer>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            var localVarFetchArgs = exports.CustomerApiFetchParamCreator(configuration).putList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find customers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [customerAccountNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, customerAccountNumber, email, invoiceEmail, isInactive, accountManagerId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.CustomerApiFetchParamCreator(configuration).search(id, customerAccountNumber, email, invoiceEmail, isInactive, accountManagerId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CustomerApi - factory interface
 * @export
 */
exports.CustomerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get customer by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.CustomerApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create customer. Related customer addresses may also be created.
         * @param {Customer} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.CustomerApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create multiple customers. Related supplier addresses may also be created.
         * @param {Array<Customer>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            return exports.CustomerApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update customer.
         * @param {number} id Element ID
         * @param {Customer} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.CustomerApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update multiple customers. Addresses can also be updated.
         * @param {Array<Customer>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            return exports.CustomerApiFp(configuration).putList(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find customers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [customerAccountNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, customerAccountNumber, email, invoiceEmail, isInactive, accountManagerId, from, count, sorting, fields, options) {
            return exports.CustomerApiFp(configuration).search(id, customerAccountNumber, email, invoiceEmail, isInactive, accountManagerId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
var CustomerApi = /** @class */ (function (_super) {
    __extends(CustomerApi, _super);
    function CustomerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get customer by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    CustomerApi.prototype.get = function (id, fields, options) {
        return exports.CustomerApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create customer. Related customer addresses may also be created.
     * @param {Customer} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    CustomerApi.prototype.post = function (body, options) {
        return exports.CustomerApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create multiple customers. Related supplier addresses may also be created.
     * @param {Array<Customer>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    CustomerApi.prototype.postList = function (body, options) {
        return exports.CustomerApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update customer.
     * @param {number} id Element ID
     * @param {Customer} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    CustomerApi.prototype.put = function (id, body, options) {
        return exports.CustomerApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update multiple customers. Addresses can also be updated.
     * @param {Array<Customer>} [body] JSON representing updates to object. Should have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    CustomerApi.prototype.putList = function (body, options) {
        return exports.CustomerApiFp(this.configuration).putList(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find customers corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [customerAccountNumber] List of IDs
     * @param {string} [email] Equals
     * @param {string} [invoiceEmail] Equals
     * @param {boolean} [isInactive] Equals
     * @param {string} [accountManagerId] List of IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    CustomerApi.prototype.search = function (id, customerAccountNumber, email, invoiceEmail, isInactive, accountManagerId, from, count, sorting, fields, options) {
        return exports.CustomerApiFp(this.configuration).search(id, customerAccountNumber, email, invoiceEmail, isInactive, accountManagerId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return CustomerApi;
}(BaseAPI));
exports.CustomerApi = CustomerApi;
/**
 * CustomercategoryApi - fetch parameter creator
 * @export
 */
exports.CustomercategoryApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Find customer/supplier category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/customer/category/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add new customer/supplier category.
         * @param {CustomerCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/customer/category";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("CustomerCategory" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update customer/supplier category.
         * @param {number} id Element ID
         * @param {CustomerCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/customer/category/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("CustomerCategory" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find customer/supplier categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {string} [type] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, description, type, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/customer/category";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CustomercategoryApi - functional programming interface
 * @export
 */
exports.CustomercategoryApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Find customer/supplier category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.CustomercategoryApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Add new customer/supplier category.
         * @param {CustomerCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.CustomercategoryApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update customer/supplier category.
         * @param {number} id Element ID
         * @param {CustomerCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.CustomercategoryApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find customer/supplier categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {string} [type] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, description, type, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.CustomercategoryApiFetchParamCreator(configuration).search(id, name, number, description, type, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CustomercategoryApi - factory interface
 * @export
 */
exports.CustomercategoryApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Find customer/supplier category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.CustomercategoryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add new customer/supplier category.
         * @param {CustomerCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.CustomercategoryApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update customer/supplier category.
         * @param {number} id Element ID
         * @param {CustomerCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.CustomercategoryApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find customer/supplier categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {string} [type] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, description, type, from, count, sorting, fields, options) {
            return exports.CustomercategoryApiFp(configuration).search(id, name, number, description, type, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * CustomercategoryApi - object-oriented interface
 * @export
 * @class CustomercategoryApi
 * @extends {BaseAPI}
 */
var CustomercategoryApi = /** @class */ (function (_super) {
    __extends(CustomercategoryApi, _super);
    function CustomercategoryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Find customer/supplier category by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomercategoryApi
     */
    CustomercategoryApi.prototype.get = function (id, fields, options) {
        return exports.CustomercategoryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Add new customer/supplier category.
     * @param {CustomerCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomercategoryApi
     */
    CustomercategoryApi.prototype.post = function (body, options) {
        return exports.CustomercategoryApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update customer/supplier category.
     * @param {number} id Element ID
     * @param {CustomerCategory} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomercategoryApi
     */
    CustomercategoryApi.prototype.put = function (id, body, options) {
        return exports.CustomercategoryApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find customer/supplier categories corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [name] Containing
     * @param {string} [number] Equals
     * @param {string} [description] Containing
     * @param {string} [type] List of IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomercategoryApi
     */
    CustomercategoryApi.prototype.search = function (id, name, number, description, type, from, count, sorting, fields, options) {
        return exports.CustomercategoryApiFp(this.configuration).search(id, name, number, description, type, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return CustomercategoryApi;
}(BaseAPI));
exports.CustomercategoryApi = CustomercategoryApi;
/**
 * DepartmentApi - fetch parameter creator
 * @export
 */
exports.DepartmentApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get department by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/department/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find department corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [departmentNumber] Containing
         * @param {string} [departmentManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, departmentNumber, departmentManagerId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/department";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (departmentNumber !== undefined) {
                localVarQueryParameter['departmentNumber'] = departmentNumber;
            }
            if (departmentManagerId !== undefined) {
                localVarQueryParameter['departmentManagerId'] = departmentManagerId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DepartmentApi - functional programming interface
 * @export
 */
exports.DepartmentApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get department by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.DepartmentApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find department corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [departmentNumber] Containing
         * @param {string} [departmentManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, departmentNumber, departmentManagerId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.DepartmentApiFetchParamCreator(configuration).search(id, name, departmentNumber, departmentManagerId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * DepartmentApi - factory interface
 * @export
 */
exports.DepartmentApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get department by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.DepartmentApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find department corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [departmentNumber] Containing
         * @param {string} [departmentManagerId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, departmentNumber, departmentManagerId, from, count, sorting, fields, options) {
            return exports.DepartmentApiFp(configuration).search(id, name, departmentNumber, departmentManagerId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * DepartmentApi - object-oriented interface
 * @export
 * @class DepartmentApi
 * @extends {BaseAPI}
 */
var DepartmentApi = /** @class */ (function (_super) {
    __extends(DepartmentApi, _super);
    function DepartmentApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get department by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentApi
     */
    DepartmentApi.prototype.get = function (id, fields, options) {
        return exports.DepartmentApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find department corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [name] Containing
     * @param {string} [departmentNumber] Containing
     * @param {string} [departmentManagerId] List of IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentApi
     */
    DepartmentApi.prototype.search = function (id, name, departmentNumber, departmentManagerId, from, count, sorting, fields, options) {
        return exports.DepartmentApiFp(this.configuration).search(id, name, departmentNumber, departmentManagerId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return DepartmentApi;
}(BaseAPI));
exports.DepartmentApi = DepartmentApi;
/**
 * EmployeeApi - fetch parameter creator
 * @export
 */
exports.EmployeeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get employee by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/employee/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create one employee.
         * @param {Employee} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Employee" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create several employees.
         * @param {Array<Employee>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;Employee&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update employee.
         * @param {number} id Element ID
         * @param {Employee} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/employee/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Employee" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find employees corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [employeeNumber] Containing
         * @param {boolean} [allowInformationRegistration] Equals
         * @param {string} [departmentId] List of IDs
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, firstName, lastName, employeeNumber, allowInformationRegistration, departmentId, fields, from, count, sorting, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }
            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }
            if (employeeNumber !== undefined) {
                localVarQueryParameter['employeeNumber'] = employeeNumber;
            }
            if (allowInformationRegistration !== undefined) {
                localVarQueryParameter['allowInformationRegistration'] = allowInformationRegistration;
            }
            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmployeeApi - functional programming interface
 * @export
 */
exports.EmployeeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get employee by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.EmployeeApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create one employee.
         * @param {Employee} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.EmployeeApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create several employees.
         * @param {Array<Employee>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            var localVarFetchArgs = exports.EmployeeApiFetchParamCreator(configuration).postList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update employee.
         * @param {number} id Element ID
         * @param {Employee} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.EmployeeApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find employees corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [employeeNumber] Containing
         * @param {boolean} [allowInformationRegistration] Equals
         * @param {string} [departmentId] List of IDs
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, firstName, lastName, employeeNumber, allowInformationRegistration, departmentId, fields, from, count, sorting, options) {
            var localVarFetchArgs = exports.EmployeeApiFetchParamCreator(configuration).search(id, firstName, lastName, employeeNumber, allowInformationRegistration, departmentId, fields, from, count, sorting, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmployeeApi - factory interface
 * @export
 */
exports.EmployeeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get employee by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.EmployeeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create one employee.
         * @param {Employee} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.EmployeeApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create several employees.
         * @param {Array<Employee>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            return exports.EmployeeApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update employee.
         * @param {number} id Element ID
         * @param {Employee} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.EmployeeApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find employees corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [firstName] Containing
         * @param {string} [lastName] Containing
         * @param {string} [employeeNumber] Containing
         * @param {boolean} [allowInformationRegistration] Equals
         * @param {string} [departmentId] List of IDs
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, firstName, lastName, employeeNumber, allowInformationRegistration, departmentId, fields, from, count, sorting, options) {
            return exports.EmployeeApiFp(configuration).search(id, firstName, lastName, employeeNumber, allowInformationRegistration, departmentId, fields, from, count, sorting, options)(fetch, basePath);
        },
    };
};
/**
 * EmployeeApi - object-oriented interface
 * @export
 * @class EmployeeApi
 * @extends {BaseAPI}
 */
var EmployeeApi = /** @class */ (function (_super) {
    __extends(EmployeeApi, _super);
    function EmployeeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get employee by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    EmployeeApi.prototype.get = function (id, fields, options) {
        return exports.EmployeeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create one employee.
     * @param {Employee} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    EmployeeApi.prototype.post = function (body, options) {
        return exports.EmployeeApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create several employees.
     * @param {Array<Employee>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    EmployeeApi.prototype.postList = function (body, options) {
        return exports.EmployeeApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update employee.
     * @param {number} id Element ID
     * @param {Employee} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    EmployeeApi.prototype.put = function (id, body, options) {
        return exports.EmployeeApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find employees corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [firstName] Containing
     * @param {string} [lastName] Containing
     * @param {string} [employeeNumber] Containing
     * @param {boolean} [allowInformationRegistration] Equals
     * @param {string} [departmentId] List of IDs
     * @param {string} [fields] Fields filter pattern
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeApi
     */
    EmployeeApi.prototype.search = function (id, firstName, lastName, employeeNumber, allowInformationRegistration, departmentId, fields, from, count, sorting, options) {
        return exports.EmployeeApiFp(this.configuration).search(id, firstName, lastName, employeeNumber, allowInformationRegistration, departmentId, fields, from, count, sorting, options)(this.fetch, this.basePath);
    };
    return EmployeeApi;
}(BaseAPI));
exports.EmployeeApi = EmployeeApi;
/**
 * EmployeeemploymentApi - fetch parameter creator
 * @export
 */
exports.EmployeeemploymentApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Find employment by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/employee/employment/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create employment.
         * @param {Employment} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/employment";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Employment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update employemnt.
         * @param {number} id Element ID
         * @param {Employment} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/employee/employment/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Employment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find all employments for employee.
         * @param {number} [employeeId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/employment";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmployeeemploymentApi - functional programming interface
 * @export
 */
exports.EmployeeemploymentApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Find employment by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.EmployeeemploymentApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create employment.
         * @param {Employment} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.EmployeeemploymentApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update employemnt.
         * @param {number} id Element ID
         * @param {Employment} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.EmployeeemploymentApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find all employments for employee.
         * @param {number} [employeeId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.EmployeeemploymentApiFetchParamCreator(configuration).search(employeeId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmployeeemploymentApi - factory interface
 * @export
 */
exports.EmployeeemploymentApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Find employment by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.EmployeeemploymentApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create employment.
         * @param {Employment} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.EmployeeemploymentApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update employemnt.
         * @param {number} id Element ID
         * @param {Employment} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.EmployeeemploymentApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all employments for employee.
         * @param {number} [employeeId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, from, count, sorting, fields, options) {
            return exports.EmployeeemploymentApiFp(configuration).search(employeeId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * EmployeeemploymentApi - object-oriented interface
 * @export
 * @class EmployeeemploymentApi
 * @extends {BaseAPI}
 */
var EmployeeemploymentApi = /** @class */ (function (_super) {
    __extends(EmployeeemploymentApi, _super);
    function EmployeeemploymentApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Find employment by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentApi
     */
    EmployeeemploymentApi.prototype.get = function (id, fields, options) {
        return exports.EmployeeemploymentApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create employment.
     * @param {Employment} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentApi
     */
    EmployeeemploymentApi.prototype.post = function (body, options) {
        return exports.EmployeeemploymentApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update employemnt.
     * @param {number} id Element ID
     * @param {Employment} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentApi
     */
    EmployeeemploymentApi.prototype.put = function (id, body, options) {
        return exports.EmployeeemploymentApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find all employments for employee.
     * @param {number} [employeeId] Element ID
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentApi
     */
    EmployeeemploymentApi.prototype.search = function (employeeId, from, count, sorting, fields, options) {
        return exports.EmployeeemploymentApiFp(this.configuration).search(employeeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return EmployeeemploymentApi;
}(BaseAPI));
exports.EmployeeemploymentApi = EmployeeemploymentApi;
/**
 * EmployeeemploymentdetailsApi - fetch parameter creator
 * @export
 */
exports.EmployeeemploymentdetailsApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find employment details by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/employee/employment/details/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create employment details.
         * @param {EmploymentDetails} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/employment/details";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("EmploymentDetails" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update employment details.
         * @param {number} id Element ID
         * @param {EmploymentDetails} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/employee/employment/details/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("EmploymentDetails" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find all employmentdetails for employment.
         * @param {number} [employmentId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employmentId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/employment/details";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employmentId !== undefined) {
                localVarQueryParameter['employmentId'] = employmentId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmployeeemploymentdetailsApi - functional programming interface
 * @export
 */
exports.EmployeeemploymentdetailsApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find employment details by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.EmployeeemploymentdetailsApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create employment details.
         * @param {EmploymentDetails} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.EmployeeemploymentdetailsApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update employment details.
         * @param {number} id Element ID
         * @param {EmploymentDetails} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.EmployeeemploymentdetailsApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find all employmentdetails for employment.
         * @param {number} [employmentId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employmentId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.EmployeeemploymentdetailsApiFetchParamCreator(configuration).search(employmentId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmployeeemploymentdetailsApi - factory interface
 * @export
 */
exports.EmployeeemploymentdetailsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find employment details by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.EmployeeemploymentdetailsApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create employment details.
         * @param {EmploymentDetails} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.EmployeeemploymentdetailsApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update employment details.
         * @param {number} id Element ID
         * @param {EmploymentDetails} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.EmployeeemploymentdetailsApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find all employmentdetails for employment.
         * @param {number} [employmentId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employmentId, from, count, sorting, fields, options) {
            return exports.EmployeeemploymentdetailsApiFp(configuration).search(employmentId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * EmployeeemploymentdetailsApi - object-oriented interface
 * @export
 * @class EmployeeemploymentdetailsApi
 * @extends {BaseAPI}
 */
var EmployeeemploymentdetailsApi = /** @class */ (function (_super) {
    __extends(EmployeeemploymentdetailsApi, _super);
    function EmployeeemploymentdetailsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find employment details by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentdetailsApi
     */
    EmployeeemploymentdetailsApi.prototype.get = function (id, fields, options) {
        return exports.EmployeeemploymentdetailsApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create employment details.
     * @param {EmploymentDetails} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentdetailsApi
     */
    EmployeeemploymentdetailsApi.prototype.post = function (body, options) {
        return exports.EmployeeemploymentdetailsApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update employment details.
     * @param {number} id Element ID
     * @param {EmploymentDetails} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentdetailsApi
     */
    EmployeeemploymentdetailsApi.prototype.put = function (id, body, options) {
        return exports.EmployeeemploymentdetailsApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find all employmentdetails for employment.
     * @param {number} [employmentId] Element ID
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentdetailsApi
     */
    EmployeeemploymentdetailsApi.prototype.search = function (employmentId, from, count, sorting, fields, options) {
        return exports.EmployeeemploymentdetailsApiFp(this.configuration).search(employmentId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return EmployeeemploymentdetailsApi;
}(BaseAPI));
exports.EmployeeemploymentdetailsApi = EmployeeemploymentdetailsApi;
/**
 * EmployeeemploymentemploymentTypeApi - fetch parameter creator
 * @export
 */
exports.EmployeeemploymentemploymentTypeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find all employment type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/employment/employmentType";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmployeeemploymentemploymentTypeApi - functional programming interface
 * @export
 */
exports.EmployeeemploymentemploymentTypeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find all employment type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.EmployeeemploymentemploymentTypeApiFetchParamCreator(configuration).search(from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmployeeemploymentemploymentTypeApi - factory interface
 * @export
 */
exports.EmployeeemploymentemploymentTypeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find all employment type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            return exports.EmployeeemploymentemploymentTypeApiFp(configuration).search(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * EmployeeemploymentemploymentTypeApi - object-oriented interface
 * @export
 * @class EmployeeemploymentemploymentTypeApi
 * @extends {BaseAPI}
 */
var EmployeeemploymentemploymentTypeApi = /** @class */ (function (_super) {
    __extends(EmployeeemploymentemploymentTypeApi, _super);
    function EmployeeemploymentemploymentTypeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find all employment type IDs.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentemploymentTypeApi
     */
    EmployeeemploymentemploymentTypeApi.prototype.search = function (from, count, sorting, fields, options) {
        return exports.EmployeeemploymentemploymentTypeApiFp(this.configuration).search(from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return EmployeeemploymentemploymentTypeApi;
}(BaseAPI));
exports.EmployeeemploymentemploymentTypeApi = EmployeeemploymentemploymentTypeApi;
/**
 * EmployeeemploymentleaveOfAbsenceApi - fetch parameter creator
 * @export
 */
exports.EmployeeemploymentleaveOfAbsenceApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find leave of absence by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/employee/employment/leaveOfAbsence/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create leave of absence.
         * @param {LeaveOfAbsence} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/employment/leaveOfAbsence";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("LeaveOfAbsence" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update leave of absence.
         * @param {number} id Element ID
         * @param {LeaveOfAbsence} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/employee/employment/leaveOfAbsence/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("LeaveOfAbsence" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmployeeemploymentleaveOfAbsenceApi - functional programming interface
 * @export
 */
exports.EmployeeemploymentleaveOfAbsenceApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find leave of absence by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.EmployeeemploymentleaveOfAbsenceApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create leave of absence.
         * @param {LeaveOfAbsence} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.EmployeeemploymentleaveOfAbsenceApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update leave of absence.
         * @param {number} id Element ID
         * @param {LeaveOfAbsence} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.EmployeeemploymentleaveOfAbsenceApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmployeeemploymentleaveOfAbsenceApi - factory interface
 * @export
 */
exports.EmployeeemploymentleaveOfAbsenceApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find leave of absence by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.EmployeeemploymentleaveOfAbsenceApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create leave of absence.
         * @param {LeaveOfAbsence} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.EmployeeemploymentleaveOfAbsenceApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update leave of absence.
         * @param {number} id Element ID
         * @param {LeaveOfAbsence} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.EmployeeemploymentleaveOfAbsenceApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
    };
};
/**
 * EmployeeemploymentleaveOfAbsenceApi - object-oriented interface
 * @export
 * @class EmployeeemploymentleaveOfAbsenceApi
 * @extends {BaseAPI}
 */
var EmployeeemploymentleaveOfAbsenceApi = /** @class */ (function (_super) {
    __extends(EmployeeemploymentleaveOfAbsenceApi, _super);
    function EmployeeemploymentleaveOfAbsenceApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find leave of absence by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentleaveOfAbsenceApi
     */
    EmployeeemploymentleaveOfAbsenceApi.prototype.get = function (id, fields, options) {
        return exports.EmployeeemploymentleaveOfAbsenceApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create leave of absence.
     * @param {LeaveOfAbsence} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentleaveOfAbsenceApi
     */
    EmployeeemploymentleaveOfAbsenceApi.prototype.post = function (body, options) {
        return exports.EmployeeemploymentleaveOfAbsenceApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update leave of absence.
     * @param {number} id Element ID
     * @param {LeaveOfAbsence} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentleaveOfAbsenceApi
     */
    EmployeeemploymentleaveOfAbsenceApi.prototype.put = function (id, body, options) {
        return exports.EmployeeemploymentleaveOfAbsenceApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    return EmployeeemploymentleaveOfAbsenceApi;
}(BaseAPI));
exports.EmployeeemploymentleaveOfAbsenceApi = EmployeeemploymentleaveOfAbsenceApi;
/**
 * EmployeeemploymentleaveOfAbsenceTypeApi - fetch parameter creator
 * @export
 */
exports.EmployeeemploymentleaveOfAbsenceTypeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find all leave of absence type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/employment/leaveOfAbsenceType";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmployeeemploymentleaveOfAbsenceTypeApi - functional programming interface
 * @export
 */
exports.EmployeeemploymentleaveOfAbsenceTypeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find all leave of absence type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.EmployeeemploymentleaveOfAbsenceTypeApiFetchParamCreator(configuration).search(from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmployeeemploymentleaveOfAbsenceTypeApi - factory interface
 * @export
 */
exports.EmployeeemploymentleaveOfAbsenceTypeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find all leave of absence type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            return exports.EmployeeemploymentleaveOfAbsenceTypeApiFp(configuration).search(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * EmployeeemploymentleaveOfAbsenceTypeApi - object-oriented interface
 * @export
 * @class EmployeeemploymentleaveOfAbsenceTypeApi
 * @extends {BaseAPI}
 */
var EmployeeemploymentleaveOfAbsenceTypeApi = /** @class */ (function (_super) {
    __extends(EmployeeemploymentleaveOfAbsenceTypeApi, _super);
    function EmployeeemploymentleaveOfAbsenceTypeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find all leave of absence type IDs.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentleaveOfAbsenceTypeApi
     */
    EmployeeemploymentleaveOfAbsenceTypeApi.prototype.search = function (from, count, sorting, fields, options) {
        return exports.EmployeeemploymentleaveOfAbsenceTypeApiFp(this.configuration).search(from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return EmployeeemploymentleaveOfAbsenceTypeApi;
}(BaseAPI));
exports.EmployeeemploymentleaveOfAbsenceTypeApi = EmployeeemploymentleaveOfAbsenceTypeApi;
/**
 * EmployeeemploymentoccupationCodeApi - fetch parameter creator
 * @export
 */
exports.EmployeeemploymentoccupationCodeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find all profession codes.
         * @param {string} [nameNO] Containing
         * @param {string} [code] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (nameNO, code, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/employment/occupationCode";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (nameNO !== undefined) {
                localVarQueryParameter['nameNO'] = nameNO;
            }
            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmployeeemploymentoccupationCodeApi - functional programming interface
 * @export
 */
exports.EmployeeemploymentoccupationCodeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find all profession codes.
         * @param {string} [nameNO] Containing
         * @param {string} [code] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (nameNO, code, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.EmployeeemploymentoccupationCodeApiFetchParamCreator(configuration).search(nameNO, code, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmployeeemploymentoccupationCodeApi - factory interface
 * @export
 */
exports.EmployeeemploymentoccupationCodeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find all profession codes.
         * @param {string} [nameNO] Containing
         * @param {string} [code] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (nameNO, code, from, count, sorting, fields, options) {
            return exports.EmployeeemploymentoccupationCodeApiFp(configuration).search(nameNO, code, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * EmployeeemploymentoccupationCodeApi - object-oriented interface
 * @export
 * @class EmployeeemploymentoccupationCodeApi
 * @extends {BaseAPI}
 */
var EmployeeemploymentoccupationCodeApi = /** @class */ (function (_super) {
    __extends(EmployeeemploymentoccupationCodeApi, _super);
    function EmployeeemploymentoccupationCodeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find all profession codes.
     * @param {string} [nameNO] Containing
     * @param {string} [code] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentoccupationCodeApi
     */
    EmployeeemploymentoccupationCodeApi.prototype.search = function (nameNO, code, from, count, sorting, fields, options) {
        return exports.EmployeeemploymentoccupationCodeApiFp(this.configuration).search(nameNO, code, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return EmployeeemploymentoccupationCodeApi;
}(BaseAPI));
exports.EmployeeemploymentoccupationCodeApi = EmployeeemploymentoccupationCodeApi;
/**
 * EmployeeemploymentremunerationTypeApi - fetch parameter creator
 * @export
 */
exports.EmployeeemploymentremunerationTypeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find all remuneration type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/employment/remunerationType";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmployeeemploymentremunerationTypeApi - functional programming interface
 * @export
 */
exports.EmployeeemploymentremunerationTypeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find all remuneration type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.EmployeeemploymentremunerationTypeApiFetchParamCreator(configuration).search(from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmployeeemploymentremunerationTypeApi - factory interface
 * @export
 */
exports.EmployeeemploymentremunerationTypeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find all remuneration type IDs.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            return exports.EmployeeemploymentremunerationTypeApiFp(configuration).search(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * EmployeeemploymentremunerationTypeApi - object-oriented interface
 * @export
 * @class EmployeeemploymentremunerationTypeApi
 * @extends {BaseAPI}
 */
var EmployeeemploymentremunerationTypeApi = /** @class */ (function (_super) {
    __extends(EmployeeemploymentremunerationTypeApi, _super);
    function EmployeeemploymentremunerationTypeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find all remuneration type IDs.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentremunerationTypeApi
     */
    EmployeeemploymentremunerationTypeApi.prototype.search = function (from, count, sorting, fields, options) {
        return exports.EmployeeemploymentremunerationTypeApiFp(this.configuration).search(from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return EmployeeemploymentremunerationTypeApi;
}(BaseAPI));
exports.EmployeeemploymentremunerationTypeApi = EmployeeemploymentremunerationTypeApi;
/**
 * EmployeeemploymentworkingHoursSchemeApi - fetch parameter creator
 * @export
 */
exports.EmployeeemploymentworkingHoursSchemeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find working hours scheme ID.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/employment/workingHoursScheme";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmployeeemploymentworkingHoursSchemeApi - functional programming interface
 * @export
 */
exports.EmployeeemploymentworkingHoursSchemeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find working hours scheme ID.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.EmployeeemploymentworkingHoursSchemeApiFetchParamCreator(configuration).search(from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmployeeemploymentworkingHoursSchemeApi - factory interface
 * @export
 */
exports.EmployeeemploymentworkingHoursSchemeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find working hours scheme ID.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            return exports.EmployeeemploymentworkingHoursSchemeApiFp(configuration).search(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * EmployeeemploymentworkingHoursSchemeApi - object-oriented interface
 * @export
 * @class EmployeeemploymentworkingHoursSchemeApi
 * @extends {BaseAPI}
 */
var EmployeeemploymentworkingHoursSchemeApi = /** @class */ (function (_super) {
    __extends(EmployeeemploymentworkingHoursSchemeApi, _super);
    function EmployeeemploymentworkingHoursSchemeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find working hours scheme ID.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeemploymentworkingHoursSchemeApi
     */
    EmployeeemploymentworkingHoursSchemeApi.prototype.search = function (from, count, sorting, fields, options) {
        return exports.EmployeeemploymentworkingHoursSchemeApiFp(this.configuration).search(from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return EmployeeemploymentworkingHoursSchemeApi;
}(BaseAPI));
exports.EmployeeemploymentworkingHoursSchemeApi = EmployeeemploymentworkingHoursSchemeApi;
/**
 * EmployeeentitlementApi - fetch parameter creator
 * @export
 */
exports.EmployeeentitlementApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find all entitlements at client for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [customerId] Client ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        client: function (employeeId, customerId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/entitlement/client";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get entitlement by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/employee/entitlement/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update employee entitlements in client account.
         * @param {number} employeeId Employee ID
         * @param {number} customerId Client ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantClientEntitlementsByTemplate: function (employeeId, customerId, template, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'employeeId' is not null or undefined
            if (employeeId === null || employeeId === undefined) {
                throw new RequiredError('employeeId', 'Required parameter employeeId was null or undefined when calling grantClientEntitlementsByTemplate.');
            }
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId', 'Required parameter customerId was null or undefined when calling grantClientEntitlementsByTemplate.');
            }
            // verify required parameter 'template' is not null or undefined
            if (template === null || template === undefined) {
                throw new RequiredError('template', 'Required parameter template was null or undefined when calling grantClientEntitlementsByTemplate.');
            }
            var localVarPath = "/employee/entitlement/:grantClientEntitlementsByTemplate";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }
            if (template !== undefined) {
                localVarQueryParameter['template'] = template;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The user will only receive the entitlements which are possible with the registered user type
         * @summary [BETA] Update employee entitlements.
         * @param {number} employeeId Employee ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantEntitlementsByTemplate: function (employeeId, template, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'employeeId' is not null or undefined
            if (employeeId === null || employeeId === undefined) {
                throw new RequiredError('employeeId', 'Required parameter employeeId was null or undefined when calling grantEntitlementsByTemplate.');
            }
            // verify required parameter 'template' is not null or undefined
            if (template === null || template === undefined) {
                throw new RequiredError('template', 'Required parameter template was null or undefined when calling grantEntitlementsByTemplate.');
            }
            var localVarPath = "/employee/entitlement/:grantEntitlementsByTemplate";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (template !== undefined) {
                localVarQueryParameter['template'] = template;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find all entitlements for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/entitlement";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmployeeentitlementApi - functional programming interface
 * @export
 */
exports.EmployeeentitlementApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find all entitlements at client for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [customerId] Client ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        client: function (employeeId, customerId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.EmployeeentitlementApiFetchParamCreator(configuration).client(employeeId, customerId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get entitlement by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.EmployeeentitlementApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update employee entitlements in client account.
         * @param {number} employeeId Employee ID
         * @param {number} customerId Client ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantClientEntitlementsByTemplate: function (employeeId, customerId, template, options) {
            var localVarFetchArgs = exports.EmployeeentitlementApiFetchParamCreator(configuration).grantClientEntitlementsByTemplate(employeeId, customerId, template, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The user will only receive the entitlements which are possible with the registered user type
         * @summary [BETA] Update employee entitlements.
         * @param {number} employeeId Employee ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantEntitlementsByTemplate: function (employeeId, template, options) {
            var localVarFetchArgs = exports.EmployeeentitlementApiFetchParamCreator(configuration).grantEntitlementsByTemplate(employeeId, template, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find all entitlements for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.EmployeeentitlementApiFetchParamCreator(configuration).search(employeeId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmployeeentitlementApi - factory interface
 * @export
 */
exports.EmployeeentitlementApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find all entitlements at client for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [customerId] Client ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        client: function (employeeId, customerId, from, count, sorting, fields, options) {
            return exports.EmployeeentitlementApiFp(configuration).client(employeeId, customerId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get entitlement by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.EmployeeentitlementApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update employee entitlements in client account.
         * @param {number} employeeId Employee ID
         * @param {number} customerId Client ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantClientEntitlementsByTemplate: function (employeeId, customerId, template, options) {
            return exports.EmployeeentitlementApiFp(configuration).grantClientEntitlementsByTemplate(employeeId, customerId, template, options)(fetch, basePath);
        },
        /**
         * The user will only receive the entitlements which are possible with the registered user type
         * @summary [BETA] Update employee entitlements.
         * @param {number} employeeId Employee ID
         * @param {string} template Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantEntitlementsByTemplate: function (employeeId, template, options) {
            return exports.EmployeeentitlementApiFp(configuration).grantEntitlementsByTemplate(employeeId, template, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all entitlements for user.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, from, count, sorting, fields, options) {
            return exports.EmployeeentitlementApiFp(configuration).search(employeeId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * EmployeeentitlementApi - object-oriented interface
 * @export
 * @class EmployeeentitlementApi
 * @extends {BaseAPI}
 */
var EmployeeentitlementApi = /** @class */ (function (_super) {
    __extends(EmployeeentitlementApi, _super);
    function EmployeeentitlementApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find all entitlements at client for user.
     * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {number} [customerId] Client ID
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeentitlementApi
     */
    EmployeeentitlementApi.prototype.client = function (employeeId, customerId, from, count, sorting, fields, options) {
        return exports.EmployeeentitlementApiFp(this.configuration).client(employeeId, customerId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get entitlement by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeentitlementApi
     */
    EmployeeentitlementApi.prototype.get = function (id, fields, options) {
        return exports.EmployeeentitlementApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update employee entitlements in client account.
     * @param {number} employeeId Employee ID
     * @param {number} customerId Client ID
     * @param {string} template Template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeentitlementApi
     */
    EmployeeentitlementApi.prototype.grantClientEntitlementsByTemplate = function (employeeId, customerId, template, options) {
        return exports.EmployeeentitlementApiFp(this.configuration).grantClientEntitlementsByTemplate(employeeId, customerId, template, options)(this.fetch, this.basePath);
    };
    /**
     * The user will only receive the entitlements which are possible with the registered user type
     * @summary [BETA] Update employee entitlements.
     * @param {number} employeeId Employee ID
     * @param {string} template Template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeentitlementApi
     */
    EmployeeentitlementApi.prototype.grantEntitlementsByTemplate = function (employeeId, template, options) {
        return exports.EmployeeentitlementApiFp(this.configuration).grantEntitlementsByTemplate(employeeId, template, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find all entitlements for user.
     * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeentitlementApi
     */
    EmployeeentitlementApi.prototype.search = function (employeeId, from, count, sorting, fields, options) {
        return exports.EmployeeentitlementApiFp(this.configuration).search(employeeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return EmployeeentitlementApi;
}(BaseAPI));
exports.EmployeeentitlementApi = EmployeeentitlementApi;
/**
 * EmployeestandardTimeApi - fetch parameter creator
 * @export
 */
exports.EmployeestandardTimeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find standard time by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/employee/standardTime/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create standard time.
         * @param {StandardTime} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/standardTime";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("StandardTime" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update standard time.
         * @param {number} id Element ID
         * @param {StandardTime} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/employee/standardTime/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("StandardTime" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find all standard times for employee.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/employee/standardTime";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmployeestandardTimeApi - functional programming interface
 * @export
 */
exports.EmployeestandardTimeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find standard time by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.EmployeestandardTimeApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create standard time.
         * @param {StandardTime} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.EmployeestandardTimeApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update standard time.
         * @param {number} id Element ID
         * @param {StandardTime} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.EmployeestandardTimeApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find all standard times for employee.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.EmployeestandardTimeApiFetchParamCreator(configuration).search(employeeId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmployeestandardTimeApi - factory interface
 * @export
 */
exports.EmployeestandardTimeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find standard time by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.EmployeestandardTimeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create standard time.
         * @param {StandardTime} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.EmployeestandardTimeApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update standard time.
         * @param {number} id Element ID
         * @param {StandardTime} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.EmployeestandardTimeApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find all standard times for employee.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, from, count, sorting, fields, options) {
            return exports.EmployeestandardTimeApiFp(configuration).search(employeeId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * EmployeestandardTimeApi - object-oriented interface
 * @export
 * @class EmployeestandardTimeApi
 * @extends {BaseAPI}
 */
var EmployeestandardTimeApi = /** @class */ (function (_super) {
    __extends(EmployeestandardTimeApi, _super);
    function EmployeestandardTimeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find standard time by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeestandardTimeApi
     */
    EmployeestandardTimeApi.prototype.get = function (id, fields, options) {
        return exports.EmployeestandardTimeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create standard time.
     * @param {StandardTime} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeestandardTimeApi
     */
    EmployeestandardTimeApi.prototype.post = function (body, options) {
        return exports.EmployeestandardTimeApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update standard time.
     * @param {number} id Element ID
     * @param {StandardTime} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeestandardTimeApi
     */
    EmployeestandardTimeApi.prototype.put = function (id, body, options) {
        return exports.EmployeestandardTimeApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find all standard times for employee.
     * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeestandardTimeApi
     */
    EmployeestandardTimeApi.prototype.search = function (employeeId, from, count, sorting, fields, options) {
        return exports.EmployeestandardTimeApiFp(this.configuration).search(employeeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return EmployeestandardTimeApi;
}(BaseAPI));
exports.EmployeestandardTimeApi = EmployeestandardTimeApi;
/**
 * EventApi - fetch parameter creator
 * @export
 */
exports.EventApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get all (WebHook) event keys.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/event";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EventApi - functional programming interface
 * @export
 */
exports.EventApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get all (WebHook) event keys.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (fields, options) {
            var localVarFetchArgs = exports.EventApiFetchParamCreator(configuration).get(fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EventApi - factory interface
 * @export
 */
exports.EventApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Get all (WebHook) event keys.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (fields, options) {
            return exports.EventApiFp(configuration).get(fields, options)(fetch, basePath);
        },
    };
};
/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
var EventApi = /** @class */ (function (_super) {
    __extends(EventApi, _super);
    function EventApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Get all (WebHook) event keys.
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    EventApi.prototype.get = function (fields, options) {
        return exports.EventApiFp(this.configuration).get(fields, options)(this.fetch, this.basePath);
    };
    return EventApi;
}(BaseAPI));
exports.EventApi = EventApi;
/**
 * EventsubscriptionApi - fetch parameter creator
 * @export
 */
exports.EventsubscriptionApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete the given subscription.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/event/subscription/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get subscription by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/event/subscription/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create a new subscription for current EmployeeToken.
         * @param {Subscription} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/event/subscription";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Subscription" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Change a current subscription, based on id.
         * @param {number} id Element ID
         * @param {Subscription} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/event/subscription/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Subscription" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find all ongoing subscriptions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/event/subscription";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EventsubscriptionApi - functional programming interface
 * @export
 */
exports.EventsubscriptionApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete the given subscription.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.EventsubscriptionApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get subscription by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.EventsubscriptionApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create a new subscription for current EmployeeToken.
         * @param {Subscription} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.EventsubscriptionApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Change a current subscription, based on id.
         * @param {number} id Element ID
         * @param {Subscription} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.EventsubscriptionApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find all ongoing subscriptions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.EventsubscriptionApiFetchParamCreator(configuration).search(from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EventsubscriptionApi - factory interface
 * @export
 */
exports.EventsubscriptionApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete the given subscription.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.EventsubscriptionApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get subscription by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.EventsubscriptionApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create a new subscription for current EmployeeToken.
         * @param {Subscription} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.EventsubscriptionApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Change a current subscription, based on id.
         * @param {number} id Element ID
         * @param {Subscription} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.EventsubscriptionApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find all ongoing subscriptions.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (from, count, sorting, fields, options) {
            return exports.EventsubscriptionApiFp(configuration).search(from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * EventsubscriptionApi - object-oriented interface
 * @export
 * @class EventsubscriptionApi
 * @extends {BaseAPI}
 */
var EventsubscriptionApi = /** @class */ (function (_super) {
    __extends(EventsubscriptionApi, _super);
    function EventsubscriptionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete the given subscription.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsubscriptionApi
     */
    EventsubscriptionApi.prototype._delete = function (id, options) {
        return exports.EventsubscriptionApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get subscription by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsubscriptionApi
     */
    EventsubscriptionApi.prototype.get = function (id, fields, options) {
        return exports.EventsubscriptionApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create a new subscription for current EmployeeToken.
     * @param {Subscription} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsubscriptionApi
     */
    EventsubscriptionApi.prototype.post = function (body, options) {
        return exports.EventsubscriptionApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Change a current subscription, based on id.
     * @param {number} id Element ID
     * @param {Subscription} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsubscriptionApi
     */
    EventsubscriptionApi.prototype.put = function (id, body, options) {
        return exports.EventsubscriptionApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find all ongoing subscriptions.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsubscriptionApi
     */
    EventsubscriptionApi.prototype.search = function (from, count, sorting, fields, options) {
        return exports.EventsubscriptionApiFp(this.configuration).search(from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return EventsubscriptionApi;
}(BaseAPI));
exports.EventsubscriptionApi = EventsubscriptionApi;
/**
 * InventoryApi - fetch parameter creator
 * @export
 */
exports.InventoryApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get inventory by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/inventory/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find inventory corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {boolean} [isMainInventory] Equals
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, isMainInventory, isInactive, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inventory";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (isMainInventory !== undefined) {
                localVarQueryParameter['isMainInventory'] = isMainInventory;
            }
            if (isInactive !== undefined) {
                localVarQueryParameter['isInactive'] = isInactive;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * InventoryApi - functional programming interface
 * @export
 */
exports.InventoryApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get inventory by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.InventoryApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find inventory corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {boolean} [isMainInventory] Equals
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, isMainInventory, isInactive, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.InventoryApiFetchParamCreator(configuration).search(id, name, isMainInventory, isInactive, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * InventoryApi - factory interface
 * @export
 */
exports.InventoryApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get inventory by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.InventoryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find inventory corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {boolean} [isMainInventory] Equals
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, isMainInventory, isInactive, from, count, sorting, fields, options) {
            return exports.InventoryApiFp(configuration).search(id, name, isMainInventory, isInactive, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
var InventoryApi = /** @class */ (function (_super) {
    __extends(InventoryApi, _super);
    function InventoryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get inventory by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    InventoryApi.prototype.get = function (id, fields, options) {
        return exports.InventoryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find inventory corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [name] Containing
     * @param {boolean} [isMainInventory] Equals
     * @param {boolean} [isInactive] Equals
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    InventoryApi.prototype.search = function (id, name, isMainInventory, isInactive, from, count, sorting, fields, options) {
        return exports.InventoryApiFp(this.configuration).search(id, name, isMainInventory, isInactive, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return InventoryApi;
}(BaseAPI));
exports.InventoryApi = InventoryApi;
/**
 * InvoiceApi - fetch parameter creator
 * @export
 */
exports.InvoiceApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get invoice document by invoice ID.
         * @param {number} invoiceId Invoice ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf: function (invoiceId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling downloadPdf.');
            }
            var localVarPath = "/invoice/{invoiceId}/pdf"
                .replace("{" + "invoiceId" + "}", encodeURIComponent(String(invoiceId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get invoice by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/invoice/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update invoice. The invoice is updated with payment information. The amount is in the invoice’s currency.
         * @param {number} id Invoice id
         * @param {string} paymentDate Payment date
         * @param {number} paymentTypeId PaymentType id
         * @param {number} paidAmount Amount paid by customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payment: function (id, paymentDate, paymentTypeId, paidAmount, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling payment.');
            }
            // verify required parameter 'paymentDate' is not null or undefined
            if (paymentDate === null || paymentDate === undefined) {
                throw new RequiredError('paymentDate', 'Required parameter paymentDate was null or undefined when calling payment.');
            }
            // verify required parameter 'paymentTypeId' is not null or undefined
            if (paymentTypeId === null || paymentTypeId === undefined) {
                throw new RequiredError('paymentTypeId', 'Required parameter paymentTypeId was null or undefined when calling payment.');
            }
            // verify required parameter 'paidAmount' is not null or undefined
            if (paidAmount === null || paidAmount === undefined) {
                throw new RequiredError('paidAmount', 'Required parameter paidAmount was null or undefined when calling payment.');
            }
            var localVarPath = "/invoice/{id}/:payment"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (paymentDate !== undefined) {
                localVarQueryParameter['paymentDate'] = paymentDate;
            }
            if (paymentTypeId !== undefined) {
                localVarQueryParameter['paymentTypeId'] = paymentTypeId;
            }
            if (paidAmount !== undefined) {
                localVarQueryParameter['paidAmount'] = paidAmount;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create invoice.
         * @param {Invoice} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {boolean} [sendToCustomer] Equals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, sendToCustomer, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/invoice";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (sendToCustomer !== undefined) {
                localVarQueryParameter['sendToCustomer'] = sendToCustomer;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Invoice" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find invoices corresponding with sent data.
         * @param {string} invoiceDateFrom From and including
         * @param {string} invoiceDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [invoiceNumber] Equals
         * @param {string} [kid] Equals
         * @param {string} [voucherId] Equals
         * @param {string} [customerId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (invoiceDateFrom, invoiceDateTo, id, invoiceNumber, kid, voucherId, customerId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'invoiceDateFrom' is not null or undefined
            if (invoiceDateFrom === null || invoiceDateFrom === undefined) {
                throw new RequiredError('invoiceDateFrom', 'Required parameter invoiceDateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'invoiceDateTo' is not null or undefined
            if (invoiceDateTo === null || invoiceDateTo === undefined) {
                throw new RequiredError('invoiceDateTo', 'Required parameter invoiceDateTo was null or undefined when calling search.');
            }
            var localVarPath = "/invoice";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (invoiceDateFrom !== undefined) {
                localVarQueryParameter['invoiceDateFrom'] = invoiceDateFrom;
            }
            if (invoiceDateTo !== undefined) {
                localVarQueryParameter['invoiceDateTo'] = invoiceDateTo;
            }
            if (invoiceNumber !== undefined) {
                localVarQueryParameter['invoiceNumber'] = invoiceNumber;
            }
            if (kid !== undefined) {
                localVarQueryParameter['kid'] = kid;
            }
            if (voucherId !== undefined) {
                localVarQueryParameter['voucherId'] = voucherId;
            }
            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Send invoice by ID and sendType. Optionally override email recipient.
         * @param {number} id Element ID
         * @param {string} sendType SendType
         * @param {string} [overrideEmailAddress] Will override email address if sendType &#x3D; EMAIL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send: function (id, sendType, overrideEmailAddress, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling send.');
            }
            // verify required parameter 'sendType' is not null or undefined
            if (sendType === null || sendType === undefined) {
                throw new RequiredError('sendType', 'Required parameter sendType was null or undefined when calling send.');
            }
            var localVarPath = "/invoice/{id}/:send"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (sendType !== undefined) {
                localVarQueryParameter['sendType'] = sendType;
            }
            if (overrideEmailAddress !== undefined) {
                localVarQueryParameter['overrideEmailAddress'] = overrideEmailAddress;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * InvoiceApi - functional programming interface
 * @export
 */
exports.InvoiceApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get invoice document by invoice ID.
         * @param {number} invoiceId Invoice ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf: function (invoiceId, options) {
            var localVarFetchArgs = exports.InvoiceApiFetchParamCreator(configuration).downloadPdf(invoiceId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get invoice by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.InvoiceApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update invoice. The invoice is updated with payment information. The amount is in the invoice’s currency.
         * @param {number} id Invoice id
         * @param {string} paymentDate Payment date
         * @param {number} paymentTypeId PaymentType id
         * @param {number} paidAmount Amount paid by customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payment: function (id, paymentDate, paymentTypeId, paidAmount, options) {
            var localVarFetchArgs = exports.InvoiceApiFetchParamCreator(configuration).payment(id, paymentDate, paymentTypeId, paidAmount, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create invoice.
         * @param {Invoice} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {boolean} [sendToCustomer] Equals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, sendToCustomer, options) {
            var localVarFetchArgs = exports.InvoiceApiFetchParamCreator(configuration).post(body, sendToCustomer, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find invoices corresponding with sent data.
         * @param {string} invoiceDateFrom From and including
         * @param {string} invoiceDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [invoiceNumber] Equals
         * @param {string} [kid] Equals
         * @param {string} [voucherId] Equals
         * @param {string} [customerId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (invoiceDateFrom, invoiceDateTo, id, invoiceNumber, kid, voucherId, customerId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.InvoiceApiFetchParamCreator(configuration).search(invoiceDateFrom, invoiceDateTo, id, invoiceNumber, kid, voucherId, customerId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Send invoice by ID and sendType. Optionally override email recipient.
         * @param {number} id Element ID
         * @param {string} sendType SendType
         * @param {string} [overrideEmailAddress] Will override email address if sendType &#x3D; EMAIL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send: function (id, sendType, overrideEmailAddress, options) {
            var localVarFetchArgs = exports.InvoiceApiFetchParamCreator(configuration).send(id, sendType, overrideEmailAddress, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * InvoiceApi - factory interface
 * @export
 */
exports.InvoiceApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get invoice document by invoice ID.
         * @param {number} invoiceId Invoice ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf: function (invoiceId, options) {
            return exports.InvoiceApiFp(configuration).downloadPdf(invoiceId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get invoice by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.InvoiceApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update invoice. The invoice is updated with payment information. The amount is in the invoice’s currency.
         * @param {number} id Invoice id
         * @param {string} paymentDate Payment date
         * @param {number} paymentTypeId PaymentType id
         * @param {number} paidAmount Amount paid by customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payment: function (id, paymentDate, paymentTypeId, paidAmount, options) {
            return exports.InvoiceApiFp(configuration).payment(id, paymentDate, paymentTypeId, paidAmount, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create invoice.
         * @param {Invoice} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {boolean} [sendToCustomer] Equals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, sendToCustomer, options) {
            return exports.InvoiceApiFp(configuration).post(body, sendToCustomer, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find invoices corresponding with sent data.
         * @param {string} invoiceDateFrom From and including
         * @param {string} invoiceDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [invoiceNumber] Equals
         * @param {string} [kid] Equals
         * @param {string} [voucherId] Equals
         * @param {string} [customerId] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (invoiceDateFrom, invoiceDateTo, id, invoiceNumber, kid, voucherId, customerId, from, count, sorting, fields, options) {
            return exports.InvoiceApiFp(configuration).search(invoiceDateFrom, invoiceDateTo, id, invoiceNumber, kid, voucherId, customerId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Send invoice by ID and sendType. Optionally override email recipient.
         * @param {number} id Element ID
         * @param {string} sendType SendType
         * @param {string} [overrideEmailAddress] Will override email address if sendType &#x3D; EMAIL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send: function (id, sendType, overrideEmailAddress, options) {
            return exports.InvoiceApiFp(configuration).send(id, sendType, overrideEmailAddress, options)(fetch, basePath);
        },
    };
};
/**
 * InvoiceApi - object-oriented interface
 * @export
 * @class InvoiceApi
 * @extends {BaseAPI}
 */
var InvoiceApi = /** @class */ (function (_super) {
    __extends(InvoiceApi, _super);
    function InvoiceApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get invoice document by invoice ID.
     * @param {number} invoiceId Invoice ID from which PDF is downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    InvoiceApi.prototype.downloadPdf = function (invoiceId, options) {
        return exports.InvoiceApiFp(this.configuration).downloadPdf(invoiceId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get invoice by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    InvoiceApi.prototype.get = function (id, fields, options) {
        return exports.InvoiceApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update invoice. The invoice is updated with payment information. The amount is in the invoice’s currency.
     * @param {number} id Invoice id
     * @param {string} paymentDate Payment date
     * @param {number} paymentTypeId PaymentType id
     * @param {number} paidAmount Amount paid by customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    InvoiceApi.prototype.payment = function (id, paymentDate, paymentTypeId, paidAmount, options) {
        return exports.InvoiceApiFp(this.configuration).payment(id, paymentDate, paymentTypeId, paidAmount, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create invoice.
     * @param {Invoice} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {boolean} [sendToCustomer] Equals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    InvoiceApi.prototype.post = function (body, sendToCustomer, options) {
        return exports.InvoiceApiFp(this.configuration).post(body, sendToCustomer, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find invoices corresponding with sent data.
     * @param {string} invoiceDateFrom From and including
     * @param {string} invoiceDateTo To and excluding
     * @param {string} [id] List of IDs
     * @param {string} [invoiceNumber] Equals
     * @param {string} [kid] Equals
     * @param {string} [voucherId] Equals
     * @param {string} [customerId] Equals
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    InvoiceApi.prototype.search = function (invoiceDateFrom, invoiceDateTo, id, invoiceNumber, kid, voucherId, customerId, from, count, sorting, fields, options) {
        return exports.InvoiceApiFp(this.configuration).search(invoiceDateFrom, invoiceDateTo, id, invoiceNumber, kid, voucherId, customerId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Send invoice by ID and sendType. Optionally override email recipient.
     * @param {number} id Element ID
     * @param {string} sendType SendType
     * @param {string} [overrideEmailAddress] Will override email address if sendType &#x3D; EMAIL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    InvoiceApi.prototype.send = function (id, sendType, overrideEmailAddress, options) {
        return exports.InvoiceApiFp(this.configuration).send(id, sendType, overrideEmailAddress, options)(this.fetch, this.basePath);
    };
    return InvoiceApi;
}(BaseAPI));
exports.InvoiceApi = InvoiceApi;
/**
 * InvoicepaymentTypeApi - fetch parameter creator
 * @export
 */
exports.InvoicepaymentTypeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/invoice/paymentType/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/invoice/paymentType";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * InvoicepaymentTypeApi - functional programming interface
 * @export
 */
exports.InvoicepaymentTypeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.InvoicepaymentTypeApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.InvoicepaymentTypeApiFetchParamCreator(configuration).search(id, description, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * InvoicepaymentTypeApi - factory interface
 * @export
 */
exports.InvoicepaymentTypeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.InvoicepaymentTypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            return exports.InvoicepaymentTypeApiFp(configuration).search(id, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * InvoicepaymentTypeApi - object-oriented interface
 * @export
 * @class InvoicepaymentTypeApi
 * @extends {BaseAPI}
 */
var InvoicepaymentTypeApi = /** @class */ (function (_super) {
    __extends(InvoicepaymentTypeApi, _super);
    function InvoicepaymentTypeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get payment type by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicepaymentTypeApi
     */
    InvoicepaymentTypeApi.prototype.get = function (id, fields, options) {
        return exports.InvoicepaymentTypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find payment type corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [description] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicepaymentTypeApi
     */
    InvoicepaymentTypeApi.prototype.search = function (id, description, from, count, sorting, fields, options) {
        return exports.InvoicepaymentTypeApiFp(this.configuration).search(id, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return InvoicepaymentTypeApi;
}(BaseAPI));
exports.InvoicepaymentTypeApi = InvoicepaymentTypeApi;
/**
 * LedgerApi - fetch parameter creator
 * @export
 */
exports.LedgerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost: function (date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date', 'Required parameter date was null or undefined when calling openPost.');
            }
            var localVarPath = "/ledger/openPost";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (supplierId !== undefined) {
                localVarQueryParameter['supplierId'] = supplierId;
            }
            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get ledger (hovedbok).
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom', 'Required parameter dateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'dateTo' is not null or undefined
            if (dateTo === null || dateTo === undefined) {
                throw new RequiredError('dateTo', 'Required parameter dateTo was null or undefined when calling search.');
            }
            var localVarPath = "/ledger";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }
            if (openPostings !== undefined) {
                localVarQueryParameter['openPostings'] = openPostings;
            }
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (supplierId !== undefined) {
                localVarQueryParameter['supplierId'] = supplierId;
            }
            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LedgerApi - functional programming interface
 * @export
 */
exports.LedgerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost: function (date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options) {
            var localVarFetchArgs = exports.LedgerApiFetchParamCreator(configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get ledger (hovedbok).
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options) {
            var localVarFetchArgs = exports.LedgerApiFetchParamCreator(configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * LedgerApi - factory interface
 * @export
 */
exports.LedgerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost: function (date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options) {
            return exports.LedgerApiFp(configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get ledger (hovedbok).
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options) {
            return exports.LedgerApiFp(configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options)(fetch, basePath);
        },
    };
};
/**
 * LedgerApi - object-oriented interface
 * @export
 * @class LedgerApi
 * @extends {BaseAPI}
 */
var LedgerApi = /** @class */ (function (_super) {
    __extends(LedgerApi, _super);
    function LedgerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Find open posts corresponding with sent data.
     * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
     * @param {number} [accountId] Element ID
     * @param {number} [supplierId] Element ID
     * @param {number} [customerId] Element ID
     * @param {number} [employeeId] Element ID
     * @param {number} [departmentId] Element ID
     * @param {number} [projectId] Element ID
     * @param {number} [productId] Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerApi
     */
    LedgerApi.prototype.openPost = function (date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options) {
        return exports.LedgerApiFp(this.configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get ledger (hovedbok).
     * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
     * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
     * @param {string} [openPostings] Deprecated
     * @param {number} [accountId] Element ID
     * @param {number} [supplierId] Element ID
     * @param {number} [customerId] Element ID
     * @param {number} [employeeId] Element ID
     * @param {number} [departmentId] Element ID
     * @param {number} [projectId] Element ID
     * @param {number} [productId] Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerApi
     */
    LedgerApi.prototype.search = function (dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options) {
        return exports.LedgerApiFp(this.configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, fields, from, count, sorting, options)(this.fetch, this.basePath);
    };
    return LedgerApi;
}(BaseAPI));
exports.LedgerApi = LedgerApi;
/**
 * LedgeraccountApi - fetch parameter creator
 * @export
 */
exports.LedgeraccountApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete account.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/ledger/account/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Delete multiple accounts.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds: function (ids, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids', 'Required parameter ids was null or undefined when calling deleteByIds.');
            }
            var localVarPath = "/ledger/account/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/ledger/account/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create a new account.
         * @param {Account} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/account";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Account" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create several accounts.
         * @param {Array<Account>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/account/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;Account&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update account.
         * @param {number} id Element ID
         * @param {Account} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/ledger/account/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Account" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update multiple accounts.
         * @param {Array<Account>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/account/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;Account&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {boolean} [isBankAccount] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, number, isBankAccount, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/account";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }
            if (isBankAccount !== undefined) {
                localVarQueryParameter['isBankAccount'] = isBankAccount;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LedgeraccountApi - functional programming interface
 * @export
 */
exports.LedgeraccountApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete account.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.LedgeraccountApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Delete multiple accounts.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds: function (ids, options) {
            var localVarFetchArgs = exports.LedgeraccountApiFetchParamCreator(configuration).deleteByIds(ids, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.LedgeraccountApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create a new account.
         * @param {Account} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.LedgeraccountApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create several accounts.
         * @param {Array<Account>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            var localVarFetchArgs = exports.LedgeraccountApiFetchParamCreator(configuration).postList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update account.
         * @param {number} id Element ID
         * @param {Account} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.LedgeraccountApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update multiple accounts.
         * @param {Array<Account>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            var localVarFetchArgs = exports.LedgeraccountApiFetchParamCreator(configuration).putList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {boolean} [isBankAccount] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, number, isBankAccount, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.LedgeraccountApiFetchParamCreator(configuration).search(id, number, isBankAccount, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * LedgeraccountApi - factory interface
 * @export
 */
exports.LedgeraccountApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete account.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.LedgeraccountApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Delete multiple accounts.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds: function (ids, options) {
            return exports.LedgeraccountApiFp(configuration).deleteByIds(ids, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.LedgeraccountApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create a new account.
         * @param {Account} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.LedgeraccountApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create several accounts.
         * @param {Array<Account>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            return exports.LedgeraccountApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update account.
         * @param {number} id Element ID
         * @param {Account} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.LedgeraccountApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update multiple accounts.
         * @param {Array<Account>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            return exports.LedgeraccountApiFp(configuration).putList(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {boolean} [isBankAccount] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, number, isBankAccount, from, count, sorting, fields, options) {
            return exports.LedgeraccountApiFp(configuration).search(id, number, isBankAccount, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * LedgeraccountApi - object-oriented interface
 * @export
 * @class LedgeraccountApi
 * @extends {BaseAPI}
 */
var LedgeraccountApi = /** @class */ (function (_super) {
    __extends(LedgeraccountApi, _super);
    function LedgeraccountApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete account.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    LedgeraccountApi.prototype._delete = function (id, options) {
        return exports.LedgeraccountApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Delete multiple accounts.
     * @param {string} ids ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    LedgeraccountApi.prototype.deleteByIds = function (ids, options) {
        return exports.LedgeraccountApiFp(this.configuration).deleteByIds(ids, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get account by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    LedgeraccountApi.prototype.get = function (id, fields, options) {
        return exports.LedgeraccountApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create a new account.
     * @param {Account} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    LedgeraccountApi.prototype.post = function (body, options) {
        return exports.LedgeraccountApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create several accounts.
     * @param {Array<Account>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    LedgeraccountApi.prototype.postList = function (body, options) {
        return exports.LedgeraccountApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update account.
     * @param {number} id Element ID
     * @param {Account} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    LedgeraccountApi.prototype.put = function (id, body, options) {
        return exports.LedgeraccountApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update multiple accounts.
     * @param {Array<Account>} [body] JSON representing updates to object. Should have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    LedgeraccountApi.prototype.putList = function (body, options) {
        return exports.LedgeraccountApiFp(this.configuration).putList(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find accounts corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [number] List of IDs
     * @param {boolean} [isBankAccount] Equals
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountApi
     */
    LedgeraccountApi.prototype.search = function (id, number, isBankAccount, from, count, sorting, fields, options) {
        return exports.LedgeraccountApiFp(this.configuration).search(id, number, isBankAccount, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return LedgeraccountApi;
}(BaseAPI));
exports.LedgeraccountApi = LedgeraccountApi;
/**
 * LedgeraccountingPeriodApi - fetch parameter creator
 * @export
 */
exports.LedgeraccountingPeriodApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get accounting period by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/ledger/accountingPeriod/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find accounting periods corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [startFrom] From and including
         * @param {string} [startTo] To and excluding
         * @param {string} [endFrom] From and including
         * @param {string} [endTo] To and excluding
         * @param {number} [count] Number of elements to return
         * @param {number} [from] From index
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, numberFrom, numberTo, startFrom, startTo, endFrom, endTo, count, from, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/accountingPeriod";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (numberFrom !== undefined) {
                localVarQueryParameter['numberFrom'] = numberFrom;
            }
            if (numberTo !== undefined) {
                localVarQueryParameter['numberTo'] = numberTo;
            }
            if (startFrom !== undefined) {
                localVarQueryParameter['startFrom'] = startFrom;
            }
            if (startTo !== undefined) {
                localVarQueryParameter['startTo'] = startTo;
            }
            if (endFrom !== undefined) {
                localVarQueryParameter['endFrom'] = endFrom;
            }
            if (endTo !== undefined) {
                localVarQueryParameter['endTo'] = endTo;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LedgeraccountingPeriodApi - functional programming interface
 * @export
 */
exports.LedgeraccountingPeriodApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get accounting period by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.LedgeraccountingPeriodApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find accounting periods corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [startFrom] From and including
         * @param {string} [startTo] To and excluding
         * @param {string} [endFrom] From and including
         * @param {string} [endTo] To and excluding
         * @param {number} [count] Number of elements to return
         * @param {number} [from] From index
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, numberFrom, numberTo, startFrom, startTo, endFrom, endTo, count, from, sorting, fields, options) {
            var localVarFetchArgs = exports.LedgeraccountingPeriodApiFetchParamCreator(configuration).search(id, numberFrom, numberTo, startFrom, startTo, endFrom, endTo, count, from, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * LedgeraccountingPeriodApi - factory interface
 * @export
 */
exports.LedgeraccountingPeriodApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get accounting period by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.LedgeraccountingPeriodApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find accounting periods corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [startFrom] From and including
         * @param {string} [startTo] To and excluding
         * @param {string} [endFrom] From and including
         * @param {string} [endTo] To and excluding
         * @param {number} [count] Number of elements to return
         * @param {number} [from] From index
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, numberFrom, numberTo, startFrom, startTo, endFrom, endTo, count, from, sorting, fields, options) {
            return exports.LedgeraccountingPeriodApiFp(configuration).search(id, numberFrom, numberTo, startFrom, startTo, endFrom, endTo, count, from, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * LedgeraccountingPeriodApi - object-oriented interface
 * @export
 * @class LedgeraccountingPeriodApi
 * @extends {BaseAPI}
 */
var LedgeraccountingPeriodApi = /** @class */ (function (_super) {
    __extends(LedgeraccountingPeriodApi, _super);
    function LedgeraccountingPeriodApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get accounting period by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountingPeriodApi
     */
    LedgeraccountingPeriodApi.prototype.get = function (id, fields, options) {
        return exports.LedgeraccountingPeriodApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find accounting periods corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {number} [numberFrom] From and including
     * @param {number} [numberTo] To and excluding
     * @param {string} [startFrom] From and including
     * @param {string} [startTo] To and excluding
     * @param {string} [endFrom] From and including
     * @param {string} [endTo] To and excluding
     * @param {number} [count] Number of elements to return
     * @param {number} [from] From index
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgeraccountingPeriodApi
     */
    LedgeraccountingPeriodApi.prototype.search = function (id, numberFrom, numberTo, startFrom, startTo, endFrom, endTo, count, from, sorting, fields, options) {
        return exports.LedgeraccountingPeriodApiFp(this.configuration).search(id, numberFrom, numberTo, startFrom, startTo, endFrom, endTo, count, from, sorting, fields, options)(this.fetch, this.basePath);
    };
    return LedgeraccountingPeriodApi;
}(BaseAPI));
exports.LedgeraccountingPeriodApi = LedgeraccountingPeriodApi;
/**
 * LedgerannualAccountApi - fetch parameter creator
 * @export
 */
exports.LedgerannualAccountApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get annual account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/ledger/annualAccount/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find annual accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, yearFrom, yearTo, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/annualAccount";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (yearFrom !== undefined) {
                localVarQueryParameter['yearFrom'] = yearFrom;
            }
            if (yearTo !== undefined) {
                localVarQueryParameter['yearTo'] = yearTo;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LedgerannualAccountApi - functional programming interface
 * @export
 */
exports.LedgerannualAccountApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get annual account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.LedgerannualAccountApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find annual accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, yearFrom, yearTo, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.LedgerannualAccountApiFetchParamCreator(configuration).search(id, yearFrom, yearTo, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * LedgerannualAccountApi - factory interface
 * @export
 */
exports.LedgerannualAccountApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get annual account by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.LedgerannualAccountApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find annual accounts corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, yearFrom, yearTo, from, count, sorting, fields, options) {
            return exports.LedgerannualAccountApiFp(configuration).search(id, yearFrom, yearTo, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * LedgerannualAccountApi - object-oriented interface
 * @export
 * @class LedgerannualAccountApi
 * @extends {BaseAPI}
 */
var LedgerannualAccountApi = /** @class */ (function (_super) {
    __extends(LedgerannualAccountApi, _super);
    function LedgerannualAccountApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get annual account by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerannualAccountApi
     */
    LedgerannualAccountApi.prototype.get = function (id, fields, options) {
        return exports.LedgerannualAccountApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find annual accounts corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {number} [yearFrom] From and including
     * @param {number} [yearTo] To and excluding
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerannualAccountApi
     */
    LedgerannualAccountApi.prototype.search = function (id, yearFrom, yearTo, from, count, sorting, fields, options) {
        return exports.LedgerannualAccountApiFp(this.configuration).search(id, yearFrom, yearTo, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return LedgerannualAccountApi;
}(BaseAPI));
exports.LedgerannualAccountApi = LedgerannualAccountApi;
/**
 * LedgercloseGroupApi - fetch parameter creator
 * @export
 */
exports.LedgercloseGroupApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get close group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/ledger/closeGroup/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find close groups corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, id, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom', 'Required parameter dateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'dateTo' is not null or undefined
            if (dateTo === null || dateTo === undefined) {
                throw new RequiredError('dateTo', 'Required parameter dateTo was null or undefined when calling search.');
            }
            var localVarPath = "/ledger/closeGroup";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LedgercloseGroupApi - functional programming interface
 * @export
 */
exports.LedgercloseGroupApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get close group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.LedgercloseGroupApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find close groups corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, id, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.LedgercloseGroupApiFetchParamCreator(configuration).search(dateFrom, dateTo, id, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * LedgercloseGroupApi - factory interface
 * @export
 */
exports.LedgercloseGroupApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get close group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.LedgercloseGroupApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find close groups corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, id, from, count, sorting, fields, options) {
            return exports.LedgercloseGroupApiFp(configuration).search(dateFrom, dateTo, id, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * LedgercloseGroupApi - object-oriented interface
 * @export
 * @class LedgercloseGroupApi
 * @extends {BaseAPI}
 */
var LedgercloseGroupApi = /** @class */ (function (_super) {
    __extends(LedgercloseGroupApi, _super);
    function LedgercloseGroupApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get close group by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgercloseGroupApi
     */
    LedgercloseGroupApi.prototype.get = function (id, fields, options) {
        return exports.LedgercloseGroupApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find close groups corresponding with sent data.
     * @param {string} dateFrom From and including
     * @param {string} dateTo To and excluding
     * @param {string} [id] List of IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgercloseGroupApi
     */
    LedgercloseGroupApi.prototype.search = function (dateFrom, dateTo, id, from, count, sorting, fields, options) {
        return exports.LedgercloseGroupApiFp(this.configuration).search(dateFrom, dateTo, id, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return LedgercloseGroupApi;
}(BaseAPI));
exports.LedgercloseGroupApi = LedgercloseGroupApi;
/**
 * LedgerpaymentTypeOutApi - fetch parameter creator
 * @export
 */
exports.LedgerpaymentTypeOutApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/ledger/paymentTypeOut/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/ledger/paymentTypeOut/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create new payment type for outgoing payments
         * @param {PaymentTypeOut} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/paymentTypeOut";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PaymentTypeOut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create multiple payment types for outgoing payments at once
         * @param {Array<PaymentTypeOut>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/paymentTypeOut/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;PaymentTypeOut&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update existing payment type for outgoing payments
         * @param {number} id Element ID
         * @param {PaymentTypeOut} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/ledger/paymentTypeOut/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PaymentTypeOut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update multiple payment types for outgoing payments at once
         * @param {Array<PaymentTypeOut>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/paymentTypeOut/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;PaymentTypeOut&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is an API endpoint for getting payment types for outgoing payments. This is equivalent to the section 'Outgoing Payments' under Accounts Settings in Tripletex. These are the payment types listed in supplier invoices, vat returns, salary payments and Tax/ENI
         * @summary [BETA] Gets payment types for outgoing payments
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, isInactive, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/paymentTypeOut";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (isInactive !== undefined) {
                localVarQueryParameter['isInactive'] = isInactive;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LedgerpaymentTypeOutApi - functional programming interface
 * @export
 */
exports.LedgerpaymentTypeOutApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.LedgerpaymentTypeOutApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.LedgerpaymentTypeOutApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create new payment type for outgoing payments
         * @param {PaymentTypeOut} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.LedgerpaymentTypeOutApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create multiple payment types for outgoing payments at once
         * @param {Array<PaymentTypeOut>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            var localVarFetchArgs = exports.LedgerpaymentTypeOutApiFetchParamCreator(configuration).postList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update existing payment type for outgoing payments
         * @param {number} id Element ID
         * @param {PaymentTypeOut} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.LedgerpaymentTypeOutApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update multiple payment types for outgoing payments at once
         * @param {Array<PaymentTypeOut>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            var localVarFetchArgs = exports.LedgerpaymentTypeOutApiFetchParamCreator(configuration).putList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This is an API endpoint for getting payment types for outgoing payments. This is equivalent to the section 'Outgoing Payments' under Accounts Settings in Tripletex. These are the payment types listed in supplier invoices, vat returns, salary payments and Tax/ENI
         * @summary [BETA] Gets payment types for outgoing payments
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, isInactive, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.LedgerpaymentTypeOutApiFetchParamCreator(configuration).search(id, description, isInactive, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * LedgerpaymentTypeOutApi - factory interface
 * @export
 */
exports.LedgerpaymentTypeOutApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.LedgerpaymentTypeOutApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get payment type for outgoing payments by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.LedgerpaymentTypeOutApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create new payment type for outgoing payments
         * @param {PaymentTypeOut} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.LedgerpaymentTypeOutApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create multiple payment types for outgoing payments at once
         * @param {Array<PaymentTypeOut>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            return exports.LedgerpaymentTypeOutApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update existing payment type for outgoing payments
         * @param {number} id Element ID
         * @param {PaymentTypeOut} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.LedgerpaymentTypeOutApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update multiple payment types for outgoing payments at once
         * @param {Array<PaymentTypeOut>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            return exports.LedgerpaymentTypeOutApiFp(configuration).putList(body, options)(fetch, basePath);
        },
        /**
         * This is an API endpoint for getting payment types for outgoing payments. This is equivalent to the section 'Outgoing Payments' under Accounts Settings in Tripletex. These are the payment types listed in supplier invoices, vat returns, salary payments and Tax/ENI
         * @summary [BETA] Gets payment types for outgoing payments
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {boolean} [isInactive] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, isInactive, from, count, sorting, fields, options) {
            return exports.LedgerpaymentTypeOutApiFp(configuration).search(id, description, isInactive, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * LedgerpaymentTypeOutApi - object-oriented interface
 * @export
 * @class LedgerpaymentTypeOutApi
 * @extends {BaseAPI}
 */
var LedgerpaymentTypeOutApi = /** @class */ (function (_super) {
    __extends(LedgerpaymentTypeOutApi, _super);
    function LedgerpaymentTypeOutApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete payment type for outgoing payments by ID.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    LedgerpaymentTypeOutApi.prototype._delete = function (id, options) {
        return exports.LedgerpaymentTypeOutApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get payment type for outgoing payments by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    LedgerpaymentTypeOutApi.prototype.get = function (id, fields, options) {
        return exports.LedgerpaymentTypeOutApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create new payment type for outgoing payments
     * @param {PaymentTypeOut} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    LedgerpaymentTypeOutApi.prototype.post = function (body, options) {
        return exports.LedgerpaymentTypeOutApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create multiple payment types for outgoing payments at once
     * @param {Array<PaymentTypeOut>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    LedgerpaymentTypeOutApi.prototype.postList = function (body, options) {
        return exports.LedgerpaymentTypeOutApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update existing payment type for outgoing payments
     * @param {number} id Element ID
     * @param {PaymentTypeOut} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    LedgerpaymentTypeOutApi.prototype.put = function (id, body, options) {
        return exports.LedgerpaymentTypeOutApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update multiple payment types for outgoing payments at once
     * @param {Array<PaymentTypeOut>} [body] JSON representing updates to object. Should have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    LedgerpaymentTypeOutApi.prototype.putList = function (body, options) {
        return exports.LedgerpaymentTypeOutApiFp(this.configuration).putList(body, options)(this.fetch, this.basePath);
    };
    /**
     * This is an API endpoint for getting payment types for outgoing payments. This is equivalent to the section 'Outgoing Payments' under Accounts Settings in Tripletex. These are the payment types listed in supplier invoices, vat returns, salary payments and Tax/ENI
     * @summary [BETA] Gets payment types for outgoing payments
     * @param {string} [id] List of IDs
     * @param {string} [description] Containing
     * @param {boolean} [isInactive] Equals
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpaymentTypeOutApi
     */
    LedgerpaymentTypeOutApi.prototype.search = function (id, description, isInactive, from, count, sorting, fields, options) {
        return exports.LedgerpaymentTypeOutApiFp(this.configuration).search(id, description, isInactive, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return LedgerpaymentTypeOutApi;
}(BaseAPI));
exports.LedgerpaymentTypeOutApi = LedgerpaymentTypeOutApi;
/**
 * LedgerpostingApi - fetch parameter creator
 * @export
 */
exports.LedgerpostingApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Find postings by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/ledger/posting/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost: function (date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date', 'Required parameter date was null or undefined when calling openPost.');
            }
            var localVarPath = "/ledger/posting/openPost";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (supplierId !== undefined) {
                localVarQueryParameter['supplierId'] = supplierId;
            }
            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find postings corresponding with sent data.
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom', 'Required parameter dateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'dateTo' is not null or undefined
            if (dateTo === null || dateTo === undefined) {
                throw new RequiredError('dateTo', 'Required parameter dateTo was null or undefined when calling search.');
            }
            var localVarPath = "/ledger/posting";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }
            if (openPostings !== undefined) {
                localVarQueryParameter['openPostings'] = openPostings;
            }
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (supplierId !== undefined) {
                localVarQueryParameter['supplierId'] = supplierId;
            }
            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LedgerpostingApi - functional programming interface
 * @export
 */
exports.LedgerpostingApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Find postings by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.LedgerpostingApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost: function (date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.LedgerpostingApiFetchParamCreator(configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find postings corresponding with sent data.
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.LedgerpostingApiFetchParamCreator(configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * LedgerpostingApi - factory interface
 * @export
 */
exports.LedgerpostingApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Find postings by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.LedgerpostingApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find open posts corresponding with sent data.
         * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openPost: function (date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options) {
            return exports.LedgerpostingApiFp(configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find postings corresponding with sent data.
         * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
         * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
         * @param {string} [openPostings] Deprecated
         * @param {number} [accountId] Element ID
         * @param {number} [supplierId] Element ID
         * @param {number} [customerId] Element ID
         * @param {number} [employeeId] Element ID
         * @param {number} [departmentId] Element ID
         * @param {number} [projectId] Element ID
         * @param {number} [productId] Element ID
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options) {
            return exports.LedgerpostingApiFp(configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * LedgerpostingApi - object-oriented interface
 * @export
 * @class LedgerpostingApi
 * @extends {BaseAPI}
 */
var LedgerpostingApi = /** @class */ (function (_super) {
    __extends(LedgerpostingApi, _super);
    function LedgerpostingApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Find postings by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpostingApi
     */
    LedgerpostingApi.prototype.get = function (id, fields, options) {
        return exports.LedgerpostingApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find open posts corresponding with sent data.
     * @param {string} date Invoice date. Format is yyyy-MM-dd (to and excl.).
     * @param {number} [accountId] Element ID
     * @param {number} [supplierId] Element ID
     * @param {number} [customerId] Element ID
     * @param {number} [employeeId] Element ID
     * @param {number} [departmentId] Element ID
     * @param {number} [projectId] Element ID
     * @param {number} [productId] Element ID
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpostingApi
     */
    LedgerpostingApi.prototype.openPost = function (date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options) {
        return exports.LedgerpostingApiFp(this.configuration).openPost(date, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find postings corresponding with sent data.
     * @param {string} dateFrom Format is yyyy-MM-dd (from and incl.).
     * @param {string} dateTo Format is yyyy-MM-dd (to and excl.).
     * @param {string} [openPostings] Deprecated
     * @param {number} [accountId] Element ID
     * @param {number} [supplierId] Element ID
     * @param {number} [customerId] Element ID
     * @param {number} [employeeId] Element ID
     * @param {number} [departmentId] Element ID
     * @param {number} [projectId] Element ID
     * @param {number} [productId] Element ID
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgerpostingApi
     */
    LedgerpostingApi.prototype.search = function (dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options) {
        return exports.LedgerpostingApiFp(this.configuration).search(dateFrom, dateTo, openPostings, accountId, supplierId, customerId, employeeId, departmentId, projectId, productId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return LedgerpostingApi;
}(BaseAPI));
exports.LedgerpostingApi = LedgerpostingApi;
/**
 * LedgervatTypeApi - fetch parameter creator
 * @export
 */
exports.LedgervatTypeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get vat type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/ledger/vatType/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find vat types corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, number, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/vatType";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LedgervatTypeApi - functional programming interface
 * @export
 */
exports.LedgervatTypeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get vat type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.LedgervatTypeApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find vat types corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, number, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.LedgervatTypeApiFetchParamCreator(configuration).search(id, number, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * LedgervatTypeApi - factory interface
 * @export
 */
exports.LedgervatTypeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get vat type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.LedgervatTypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find vat types corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, number, from, count, sorting, fields, options) {
            return exports.LedgervatTypeApiFp(configuration).search(id, number, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * LedgervatTypeApi - object-oriented interface
 * @export
 * @class LedgervatTypeApi
 * @extends {BaseAPI}
 */
var LedgervatTypeApi = /** @class */ (function (_super) {
    __extends(LedgervatTypeApi, _super);
    function LedgervatTypeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get vat type by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervatTypeApi
     */
    LedgervatTypeApi.prototype.get = function (id, fields, options) {
        return exports.LedgervatTypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find vat types corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [number] List of IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervatTypeApi
     */
    LedgervatTypeApi.prototype.search = function (id, number, from, count, sorting, fields, options) {
        return exports.LedgervatTypeApiFp(this.configuration).search(id, number, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return LedgervatTypeApi;
}(BaseAPI));
exports.LedgervatTypeApi = LedgervatTypeApi;
/**
 * LedgervoucherApi - fetch parameter creator
 * @export
 */
exports.LedgervoucherApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get attachment by voucher ID.
         * @param {number} voucherId Voucher ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf: function (voucherId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'voucherId' is not null or undefined
            if (voucherId === null || voucherId === undefined) {
                throw new RequiredError('voucherId', 'Required parameter voucherId was null or undefined when calling downloadPdf.');
            }
            var localVarPath = "/ledger/voucher/{voucherId}/pdf"
                .replace("{" + "voucherId" + "}", encodeURIComponent(String(voucherId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get voucher by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/ledger/voucher/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Import GBAT10. Send as multipart form.
         * @param {boolean} generateVatPostings If the import should generate VAT postings
         * @param {any} file The file
         * @param {string} [encoding] The file encoding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGbat10: function (generateVatPostings, file, encoding, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'generateVatPostings' is not null or undefined
            if (generateVatPostings === null || generateVatPostings === undefined) {
                throw new RequiredError('generateVatPostings', 'Required parameter generateVatPostings was null or undefined when calling importGbat10.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling importGbat10.');
            }
            var localVarPath = "/ledger/voucher/importGbat10";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (generateVatPostings !== undefined) {
                localVarFormParams.set('generateVatPostings', generateVatPostings);
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            if (encoding !== undefined) {
                localVarFormParams.set('encoding', encoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find non-posted vouchers.
         * @param {boolean} includeNonApproved Include non-approved vouchers in the result.
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonPosted: function (includeNonApproved, dateFrom, dateTo, changedSince, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'includeNonApproved' is not null or undefined
            if (includeNonApproved === null || includeNonApproved === undefined) {
                throw new RequiredError('includeNonApproved', 'Required parameter includeNonApproved was null or undefined when calling nonPosted.');
            }
            var localVarPath = "/ledger/voucher/>nonPosted";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }
            if (includeNonApproved !== undefined) {
                localVarQueryParameter['includeNonApproved'] = includeNonApproved;
            }
            if (changedSince !== undefined) {
                localVarQueryParameter['changedSince'] = changedSince;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add new voucher. IMPORTANT: Also creates postings. Only the gross amounts will be used
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (sendToLedger, body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/voucher";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (sendToLedger !== undefined) {
                localVarQueryParameter['sendToLedger'] = sendToLedger;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Voucher" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update voucher. Postings with guiRow==0 will be deleted and regenerated.
         * @param {number} id Element ID
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, sendToLedger, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/ledger/voucher/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (sendToLedger !== undefined) {
                localVarQueryParameter['sendToLedger'] = sendToLedger;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Voucher" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find vouchers corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [typeId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, id, number, numberFrom, numberTo, typeId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom', 'Required parameter dateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'dateTo' is not null or undefined
            if (dateTo === null || dateTo === undefined) {
                throw new RequiredError('dateTo', 'Required parameter dateTo was null or undefined when calling search.');
            }
            var localVarPath = "/ledger/voucher";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }
            if (numberFrom !== undefined) {
                localVarQueryParameter['numberFrom'] = numberFrom;
            }
            if (numberTo !== undefined) {
                localVarQueryParameter['numberTo'] = numberTo;
            }
            if (typeId !== undefined) {
                localVarQueryParameter['typeId'] = typeId;
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Send voucher to inbox.
         * @param {number} id ID of voucher that should be sent to inbox.
         * @param {number} [version] Version of voucher that should be sent to inbox.
         * @param {string} [comment] Description of why the voucher was rejected. This parameter is only used if the approval feature is enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToInbox: function (id, version, comment, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sendToInbox.');
            }
            var localVarPath = "/ledger/voucher/{id}/:sendToInbox"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Send voucher to ledger.
         * @param {number} id ID of voucher that should be sent to ledger.
         * @param {number} [version] Version of voucher that should be sent to ledger.
         * @param {number} [number] Voucher number to use. If omitted or 0 the system will assign the number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToLedger: function (id, version, number, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sendToLedger.');
            }
            var localVarPath = "/ledger/voucher/{id}/:sendToLedger"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Upload attachment to voucher. Send as multipart form.
         * @param {number} voucherId Voucher ID to upload PDF to.
         * @param {string} fileName File name to store the pdf under. Will not be the same as the filename on the file returned.
         * @param {any} file The file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPdf: function (voucherId, fileName, file, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'voucherId' is not null or undefined
            if (voucherId === null || voucherId === undefined) {
                throw new RequiredError('voucherId', 'Required parameter voucherId was null or undefined when calling uploadPdf.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName', 'Required parameter fileName was null or undefined when calling uploadPdf.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling uploadPdf.');
            }
            var localVarPath = "/ledger/voucher/{voucherId}/pdf/{fileName}"
                .replace("{" + "voucherId" + "}", encodeURIComponent(String(voucherId)))
                .replace("{" + "fileName" + "}", encodeURIComponent(String(fileName)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LedgervoucherApi - functional programming interface
 * @export
 */
exports.LedgervoucherApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get attachment by voucher ID.
         * @param {number} voucherId Voucher ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf: function (voucherId, options) {
            var localVarFetchArgs = exports.LedgervoucherApiFetchParamCreator(configuration).downloadPdf(voucherId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get voucher by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.LedgervoucherApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Import GBAT10. Send as multipart form.
         * @param {boolean} generateVatPostings If the import should generate VAT postings
         * @param {any} file The file
         * @param {string} [encoding] The file encoding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGbat10: function (generateVatPostings, file, encoding, options) {
            var localVarFetchArgs = exports.LedgervoucherApiFetchParamCreator(configuration).importGbat10(generateVatPostings, file, encoding, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find non-posted vouchers.
         * @param {boolean} includeNonApproved Include non-approved vouchers in the result.
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonPosted: function (includeNonApproved, dateFrom, dateTo, changedSince, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.LedgervoucherApiFetchParamCreator(configuration).nonPosted(includeNonApproved, dateFrom, dateTo, changedSince, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Add new voucher. IMPORTANT: Also creates postings. Only the gross amounts will be used
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (sendToLedger, body, options) {
            var localVarFetchArgs = exports.LedgervoucherApiFetchParamCreator(configuration).post(sendToLedger, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update voucher. Postings with guiRow==0 will be deleted and regenerated.
         * @param {number} id Element ID
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, sendToLedger, body, options) {
            var localVarFetchArgs = exports.LedgervoucherApiFetchParamCreator(configuration).put(id, sendToLedger, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find vouchers corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [typeId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, id, number, numberFrom, numberTo, typeId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.LedgervoucherApiFetchParamCreator(configuration).search(dateFrom, dateTo, id, number, numberFrom, numberTo, typeId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Send voucher to inbox.
         * @param {number} id ID of voucher that should be sent to inbox.
         * @param {number} [version] Version of voucher that should be sent to inbox.
         * @param {string} [comment] Description of why the voucher was rejected. This parameter is only used if the approval feature is enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToInbox: function (id, version, comment, options) {
            var localVarFetchArgs = exports.LedgervoucherApiFetchParamCreator(configuration).sendToInbox(id, version, comment, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Send voucher to ledger.
         * @param {number} id ID of voucher that should be sent to ledger.
         * @param {number} [version] Version of voucher that should be sent to ledger.
         * @param {number} [number] Voucher number to use. If omitted or 0 the system will assign the number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToLedger: function (id, version, number, options) {
            var localVarFetchArgs = exports.LedgervoucherApiFetchParamCreator(configuration).sendToLedger(id, version, number, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Upload attachment to voucher. Send as multipart form.
         * @param {number} voucherId Voucher ID to upload PDF to.
         * @param {string} fileName File name to store the pdf under. Will not be the same as the filename on the file returned.
         * @param {any} file The file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPdf: function (voucherId, fileName, file, options) {
            var localVarFetchArgs = exports.LedgervoucherApiFetchParamCreator(configuration).uploadPdf(voucherId, fileName, file, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * LedgervoucherApi - factory interface
 * @export
 */
exports.LedgervoucherApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get attachment by voucher ID.
         * @param {number} voucherId Voucher ID from which PDF is downloaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf: function (voucherId, options) {
            return exports.LedgervoucherApiFp(configuration).downloadPdf(voucherId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get voucher by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.LedgervoucherApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Import GBAT10. Send as multipart form.
         * @param {boolean} generateVatPostings If the import should generate VAT postings
         * @param {any} file The file
         * @param {string} [encoding] The file encoding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGbat10: function (generateVatPostings, file, encoding, options) {
            return exports.LedgervoucherApiFp(configuration).importGbat10(generateVatPostings, file, encoding, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find non-posted vouchers.
         * @param {boolean} includeNonApproved Include non-approved vouchers in the result.
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonPosted: function (includeNonApproved, dateFrom, dateTo, changedSince, from, count, sorting, fields, options) {
            return exports.LedgervoucherApiFp(configuration).nonPosted(includeNonApproved, dateFrom, dateTo, changedSince, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add new voucher. IMPORTANT: Also creates postings. Only the gross amounts will be used
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (sendToLedger, body, options) {
            return exports.LedgervoucherApiFp(configuration).post(sendToLedger, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update voucher. Postings with guiRow==0 will be deleted and regenerated.
         * @param {number} id Element ID
         * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
         * @param {Voucher} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, sendToLedger, body, options) {
            return exports.LedgervoucherApiFp(configuration).put(id, sendToLedger, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find vouchers corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] List of IDs
         * @param {number} [numberFrom] From and including
         * @param {number} [numberTo] To and excluding
         * @param {string} [typeId] List of IDs
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, id, number, numberFrom, numberTo, typeId, from, count, sorting, fields, options) {
            return exports.LedgervoucherApiFp(configuration).search(dateFrom, dateTo, id, number, numberFrom, numberTo, typeId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Send voucher to inbox.
         * @param {number} id ID of voucher that should be sent to inbox.
         * @param {number} [version] Version of voucher that should be sent to inbox.
         * @param {string} [comment] Description of why the voucher was rejected. This parameter is only used if the approval feature is enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToInbox: function (id, version, comment, options) {
            return exports.LedgervoucherApiFp(configuration).sendToInbox(id, version, comment, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Send voucher to ledger.
         * @param {number} id ID of voucher that should be sent to ledger.
         * @param {number} [version] Version of voucher that should be sent to ledger.
         * @param {number} [number] Voucher number to use. If omitted or 0 the system will assign the number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToLedger: function (id, version, number, options) {
            return exports.LedgervoucherApiFp(configuration).sendToLedger(id, version, number, options)(fetch, basePath);
        },
        /**
         *
         * @summary Upload attachment to voucher. Send as multipart form.
         * @param {number} voucherId Voucher ID to upload PDF to.
         * @param {string} fileName File name to store the pdf under. Will not be the same as the filename on the file returned.
         * @param {any} file The file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPdf: function (voucherId, fileName, file, options) {
            return exports.LedgervoucherApiFp(configuration).uploadPdf(voucherId, fileName, file, options)(fetch, basePath);
        },
    };
};
/**
 * LedgervoucherApi - object-oriented interface
 * @export
 * @class LedgervoucherApi
 * @extends {BaseAPI}
 */
var LedgervoucherApi = /** @class */ (function (_super) {
    __extends(LedgervoucherApi, _super);
    function LedgervoucherApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get attachment by voucher ID.
     * @param {number} voucherId Voucher ID from which PDF is downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    LedgervoucherApi.prototype.downloadPdf = function (voucherId, options) {
        return exports.LedgervoucherApiFp(this.configuration).downloadPdf(voucherId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get voucher by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    LedgervoucherApi.prototype.get = function (id, fields, options) {
        return exports.LedgervoucherApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Import GBAT10. Send as multipart form.
     * @param {boolean} generateVatPostings If the import should generate VAT postings
     * @param {any} file The file
     * @param {string} [encoding] The file encoding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    LedgervoucherApi.prototype.importGbat10 = function (generateVatPostings, file, encoding, options) {
        return exports.LedgervoucherApiFp(this.configuration).importGbat10(generateVatPostings, file, encoding, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find non-posted vouchers.
     * @param {boolean} includeNonApproved Include non-approved vouchers in the result.
     * @param {string} [dateFrom] From and including
     * @param {string} [dateTo] To and excluding
     * @param {string} [changedSince] Only return elements that have changed since this date and time
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    LedgervoucherApi.prototype.nonPosted = function (includeNonApproved, dateFrom, dateTo, changedSince, from, count, sorting, fields, options) {
        return exports.LedgervoucherApiFp(this.configuration).nonPosted(includeNonApproved, dateFrom, dateTo, changedSince, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Add new voucher. IMPORTANT: Also creates postings. Only the gross amounts will be used
     * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
     * @param {Voucher} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    LedgervoucherApi.prototype.post = function (sendToLedger, body, options) {
        return exports.LedgervoucherApiFp(this.configuration).post(sendToLedger, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update voucher. Postings with guiRow==0 will be deleted and regenerated.
     * @param {number} id Element ID
     * @param {boolean} [sendToLedger] Should the voucher be sent to ledger? Requires the \&quot;Advanced Voucher\&quot; permission.
     * @param {Voucher} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    LedgervoucherApi.prototype.put = function (id, sendToLedger, body, options) {
        return exports.LedgervoucherApiFp(this.configuration).put(id, sendToLedger, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find vouchers corresponding with sent data.
     * @param {string} dateFrom From and including
     * @param {string} dateTo To and excluding
     * @param {string} [id] List of IDs
     * @param {string} [number] List of IDs
     * @param {number} [numberFrom] From and including
     * @param {number} [numberTo] To and excluding
     * @param {string} [typeId] List of IDs
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    LedgervoucherApi.prototype.search = function (dateFrom, dateTo, id, number, numberFrom, numberTo, typeId, from, count, sorting, fields, options) {
        return exports.LedgervoucherApiFp(this.configuration).search(dateFrom, dateTo, id, number, numberFrom, numberTo, typeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Send voucher to inbox.
     * @param {number} id ID of voucher that should be sent to inbox.
     * @param {number} [version] Version of voucher that should be sent to inbox.
     * @param {string} [comment] Description of why the voucher was rejected. This parameter is only used if the approval feature is enabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    LedgervoucherApi.prototype.sendToInbox = function (id, version, comment, options) {
        return exports.LedgervoucherApiFp(this.configuration).sendToInbox(id, version, comment, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Send voucher to ledger.
     * @param {number} id ID of voucher that should be sent to ledger.
     * @param {number} [version] Version of voucher that should be sent to ledger.
     * @param {number} [number] Voucher number to use. If omitted or 0 the system will assign the number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    LedgervoucherApi.prototype.sendToLedger = function (id, version, number, options) {
        return exports.LedgervoucherApiFp(this.configuration).sendToLedger(id, version, number, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Upload attachment to voucher. Send as multipart form.
     * @param {number} voucherId Voucher ID to upload PDF to.
     * @param {string} fileName File name to store the pdf under. Will not be the same as the filename on the file returned.
     * @param {any} file The file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherApi
     */
    LedgervoucherApi.prototype.uploadPdf = function (voucherId, fileName, file, options) {
        return exports.LedgervoucherApiFp(this.configuration).uploadPdf(voucherId, fileName, file, options)(this.fetch, this.basePath);
    };
    return LedgervoucherApi;
}(BaseAPI));
exports.LedgervoucherApi = LedgervoucherApi;
/**
 * LedgervoucherTypeApi - fetch parameter creator
 * @export
 */
exports.LedgervoucherTypeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get voucher type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/ledger/voucherType/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find voucher types corresponding with sent data.
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (name, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/ledger/voucherType";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LedgervoucherTypeApi - functional programming interface
 * @export
 */
exports.LedgervoucherTypeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get voucher type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.LedgervoucherTypeApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find voucher types corresponding with sent data.
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (name, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.LedgervoucherTypeApiFetchParamCreator(configuration).search(name, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * LedgervoucherTypeApi - factory interface
 * @export
 */
exports.LedgervoucherTypeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get voucher type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.LedgervoucherTypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find voucher types corresponding with sent data.
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (name, from, count, sorting, fields, options) {
            return exports.LedgervoucherTypeApiFp(configuration).search(name, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * LedgervoucherTypeApi - object-oriented interface
 * @export
 * @class LedgervoucherTypeApi
 * @extends {BaseAPI}
 */
var LedgervoucherTypeApi = /** @class */ (function (_super) {
    __extends(LedgervoucherTypeApi, _super);
    function LedgervoucherTypeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get voucher type by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherTypeApi
     */
    LedgervoucherTypeApi.prototype.get = function (id, fields, options) {
        return exports.LedgervoucherTypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find voucher types corresponding with sent data.
     * @param {string} [name] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LedgervoucherTypeApi
     */
    LedgervoucherTypeApi.prototype.search = function (name, from, count, sorting, fields, options) {
        return exports.LedgervoucherTypeApiFp(this.configuration).search(name, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return LedgervoucherTypeApi;
}(BaseAPI));
exports.LedgervoucherTypeApi = LedgervoucherTypeApi;
/**
 * OrderApi - fetch parameter creator
 * @export
 */
exports.OrderApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get order by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/order/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create new invoice from order.
         * @param {number} id ID of order to invoice.
         * @param {string} invoiceDate To and excluding
         * @param {boolean} [sendToCustomer] Send invoice to customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoice: function (id, invoiceDate, sendToCustomer, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling invoice.');
            }
            // verify required parameter 'invoiceDate' is not null or undefined
            if (invoiceDate === null || invoiceDate === undefined) {
                throw new RequiredError('invoiceDate', 'Required parameter invoiceDate was null or undefined when calling invoice.');
            }
            var localVarPath = "/order/{id}/:invoice"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (invoiceDate !== undefined) {
                localVarQueryParameter['invoiceDate'] = invoiceDate;
            }
            if (sendToCustomer !== undefined) {
                localVarQueryParameter['sendToCustomer'] = sendToCustomer;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create order.
         * @param {Order} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/order";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update order.
         * @param {number} id Element ID
         * @param {Order} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/order/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find orders corresponding with sent data.
         * @param {string} orderDateFrom From and including
         * @param {string} orderDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] Equals
         * @param {string} [customerId] List of IDs
         * @param {boolean} [isClosed] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (orderDateFrom, orderDateTo, id, number, customerId, isClosed, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'orderDateFrom' is not null or undefined
            if (orderDateFrom === null || orderDateFrom === undefined) {
                throw new RequiredError('orderDateFrom', 'Required parameter orderDateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'orderDateTo' is not null or undefined
            if (orderDateTo === null || orderDateTo === undefined) {
                throw new RequiredError('orderDateTo', 'Required parameter orderDateTo was null or undefined when calling search.');
            }
            var localVarPath = "/order";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }
            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }
            if (orderDateFrom !== undefined) {
                localVarQueryParameter['orderDateFrom'] = orderDateFrom;
            }
            if (orderDateTo !== undefined) {
                localVarQueryParameter['orderDateTo'] = orderDateTo;
            }
            if (isClosed !== undefined) {
                localVarQueryParameter['isClosed'] = isClosed;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrderApi - functional programming interface
 * @export
 */
exports.OrderApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get order by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.OrderApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create new invoice from order.
         * @param {number} id ID of order to invoice.
         * @param {string} invoiceDate To and excluding
         * @param {boolean} [sendToCustomer] Send invoice to customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoice: function (id, invoiceDate, sendToCustomer, options) {
            var localVarFetchArgs = exports.OrderApiFetchParamCreator(configuration).invoice(id, invoiceDate, sendToCustomer, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create order.
         * @param {Order} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.OrderApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update order.
         * @param {number} id Element ID
         * @param {Order} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.OrderApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find orders corresponding with sent data.
         * @param {string} orderDateFrom From and including
         * @param {string} orderDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] Equals
         * @param {string} [customerId] List of IDs
         * @param {boolean} [isClosed] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (orderDateFrom, orderDateTo, id, number, customerId, isClosed, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.OrderApiFetchParamCreator(configuration).search(orderDateFrom, orderDateTo, id, number, customerId, isClosed, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * OrderApi - factory interface
 * @export
 */
exports.OrderApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get order by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.OrderApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create new invoice from order.
         * @param {number} id ID of order to invoice.
         * @param {string} invoiceDate To and excluding
         * @param {boolean} [sendToCustomer] Send invoice to customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoice: function (id, invoiceDate, sendToCustomer, options) {
            return exports.OrderApiFp(configuration).invoice(id, invoiceDate, sendToCustomer, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create order.
         * @param {Order} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.OrderApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update order.
         * @param {number} id Element ID
         * @param {Order} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.OrderApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find orders corresponding with sent data.
         * @param {string} orderDateFrom From and including
         * @param {string} orderDateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [number] Equals
         * @param {string} [customerId] List of IDs
         * @param {boolean} [isClosed] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (orderDateFrom, orderDateTo, id, number, customerId, isClosed, from, count, sorting, fields, options) {
            return exports.OrderApiFp(configuration).search(orderDateFrom, orderDateTo, id, number, customerId, isClosed, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
var OrderApi = /** @class */ (function (_super) {
    __extends(OrderApi, _super);
    function OrderApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get order by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    OrderApi.prototype.get = function (id, fields, options) {
        return exports.OrderApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create new invoice from order.
     * @param {number} id ID of order to invoice.
     * @param {string} invoiceDate To and excluding
     * @param {boolean} [sendToCustomer] Send invoice to customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    OrderApi.prototype.invoice = function (id, invoiceDate, sendToCustomer, options) {
        return exports.OrderApiFp(this.configuration).invoice(id, invoiceDate, sendToCustomer, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create order.
     * @param {Order} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    OrderApi.prototype.post = function (body, options) {
        return exports.OrderApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update order.
     * @param {number} id Element ID
     * @param {Order} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    OrderApi.prototype.put = function (id, body, options) {
        return exports.OrderApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find orders corresponding with sent data.
     * @param {string} orderDateFrom From and including
     * @param {string} orderDateTo To and excluding
     * @param {string} [id] List of IDs
     * @param {string} [number] Equals
     * @param {string} [customerId] List of IDs
     * @param {boolean} [isClosed] Equals
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    OrderApi.prototype.search = function (orderDateFrom, orderDateTo, id, number, customerId, isClosed, from, count, sorting, fields, options) {
        return exports.OrderApiFp(this.configuration).search(orderDateFrom, orderDateTo, id, number, customerId, isClosed, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return OrderApi;
}(BaseAPI));
exports.OrderApi = OrderApi;
/**
 * OrderorderlineApi - fetch parameter creator
 * @export
 */
exports.OrderorderlineApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete order line by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/order/orderline/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get order line by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/order/orderline/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create order line. When creating several order lines, use /list for better performance.
         * @param {OrderLine} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/order/orderline";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("OrderLine" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create multiple order lines.
         * @param {Array<OrderLine>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/order/orderline/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;OrderLine&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrderorderlineApi - functional programming interface
 * @export
 */
exports.OrderorderlineApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete order line by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.OrderorderlineApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get order line by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.OrderorderlineApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create order line. When creating several order lines, use /list for better performance.
         * @param {OrderLine} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.OrderorderlineApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create multiple order lines.
         * @param {Array<OrderLine>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            var localVarFetchArgs = exports.OrderorderlineApiFetchParamCreator(configuration).postList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * OrderorderlineApi - factory interface
 * @export
 */
exports.OrderorderlineApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete order line by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.OrderorderlineApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get order line by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.OrderorderlineApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create order line. When creating several order lines, use /list for better performance.
         * @param {OrderLine} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.OrderorderlineApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create multiple order lines.
         * @param {Array<OrderLine>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            return exports.OrderorderlineApiFp(configuration).postList(body, options)(fetch, basePath);
        },
    };
};
/**
 * OrderorderlineApi - object-oriented interface
 * @export
 * @class OrderorderlineApi
 * @extends {BaseAPI}
 */
var OrderorderlineApi = /** @class */ (function (_super) {
    __extends(OrderorderlineApi, _super);
    function OrderorderlineApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete order line by ID.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderorderlineApi
     */
    OrderorderlineApi.prototype._delete = function (id, options) {
        return exports.OrderorderlineApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get order line by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderorderlineApi
     */
    OrderorderlineApi.prototype.get = function (id, fields, options) {
        return exports.OrderorderlineApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create order line. When creating several order lines, use /list for better performance.
     * @param {OrderLine} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderorderlineApi
     */
    OrderorderlineApi.prototype.post = function (body, options) {
        return exports.OrderorderlineApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create multiple order lines.
     * @param {Array<OrderLine>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderorderlineApi
     */
    OrderorderlineApi.prototype.postList = function (body, options) {
        return exports.OrderorderlineApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    };
    return OrderorderlineApi;
}(BaseAPI));
exports.OrderorderlineApi = OrderorderlineApi;
/**
 * ProductApi - fetch parameter creator
 * @export
 */
exports.ProductApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get product by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/product/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create new product.
         * @param {Product} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/product";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Product" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update product.
         * @param {number} id Element ID
         * @param {Product} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/product/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Product" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find products corresponding with sent data.
         * @param {string} [number] DEPRECATED. List of product numbers (Integer only)
         * @param {Array<string>} [productNumber] List of valid product numbers
         * @param {string} [name] Containing
         * @param {boolean} [isInactive] Equals
         * @param {boolean} [isStockItem] Equals
         * @param {string} [currencyId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [productUnitId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [accountId] Equals
         * @param {number} [costExcludingVatCurrencyFrom] From and including
         * @param {number} [costExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceExcludingVatCurrencyFrom] From and including
         * @param {number} [priceExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceIncludingVatCurrencyFrom] From and including
         * @param {number} [priceIncludingVatCurrencyTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (number, productNumber, name, isInactive, isStockItem, currencyId, vatTypeId, productUnitId, departmentId, accountId, costExcludingVatCurrencyFrom, costExcludingVatCurrencyTo, priceExcludingVatCurrencyFrom, priceExcludingVatCurrencyTo, priceIncludingVatCurrencyFrom, priceIncludingVatCurrencyTo, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/product";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }
            if (productNumber) {
                localVarQueryParameter['productNumber'] = productNumber;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (isInactive !== undefined) {
                localVarQueryParameter['isInactive'] = isInactive;
            }
            if (isStockItem !== undefined) {
                localVarQueryParameter['isStockItem'] = isStockItem;
            }
            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }
            if (vatTypeId !== undefined) {
                localVarQueryParameter['vatTypeId'] = vatTypeId;
            }
            if (productUnitId !== undefined) {
                localVarQueryParameter['productUnitId'] = productUnitId;
            }
            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (costExcludingVatCurrencyFrom !== undefined) {
                localVarQueryParameter['costExcludingVatCurrencyFrom'] = costExcludingVatCurrencyFrom;
            }
            if (costExcludingVatCurrencyTo !== undefined) {
                localVarQueryParameter['costExcludingVatCurrencyTo'] = costExcludingVatCurrencyTo;
            }
            if (priceExcludingVatCurrencyFrom !== undefined) {
                localVarQueryParameter['priceExcludingVatCurrencyFrom'] = priceExcludingVatCurrencyFrom;
            }
            if (priceExcludingVatCurrencyTo !== undefined) {
                localVarQueryParameter['priceExcludingVatCurrencyTo'] = priceExcludingVatCurrencyTo;
            }
            if (priceIncludingVatCurrencyFrom !== undefined) {
                localVarQueryParameter['priceIncludingVatCurrencyFrom'] = priceIncludingVatCurrencyFrom;
            }
            if (priceIncludingVatCurrencyTo !== undefined) {
                localVarQueryParameter['priceIncludingVatCurrencyTo'] = priceIncludingVatCurrencyTo;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ProductApi - functional programming interface
 * @export
 */
exports.ProductApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get product by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.ProductApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create new product.
         * @param {Product} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.ProductApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update product.
         * @param {number} id Element ID
         * @param {Product} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.ProductApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find products corresponding with sent data.
         * @param {string} [number] DEPRECATED. List of product numbers (Integer only)
         * @param {Array<string>} [productNumber] List of valid product numbers
         * @param {string} [name] Containing
         * @param {boolean} [isInactive] Equals
         * @param {boolean} [isStockItem] Equals
         * @param {string} [currencyId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [productUnitId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [accountId] Equals
         * @param {number} [costExcludingVatCurrencyFrom] From and including
         * @param {number} [costExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceExcludingVatCurrencyFrom] From and including
         * @param {number} [priceExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceIncludingVatCurrencyFrom] From and including
         * @param {number} [priceIncludingVatCurrencyTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (number, productNumber, name, isInactive, isStockItem, currencyId, vatTypeId, productUnitId, departmentId, accountId, costExcludingVatCurrencyFrom, costExcludingVatCurrencyTo, priceExcludingVatCurrencyFrom, priceExcludingVatCurrencyTo, priceIncludingVatCurrencyFrom, priceIncludingVatCurrencyTo, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.ProductApiFetchParamCreator(configuration).search(number, productNumber, name, isInactive, isStockItem, currencyId, vatTypeId, productUnitId, departmentId, accountId, costExcludingVatCurrencyFrom, costExcludingVatCurrencyTo, priceExcludingVatCurrencyFrom, priceExcludingVatCurrencyTo, priceIncludingVatCurrencyFrom, priceIncludingVatCurrencyTo, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ProductApi - factory interface
 * @export
 */
exports.ProductApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get product by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.ProductApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create new product.
         * @param {Product} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.ProductApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update product.
         * @param {number} id Element ID
         * @param {Product} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.ProductApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find products corresponding with sent data.
         * @param {string} [number] DEPRECATED. List of product numbers (Integer only)
         * @param {Array<string>} [productNumber] List of valid product numbers
         * @param {string} [name] Containing
         * @param {boolean} [isInactive] Equals
         * @param {boolean} [isStockItem] Equals
         * @param {string} [currencyId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [productUnitId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [accountId] Equals
         * @param {number} [costExcludingVatCurrencyFrom] From and including
         * @param {number} [costExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceExcludingVatCurrencyFrom] From and including
         * @param {number} [priceExcludingVatCurrencyTo] To and excluding
         * @param {number} [priceIncludingVatCurrencyFrom] From and including
         * @param {number} [priceIncludingVatCurrencyTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (number, productNumber, name, isInactive, isStockItem, currencyId, vatTypeId, productUnitId, departmentId, accountId, costExcludingVatCurrencyFrom, costExcludingVatCurrencyTo, priceExcludingVatCurrencyFrom, priceExcludingVatCurrencyTo, priceIncludingVatCurrencyFrom, priceIncludingVatCurrencyTo, from, count, sorting, fields, options) {
            return exports.ProductApiFp(configuration).search(number, productNumber, name, isInactive, isStockItem, currencyId, vatTypeId, productUnitId, departmentId, accountId, costExcludingVatCurrencyFrom, costExcludingVatCurrencyTo, priceExcludingVatCurrencyFrom, priceExcludingVatCurrencyTo, priceIncludingVatCurrencyFrom, priceIncludingVatCurrencyTo, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
var ProductApi = /** @class */ (function (_super) {
    __extends(ProductApi, _super);
    function ProductApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get product by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    ProductApi.prototype.get = function (id, fields, options) {
        return exports.ProductApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create new product.
     * @param {Product} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    ProductApi.prototype.post = function (body, options) {
        return exports.ProductApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update product.
     * @param {number} id Element ID
     * @param {Product} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    ProductApi.prototype.put = function (id, body, options) {
        return exports.ProductApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find products corresponding with sent data.
     * @param {string} [number] DEPRECATED. List of product numbers (Integer only)
     * @param {Array<string>} [productNumber] List of valid product numbers
     * @param {string} [name] Containing
     * @param {boolean} [isInactive] Equals
     * @param {boolean} [isStockItem] Equals
     * @param {string} [currencyId] Equals
     * @param {string} [vatTypeId] Equals
     * @param {string} [productUnitId] Equals
     * @param {string} [departmentId] Equals
     * @param {string} [accountId] Equals
     * @param {number} [costExcludingVatCurrencyFrom] From and including
     * @param {number} [costExcludingVatCurrencyTo] To and excluding
     * @param {number} [priceExcludingVatCurrencyFrom] From and including
     * @param {number} [priceExcludingVatCurrencyTo] To and excluding
     * @param {number} [priceIncludingVatCurrencyFrom] From and including
     * @param {number} [priceIncludingVatCurrencyTo] To and excluding
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    ProductApi.prototype.search = function (number, productNumber, name, isInactive, isStockItem, currencyId, vatTypeId, productUnitId, departmentId, accountId, costExcludingVatCurrencyFrom, costExcludingVatCurrencyTo, priceExcludingVatCurrencyFrom, priceExcludingVatCurrencyTo, priceIncludingVatCurrencyFrom, priceIncludingVatCurrencyTo, from, count, sorting, fields, options) {
        return exports.ProductApiFp(this.configuration).search(number, productNumber, name, isInactive, isStockItem, currencyId, vatTypeId, productUnitId, departmentId, accountId, costExcludingVatCurrencyFrom, costExcludingVatCurrencyTo, priceExcludingVatCurrencyFrom, priceExcludingVatCurrencyTo, priceIncludingVatCurrencyFrom, priceIncludingVatCurrencyTo, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return ProductApi;
}(BaseAPI));
exports.ProductApi = ProductApi;
/**
 * ProductunitApi - fetch parameter creator
 * @export
 */
exports.ProductunitApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get product unit by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/product/unit/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find product units corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Names
         * @param {string} [nameShort] Short names
         * @param {string} [commonCode] Common codes
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, nameShort, commonCode, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/product/unit";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (nameShort !== undefined) {
                localVarQueryParameter['nameShort'] = nameShort;
            }
            if (commonCode !== undefined) {
                localVarQueryParameter['commonCode'] = commonCode;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ProductunitApi - functional programming interface
 * @export
 */
exports.ProductunitApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get product unit by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.ProductunitApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find product units corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Names
         * @param {string} [nameShort] Short names
         * @param {string} [commonCode] Common codes
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, nameShort, commonCode, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.ProductunitApiFetchParamCreator(configuration).search(id, name, nameShort, commonCode, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ProductunitApi - factory interface
 * @export
 */
exports.ProductunitApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get product unit by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.ProductunitApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find product units corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Names
         * @param {string} [nameShort] Short names
         * @param {string} [commonCode] Common codes
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, nameShort, commonCode, from, count, sorting, fields, options) {
            return exports.ProductunitApiFp(configuration).search(id, name, nameShort, commonCode, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * ProductunitApi - object-oriented interface
 * @export
 * @class ProductunitApi
 * @extends {BaseAPI}
 */
var ProductunitApi = /** @class */ (function (_super) {
    __extends(ProductunitApi, _super);
    function ProductunitApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get product unit by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductunitApi
     */
    ProductunitApi.prototype.get = function (id, fields, options) {
        return exports.ProductunitApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find product units corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [name] Names
     * @param {string} [nameShort] Short names
     * @param {string} [commonCode] Common codes
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductunitApi
     */
    ProductunitApi.prototype.search = function (id, name, nameShort, commonCode, from, count, sorting, fields, options) {
        return exports.ProductunitApiFp(this.configuration).search(id, name, nameShort, commonCode, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return ProductunitApi;
}(BaseAPI));
exports.ProductunitApi = ProductunitApi;
/**
 * ProjectApi - fetch parameter creator
 * @export
 */
exports.ProjectApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete projects.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds: function (ids, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids', 'Required parameter ids was null or undefined when calling deleteByIds.');
            }
            var localVarPath = "/project/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find project by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/project/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find projects applicable for time sheet registration on a specific day.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet: function (employeeId, date, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/project/>forTimeSheet";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Add new project.
         * @param {Project} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/project";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Register new projects. Multiple projects for different users can be sent in the same request.
         * @param {Array<Project>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/project/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;Project&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update project.
         * @param {number} id Element ID
         * @param {Project} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/project/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find projects corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {boolean} [isOffer] Equals
         * @param {string} [projectManagerId] List of IDs
         * @param {string} [employeeInProjectId] List of IDs
         * @param {string} [departmentId] List of IDs
         * @param {string} [startDateFrom] From and including
         * @param {string} [startDateTo] To and excluding
         * @param {string} [endDateFrom] From and including
         * @param {string} [endDateTo] To and excluding
         * @param {boolean} [isClosed] Equals
         * @param {string} [customerId] Equals
         * @param {string} [externalAccountsNumber] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, isOffer, projectManagerId, employeeInProjectId, departmentId, startDateFrom, startDateTo, endDateFrom, endDateTo, isClosed, customerId, externalAccountsNumber, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/project";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }
            if (isOffer !== undefined) {
                localVarQueryParameter['isOffer'] = isOffer;
            }
            if (projectManagerId !== undefined) {
                localVarQueryParameter['projectManagerId'] = projectManagerId;
            }
            if (employeeInProjectId !== undefined) {
                localVarQueryParameter['employeeInProjectId'] = employeeInProjectId;
            }
            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }
            if (startDateFrom !== undefined) {
                localVarQueryParameter['startDateFrom'] = startDateFrom;
            }
            if (startDateTo !== undefined) {
                localVarQueryParameter['startDateTo'] = startDateTo;
            }
            if (endDateFrom !== undefined) {
                localVarQueryParameter['endDateFrom'] = endDateFrom;
            }
            if (endDateTo !== undefined) {
                localVarQueryParameter['endDateTo'] = endDateTo;
            }
            if (isClosed !== undefined) {
                localVarQueryParameter['isClosed'] = isClosed;
            }
            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }
            if (externalAccountsNumber !== undefined) {
                localVarQueryParameter['externalAccountsNumber'] = externalAccountsNumber;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ProjectApi - functional programming interface
 * @export
 */
exports.ProjectApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete projects.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds: function (ids, options) {
            var localVarFetchArgs = exports.ProjectApiFetchParamCreator(configuration).deleteByIds(ids, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find project by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.ProjectApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find projects applicable for time sheet registration on a specific day.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet: function (employeeId, date, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.ProjectApiFetchParamCreator(configuration).getForTimeSheet(employeeId, date, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Add new project.
         * @param {Project} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.ProjectApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Register new projects. Multiple projects for different users can be sent in the same request.
         * @param {Array<Project>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            var localVarFetchArgs = exports.ProjectApiFetchParamCreator(configuration).postList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update project.
         * @param {number} id Element ID
         * @param {Project} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.ProjectApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find projects corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {boolean} [isOffer] Equals
         * @param {string} [projectManagerId] List of IDs
         * @param {string} [employeeInProjectId] List of IDs
         * @param {string} [departmentId] List of IDs
         * @param {string} [startDateFrom] From and including
         * @param {string} [startDateTo] To and excluding
         * @param {string} [endDateFrom] From and including
         * @param {string} [endDateTo] To and excluding
         * @param {boolean} [isClosed] Equals
         * @param {string} [customerId] Equals
         * @param {string} [externalAccountsNumber] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, isOffer, projectManagerId, employeeInProjectId, departmentId, startDateFrom, startDateTo, endDateFrom, endDateTo, isClosed, customerId, externalAccountsNumber, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.ProjectApiFetchParamCreator(configuration).search(id, name, number, isOffer, projectManagerId, employeeInProjectId, departmentId, startDateFrom, startDateTo, endDateFrom, endDateTo, isClosed, customerId, externalAccountsNumber, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ProjectApi - factory interface
 * @export
 */
exports.ProjectApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete projects.
         * @param {string} ids ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByIds: function (ids, options) {
            return exports.ProjectApiFp(configuration).deleteByIds(ids, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find project by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.ProjectApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find projects applicable for time sheet registration on a specific day.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [date] yyyy-MM-dd. Defaults to today.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForTimeSheet: function (employeeId, date, from, count, sorting, fields, options) {
            return exports.ProjectApiFp(configuration).getForTimeSheet(employeeId, date, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Add new project.
         * @param {Project} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.ProjectApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Register new projects. Multiple projects for different users can be sent in the same request.
         * @param {Array<Project>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            return exports.ProjectApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update project.
         * @param {number} id Element ID
         * @param {Project} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.ProjectApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find projects corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {boolean} [isOffer] Equals
         * @param {string} [projectManagerId] List of IDs
         * @param {string} [employeeInProjectId] List of IDs
         * @param {string} [departmentId] List of IDs
         * @param {string} [startDateFrom] From and including
         * @param {string} [startDateTo] To and excluding
         * @param {string} [endDateFrom] From and including
         * @param {string} [endDateTo] To and excluding
         * @param {boolean} [isClosed] Equals
         * @param {string} [customerId] Equals
         * @param {string} [externalAccountsNumber] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, isOffer, projectManagerId, employeeInProjectId, departmentId, startDateFrom, startDateTo, endDateFrom, endDateTo, isClosed, customerId, externalAccountsNumber, from, count, sorting, fields, options) {
            return exports.ProjectApiFp(configuration).search(id, name, number, isOffer, projectManagerId, employeeInProjectId, departmentId, startDateFrom, startDateTo, endDateFrom, endDateTo, isClosed, customerId, externalAccountsNumber, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
var ProjectApi = /** @class */ (function (_super) {
    __extends(ProjectApi, _super);
    function ProjectApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete projects.
     * @param {string} ids ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.deleteByIds = function (ids, options) {
        return exports.ProjectApiFp(this.configuration).deleteByIds(ids, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find project by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.get = function (id, fields, options) {
        return exports.ProjectApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find projects applicable for time sheet registration on a specific day.
     * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {string} [date] yyyy-MM-dd. Defaults to today.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.getForTimeSheet = function (employeeId, date, from, count, sorting, fields, options) {
        return exports.ProjectApiFp(this.configuration).getForTimeSheet(employeeId, date, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Add new project.
     * @param {Project} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.post = function (body, options) {
        return exports.ProjectApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Register new projects. Multiple projects for different users can be sent in the same request.
     * @param {Array<Project>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.postList = function (body, options) {
        return exports.ProjectApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update project.
     * @param {number} id Element ID
     * @param {Project} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.put = function (id, body, options) {
        return exports.ProjectApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find projects corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [name] Containing
     * @param {string} [number] Equals
     * @param {boolean} [isOffer] Equals
     * @param {string} [projectManagerId] List of IDs
     * @param {string} [employeeInProjectId] List of IDs
     * @param {string} [departmentId] List of IDs
     * @param {string} [startDateFrom] From and including
     * @param {string} [startDateTo] To and excluding
     * @param {string} [endDateFrom] From and including
     * @param {string} [endDateTo] To and excluding
     * @param {boolean} [isClosed] Equals
     * @param {string} [customerId] Equals
     * @param {string} [externalAccountsNumber] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.search = function (id, name, number, isOffer, projectManagerId, employeeInProjectId, departmentId, startDateFrom, startDateTo, endDateFrom, endDateTo, isClosed, customerId, externalAccountsNumber, from, count, sorting, fields, options) {
        return exports.ProjectApiFp(this.configuration).search(id, name, number, isOffer, projectManagerId, employeeInProjectId, departmentId, startDateFrom, startDateTo, endDateFrom, endDateTo, isClosed, customerId, externalAccountsNumber, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return ProjectApi;
}(BaseAPI));
exports.ProjectApi = ProjectApi;
/**
 * ProjectcategoryApi - fetch parameter creator
 * @export
 */
exports.ProjectcategoryApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Find project category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/project/category/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add new project category.
         * @param {ProjectCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/project/category";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("ProjectCategory" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update project category.
         * @param {number} id Element ID
         * @param {ProjectCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/project/category/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("ProjectCategory" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find project categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, description, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/project/category";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ProjectcategoryApi - functional programming interface
 * @export
 */
exports.ProjectcategoryApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Find project category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.ProjectcategoryApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Add new project category.
         * @param {ProjectCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.ProjectcategoryApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update project category.
         * @param {number} id Element ID
         * @param {ProjectCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.ProjectcategoryApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find project categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, description, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.ProjectcategoryApiFetchParamCreator(configuration).search(id, name, number, description, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ProjectcategoryApi - factory interface
 * @export
 */
exports.ProjectcategoryApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Find project category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.ProjectcategoryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add new project category.
         * @param {ProjectCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.ProjectcategoryApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update project category.
         * @param {number} id Element ID
         * @param {ProjectCategory} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.ProjectcategoryApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find project categories corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [name] Containing
         * @param {string} [number] Equals
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, name, number, description, from, count, sorting, fields, options) {
            return exports.ProjectcategoryApiFp(configuration).search(id, name, number, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * ProjectcategoryApi - object-oriented interface
 * @export
 * @class ProjectcategoryApi
 * @extends {BaseAPI}
 */
var ProjectcategoryApi = /** @class */ (function (_super) {
    __extends(ProjectcategoryApi, _super);
    function ProjectcategoryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Find project category by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectcategoryApi
     */
    ProjectcategoryApi.prototype.get = function (id, fields, options) {
        return exports.ProjectcategoryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Add new project category.
     * @param {ProjectCategory} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectcategoryApi
     */
    ProjectcategoryApi.prototype.post = function (body, options) {
        return exports.ProjectcategoryApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update project category.
     * @param {number} id Element ID
     * @param {ProjectCategory} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectcategoryApi
     */
    ProjectcategoryApi.prototype.put = function (id, body, options) {
        return exports.ProjectcategoryApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find project categories corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [name] Containing
     * @param {string} [number] Equals
     * @param {string} [description] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectcategoryApi
     */
    ProjectcategoryApi.prototype.search = function (id, name, number, description, from, count, sorting, fields, options) {
        return exports.ProjectcategoryApiFp(this.configuration).search(id, name, number, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return ProjectcategoryApi;
}(BaseAPI));
exports.ProjectcategoryApi = ProjectcategoryApi;
/**
 * SalarypayslipApi - fetch parameter creator
 * @export
 */
exports.SalarypayslipApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find payslip (PDF document) by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling downloadPdf.');
            }
            var localVarPath = "/salary/payslip/{id}/pdf"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find payslip by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/salary/payslip/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find payslips corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [wageTransactionId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [monthFrom] From and including
         * @param {number} [monthTo] To and excluding
         * @param {string} [voucherDateFrom] From and including
         * @param {string} [voucherDateTo] To and excluding
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, employeeId, wageTransactionId, activityId, yearFrom, yearTo, monthFrom, monthTo, voucherDateFrom, voucherDateTo, comment, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/salary/payslip";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (wageTransactionId !== undefined) {
                localVarQueryParameter['wageTransactionId'] = wageTransactionId;
            }
            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }
            if (yearFrom !== undefined) {
                localVarQueryParameter['yearFrom'] = yearFrom;
            }
            if (yearTo !== undefined) {
                localVarQueryParameter['yearTo'] = yearTo;
            }
            if (monthFrom !== undefined) {
                localVarQueryParameter['monthFrom'] = monthFrom;
            }
            if (monthTo !== undefined) {
                localVarQueryParameter['monthTo'] = monthTo;
            }
            if (voucherDateFrom !== undefined) {
                localVarQueryParameter['voucherDateFrom'] = voucherDateFrom;
            }
            if (voucherDateTo !== undefined) {
                localVarQueryParameter['voucherDateTo'] = voucherDateTo;
            }
            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SalarypayslipApi - functional programming interface
 * @export
 */
exports.SalarypayslipApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find payslip (PDF document) by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf: function (id, options) {
            var localVarFetchArgs = exports.SalarypayslipApiFetchParamCreator(configuration).downloadPdf(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find payslip by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.SalarypayslipApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find payslips corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [wageTransactionId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [monthFrom] From and including
         * @param {number} [monthTo] To and excluding
         * @param {string} [voucherDateFrom] From and including
         * @param {string} [voucherDateTo] To and excluding
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, employeeId, wageTransactionId, activityId, yearFrom, yearTo, monthFrom, monthTo, voucherDateFrom, voucherDateTo, comment, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.SalarypayslipApiFetchParamCreator(configuration).search(id, employeeId, wageTransactionId, activityId, yearFrom, yearTo, monthFrom, monthTo, voucherDateFrom, voucherDateTo, comment, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SalarypayslipApi - factory interface
 * @export
 */
exports.SalarypayslipApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find payslip (PDF document) by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPdf: function (id, options) {
            return exports.SalarypayslipApiFp(configuration).downloadPdf(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find payslip by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.SalarypayslipApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find payslips corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [wageTransactionId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {number} [yearFrom] From and including
         * @param {number} [yearTo] To and excluding
         * @param {number} [monthFrom] From and including
         * @param {number} [monthTo] To and excluding
         * @param {string} [voucherDateFrom] From and including
         * @param {string} [voucherDateTo] To and excluding
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, employeeId, wageTransactionId, activityId, yearFrom, yearTo, monthFrom, monthTo, voucherDateFrom, voucherDateTo, comment, from, count, sorting, fields, options) {
            return exports.SalarypayslipApiFp(configuration).search(id, employeeId, wageTransactionId, activityId, yearFrom, yearTo, monthFrom, monthTo, voucherDateFrom, voucherDateTo, comment, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * SalarypayslipApi - object-oriented interface
 * @export
 * @class SalarypayslipApi
 * @extends {BaseAPI}
 */
var SalarypayslipApi = /** @class */ (function (_super) {
    __extends(SalarypayslipApi, _super);
    function SalarypayslipApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find payslip (PDF document) by ID.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarypayslipApi
     */
    SalarypayslipApi.prototype.downloadPdf = function (id, options) {
        return exports.SalarypayslipApiFp(this.configuration).downloadPdf(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find payslip by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarypayslipApi
     */
    SalarypayslipApi.prototype.get = function (id, fields, options) {
        return exports.SalarypayslipApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find payslips corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [employeeId] List of IDs
     * @param {string} [wageTransactionId] List of IDs
     * @param {string} [activityId] List of IDs
     * @param {number} [yearFrom] From and including
     * @param {number} [yearTo] To and excluding
     * @param {number} [monthFrom] From and including
     * @param {number} [monthTo] To and excluding
     * @param {string} [voucherDateFrom] From and including
     * @param {string} [voucherDateTo] To and excluding
     * @param {string} [comment] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarypayslipApi
     */
    SalarypayslipApi.prototype.search = function (id, employeeId, wageTransactionId, activityId, yearFrom, yearTo, monthFrom, monthTo, voucherDateFrom, voucherDateTo, comment, from, count, sorting, fields, options) {
        return exports.SalarypayslipApiFp(this.configuration).search(id, employeeId, wageTransactionId, activityId, yearFrom, yearTo, monthFrom, monthTo, voucherDateFrom, voucherDateTo, comment, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return SalarypayslipApi;
}(BaseAPI));
exports.SalarypayslipApi = SalarypayslipApi;
/**
 * SalarytransactionApi - fetch parameter creator
 * @export
 */
exports.SalarytransactionApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete salary transaction by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/salary/transaction/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find salary transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/salary/transaction/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create a new salary transaction.
         * @param {SalaryTransaction} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/salary/transaction";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("SalaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SalarytransactionApi - functional programming interface
 * @export
 */
exports.SalarytransactionApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete salary transaction by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.SalarytransactionApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find salary transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.SalarytransactionApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create a new salary transaction.
         * @param {SalaryTransaction} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.SalarytransactionApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SalarytransactionApi - factory interface
 * @export
 */
exports.SalarytransactionApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete salary transaction by ID.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.SalarytransactionApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find salary transaction by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.SalarytransactionApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create a new salary transaction.
         * @param {SalaryTransaction} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.SalarytransactionApiFp(configuration).post(body, options)(fetch, basePath);
        },
    };
};
/**
 * SalarytransactionApi - object-oriented interface
 * @export
 * @class SalarytransactionApi
 * @extends {BaseAPI}
 */
var SalarytransactionApi = /** @class */ (function (_super) {
    __extends(SalarytransactionApi, _super);
    function SalarytransactionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete salary transaction by ID.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarytransactionApi
     */
    SalarytransactionApi.prototype._delete = function (id, options) {
        return exports.SalarytransactionApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find salary transaction by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarytransactionApi
     */
    SalarytransactionApi.prototype.get = function (id, fields, options) {
        return exports.SalarytransactionApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create a new salary transaction.
     * @param {SalaryTransaction} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarytransactionApi
     */
    SalarytransactionApi.prototype.post = function (body, options) {
        return exports.SalarytransactionApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    return SalarytransactionApi;
}(BaseAPI));
exports.SalarytransactionApi = SalarytransactionApi;
/**
 * SalarytypeApi - fetch parameter creator
 * @export
 */
exports.SalarytypeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find salary type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/salary/type/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find salary type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] Containing
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, number, name, description, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/salary/type";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SalarytypeApi - functional programming interface
 * @export
 */
exports.SalarytypeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Find salary type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.SalarytypeApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find salary type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] Containing
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, number, name, description, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.SalarytypeApiFetchParamCreator(configuration).search(id, number, name, description, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SalarytypeApi - factory interface
 * @export
 */
exports.SalarytypeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Find salary type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.SalarytypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find salary type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [number] Containing
         * @param {string} [name] Containing
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, number, name, description, from, count, sorting, fields, options) {
            return exports.SalarytypeApiFp(configuration).search(id, number, name, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * SalarytypeApi - object-oriented interface
 * @export
 * @class SalarytypeApi
 * @extends {BaseAPI}
 */
var SalarytypeApi = /** @class */ (function (_super) {
    __extends(SalarytypeApi, _super);
    function SalarytypeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Find salary type by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarytypeApi
     */
    SalarytypeApi.prototype.get = function (id, fields, options) {
        return exports.SalarytypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find salary type corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [number] Containing
     * @param {string} [name] Containing
     * @param {string} [description] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalarytypeApi
     */
    SalarytypeApi.prototype.search = function (id, number, name, description, from, count, sorting, fields, options) {
        return exports.SalarytypeApiFp(this.configuration).search(id, number, name, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return SalarytypeApi;
}(BaseAPI));
exports.SalarytypeApi = SalarytypeApi;
/**
 * SupplierApi - fetch parameter creator
 * @export
 */
exports.SupplierApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get supplier by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/supplier/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create supplier. Related supplier addresses may also be created.
         * @param {Supplier} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/supplier";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Supplier" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create multiple suppliers. Related supplier addresses may also be created.
         * @param {Array<Supplier>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/supplier/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;Supplier&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update supplier.
         * @param {number} id Element ID
         * @param {Supplier} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/supplier/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Supplier" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update multiple suppliers. Addresses can also be updated.
         * @param {Array<Supplier>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/supplier/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;Supplier&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find suppliers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [supplierNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, supplierNumber, email, invoiceEmail, isInactive, accountManagerId, changedSince, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/supplier";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (supplierNumber !== undefined) {
                localVarQueryParameter['supplierNumber'] = supplierNumber;
            }
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            if (invoiceEmail !== undefined) {
                localVarQueryParameter['invoiceEmail'] = invoiceEmail;
            }
            if (isInactive !== undefined) {
                localVarQueryParameter['isInactive'] = isInactive;
            }
            if (accountManagerId !== undefined) {
                localVarQueryParameter['accountManagerId'] = accountManagerId;
            }
            if (changedSince !== undefined) {
                localVarQueryParameter['changedSince'] = changedSince;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SupplierApi - functional programming interface
 * @export
 */
exports.SupplierApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get supplier by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.SupplierApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create supplier. Related supplier addresses may also be created.
         * @param {Supplier} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.SupplierApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create multiple suppliers. Related supplier addresses may also be created.
         * @param {Array<Supplier>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            var localVarFetchArgs = exports.SupplierApiFetchParamCreator(configuration).postList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update supplier.
         * @param {number} id Element ID
         * @param {Supplier} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.SupplierApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update multiple suppliers. Addresses can also be updated.
         * @param {Array<Supplier>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            var localVarFetchArgs = exports.SupplierApiFetchParamCreator(configuration).putList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find suppliers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [supplierNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, supplierNumber, email, invoiceEmail, isInactive, accountManagerId, changedSince, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.SupplierApiFetchParamCreator(configuration).search(id, supplierNumber, email, invoiceEmail, isInactive, accountManagerId, changedSince, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SupplierApi - factory interface
 * @export
 */
exports.SupplierApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get supplier by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.SupplierApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create supplier. Related supplier addresses may also be created.
         * @param {Supplier} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.SupplierApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create multiple suppliers. Related supplier addresses may also be created.
         * @param {Array<Supplier>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            return exports.SupplierApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update supplier.
         * @param {number} id Element ID
         * @param {Supplier} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.SupplierApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update multiple suppliers. Addresses can also be updated.
         * @param {Array<Supplier>} [body] JSON representing updates to object. Should have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            return exports.SupplierApiFp(configuration).putList(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find suppliers corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [supplierNumber] List of IDs
         * @param {string} [email] Equals
         * @param {string} [invoiceEmail] Equals
         * @param {boolean} [isInactive] Equals
         * @param {string} [accountManagerId] List of IDs
         * @param {string} [changedSince] Only return elements that have changed since this date and time
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, supplierNumber, email, invoiceEmail, isInactive, accountManagerId, changedSince, from, count, sorting, fields, options) {
            return exports.SupplierApiFp(configuration).search(id, supplierNumber, email, invoiceEmail, isInactive, accountManagerId, changedSince, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * SupplierApi - object-oriented interface
 * @export
 * @class SupplierApi
 * @extends {BaseAPI}
 */
var SupplierApi = /** @class */ (function (_super) {
    __extends(SupplierApi, _super);
    function SupplierApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get supplier by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    SupplierApi.prototype.get = function (id, fields, options) {
        return exports.SupplierApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create supplier. Related supplier addresses may also be created.
     * @param {Supplier} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    SupplierApi.prototype.post = function (body, options) {
        return exports.SupplierApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create multiple suppliers. Related supplier addresses may also be created.
     * @param {Array<Supplier>} [body] JSON representing a list of new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    SupplierApi.prototype.postList = function (body, options) {
        return exports.SupplierApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update supplier.
     * @param {number} id Element ID
     * @param {Supplier} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    SupplierApi.prototype.put = function (id, body, options) {
        return exports.SupplierApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update multiple suppliers. Addresses can also be updated.
     * @param {Array<Supplier>} [body] JSON representing updates to object. Should have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    SupplierApi.prototype.putList = function (body, options) {
        return exports.SupplierApiFp(this.configuration).putList(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find suppliers corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [supplierNumber] List of IDs
     * @param {string} [email] Equals
     * @param {string} [invoiceEmail] Equals
     * @param {boolean} [isInactive] Equals
     * @param {string} [accountManagerId] List of IDs
     * @param {string} [changedSince] Only return elements that have changed since this date and time
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierApi
     */
    SupplierApi.prototype.search = function (id, supplierNumber, email, invoiceEmail, isInactive, accountManagerId, changedSince, from, count, sorting, fields, options) {
        return exports.SupplierApiFp(this.configuration).search(id, supplierNumber, email, invoiceEmail, isInactive, accountManagerId, changedSince, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return SupplierApi;
}(BaseAPI));
exports.SupplierApi = SupplierApi;
/**
 * TimesheetentryApi - fetch parameter creator
 * @export
 */
exports.TimesheetentryApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Delete timesheet entry by ID.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, version, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/timesheet/entry/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find timesheet entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/timesheet/entry/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find recently used timesheet activities.
         * @param {number} projectId ID of project to find activities for
         * @param {number} [employeeId] ID of employee to find activities for. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivities: function (projectId, employeeId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getRecentActivities.');
            }
            var localVarPath = "/timesheet/entry/>recentActivities";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find projects with recent activities (timesheet entry registered).
         * @param {number} [employeeId] ID of employee with recent project hours Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProjects: function (employeeId, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/timesheet/entry/>recentProjects";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find total hours registered on an employee in a specific period.
         * @param {number} [employeeId] ID of employee to find hours for. Defaults to ID of token owner.
         * @param {string} [startDate] Format is yyyy-MM-dd (from and incl.). Defaults to today.
         * @param {string} [endDate] Format is yyyy-MM-dd (to and excl.). Defaults to tomorrow.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalHours: function (employeeId, startDate, endDate, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/timesheet/entry/>totalHours";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add new timesheet entry. Only one entry per employee/date/activity/project combination is supported.
         * @param {TimesheetEntry} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/timesheet/entry";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("TimesheetEntry" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add new timesheet entry. Multiple objects for several users can be sent in the same request.
         * @param {Array<TimesheetEntry>} [body] List of timesheet entry objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/timesheet/entry/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;TimesheetEntry&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update timesheet entry by ID. Note: Timesheet entry object fields which are present but not set, or set to 0, will be nulled.
         * @param {number} id Element ID
         * @param {TimesheetEntry} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/timesheet/entry/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("TimesheetEntry" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update timesheet entry. Multiple objects for different users can be sent in the same request.
         * @param {Array<TimesheetEntry>} [body] List of timesheet entry objects to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/timesheet/entry/list";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;TimesheetEntry&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find timesheet entry corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, id, employeeId, projectId, activityId, comment, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom', 'Required parameter dateFrom was null or undefined when calling search.');
            }
            // verify required parameter 'dateTo' is not null or undefined
            if (dateTo === null || dateTo === undefined) {
                throw new RequiredError('dateTo', 'Required parameter dateTo was null or undefined when calling search.');
            }
            var localVarPath = "/timesheet/entry";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }
            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TimesheetentryApi - functional programming interface
 * @export
 */
exports.TimesheetentryApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Delete timesheet entry by ID.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, version, options) {
            var localVarFetchArgs = exports.TimesheetentryApiFetchParamCreator(configuration)._delete(id, version, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find timesheet entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TimesheetentryApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find recently used timesheet activities.
         * @param {number} projectId ID of project to find activities for
         * @param {number} [employeeId] ID of employee to find activities for. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivities: function (projectId, employeeId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TimesheetentryApiFetchParamCreator(configuration).getRecentActivities(projectId, employeeId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find projects with recent activities (timesheet entry registered).
         * @param {number} [employeeId] ID of employee with recent project hours Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProjects: function (employeeId, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TimesheetentryApiFetchParamCreator(configuration).getRecentProjects(employeeId, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find total hours registered on an employee in a specific period.
         * @param {number} [employeeId] ID of employee to find hours for. Defaults to ID of token owner.
         * @param {string} [startDate] Format is yyyy-MM-dd (from and incl.). Defaults to today.
         * @param {string} [endDate] Format is yyyy-MM-dd (to and excl.). Defaults to tomorrow.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalHours: function (employeeId, startDate, endDate, fields, options) {
            var localVarFetchArgs = exports.TimesheetentryApiFetchParamCreator(configuration).getTotalHours(employeeId, startDate, endDate, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Add new timesheet entry. Only one entry per employee/date/activity/project combination is supported.
         * @param {TimesheetEntry} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.TimesheetentryApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Add new timesheet entry. Multiple objects for several users can be sent in the same request.
         * @param {Array<TimesheetEntry>} [body] List of timesheet entry objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            var localVarFetchArgs = exports.TimesheetentryApiFetchParamCreator(configuration).postList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update timesheet entry by ID. Note: Timesheet entry object fields which are present but not set, or set to 0, will be nulled.
         * @param {number} id Element ID
         * @param {TimesheetEntry} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.TimesheetentryApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update timesheet entry. Multiple objects for different users can be sent in the same request.
         * @param {Array<TimesheetEntry>} [body] List of timesheet entry objects to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            var localVarFetchArgs = exports.TimesheetentryApiFetchParamCreator(configuration).putList(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find timesheet entry corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, id, employeeId, projectId, activityId, comment, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TimesheetentryApiFetchParamCreator(configuration).search(dateFrom, dateTo, id, employeeId, projectId, activityId, comment, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TimesheetentryApi - factory interface
 * @export
 */
exports.TimesheetentryApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Delete timesheet entry by ID.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, version, options) {
            return exports.TimesheetentryApiFp(configuration)._delete(id, version, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find timesheet entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TimesheetentryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find recently used timesheet activities.
         * @param {number} projectId ID of project to find activities for
         * @param {number} [employeeId] ID of employee to find activities for. Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivities: function (projectId, employeeId, from, count, sorting, fields, options) {
            return exports.TimesheetentryApiFp(configuration).getRecentActivities(projectId, employeeId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find projects with recent activities (timesheet entry registered).
         * @param {number} [employeeId] ID of employee with recent project hours Defaults to ID of token owner.
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProjects: function (employeeId, from, count, sorting, fields, options) {
            return exports.TimesheetentryApiFp(configuration).getRecentProjects(employeeId, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find total hours registered on an employee in a specific period.
         * @param {number} [employeeId] ID of employee to find hours for. Defaults to ID of token owner.
         * @param {string} [startDate] Format is yyyy-MM-dd (from and incl.). Defaults to today.
         * @param {string} [endDate] Format is yyyy-MM-dd (to and excl.). Defaults to tomorrow.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalHours: function (employeeId, startDate, endDate, fields, options) {
            return exports.TimesheetentryApiFp(configuration).getTotalHours(employeeId, startDate, endDate, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add new timesheet entry. Only one entry per employee/date/activity/project combination is supported.
         * @param {TimesheetEntry} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.TimesheetentryApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add new timesheet entry. Multiple objects for several users can be sent in the same request.
         * @param {Array<TimesheetEntry>} [body] List of timesheet entry objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: function (body, options) {
            return exports.TimesheetentryApiFp(configuration).postList(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update timesheet entry by ID. Note: Timesheet entry object fields which are present but not set, or set to 0, will be nulled.
         * @param {number} id Element ID
         * @param {TimesheetEntry} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.TimesheetentryApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update timesheet entry. Multiple objects for different users can be sent in the same request.
         * @param {Array<TimesheetEntry>} [body] List of timesheet entry objects to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putList: function (body, options) {
            return exports.TimesheetentryApiFp(configuration).putList(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find timesheet entry corresponding with sent data.
         * @param {string} dateFrom From and including
         * @param {string} dateTo To and excluding
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [comment] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (dateFrom, dateTo, id, employeeId, projectId, activityId, comment, from, count, sorting, fields, options) {
            return exports.TimesheetentryApiFp(configuration).search(dateFrom, dateTo, id, employeeId, projectId, activityId, comment, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TimesheetentryApi - object-oriented interface
 * @export
 * @class TimesheetentryApi
 * @extends {BaseAPI}
 */
var TimesheetentryApi = /** @class */ (function (_super) {
    __extends(TimesheetentryApi, _super);
    function TimesheetentryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Delete timesheet entry by ID.
     * @param {number} id Element ID
     * @param {number} [version] Number of current version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    TimesheetentryApi.prototype._delete = function (id, version, options) {
        return exports.TimesheetentryApiFp(this.configuration)._delete(id, version, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find timesheet entry by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    TimesheetentryApi.prototype.get = function (id, fields, options) {
        return exports.TimesheetentryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find recently used timesheet activities.
     * @param {number} projectId ID of project to find activities for
     * @param {number} [employeeId] ID of employee to find activities for. Defaults to ID of token owner.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    TimesheetentryApi.prototype.getRecentActivities = function (projectId, employeeId, from, count, sorting, fields, options) {
        return exports.TimesheetentryApiFp(this.configuration).getRecentActivities(projectId, employeeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find projects with recent activities (timesheet entry registered).
     * @param {number} [employeeId] ID of employee with recent project hours Defaults to ID of token owner.
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    TimesheetentryApi.prototype.getRecentProjects = function (employeeId, from, count, sorting, fields, options) {
        return exports.TimesheetentryApiFp(this.configuration).getRecentProjects(employeeId, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find total hours registered on an employee in a specific period.
     * @param {number} [employeeId] ID of employee to find hours for. Defaults to ID of token owner.
     * @param {string} [startDate] Format is yyyy-MM-dd (from and incl.). Defaults to today.
     * @param {string} [endDate] Format is yyyy-MM-dd (to and excl.). Defaults to tomorrow.
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    TimesheetentryApi.prototype.getTotalHours = function (employeeId, startDate, endDate, fields, options) {
        return exports.TimesheetentryApiFp(this.configuration).getTotalHours(employeeId, startDate, endDate, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Add new timesheet entry. Only one entry per employee/date/activity/project combination is supported.
     * @param {TimesheetEntry} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    TimesheetentryApi.prototype.post = function (body, options) {
        return exports.TimesheetentryApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Add new timesheet entry. Multiple objects for several users can be sent in the same request.
     * @param {Array<TimesheetEntry>} [body] List of timesheet entry objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    TimesheetentryApi.prototype.postList = function (body, options) {
        return exports.TimesheetentryApiFp(this.configuration).postList(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update timesheet entry by ID. Note: Timesheet entry object fields which are present but not set, or set to 0, will be nulled.
     * @param {number} id Element ID
     * @param {TimesheetEntry} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    TimesheetentryApi.prototype.put = function (id, body, options) {
        return exports.TimesheetentryApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update timesheet entry. Multiple objects for different users can be sent in the same request.
     * @param {Array<TimesheetEntry>} [body] List of timesheet entry objects to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    TimesheetentryApi.prototype.putList = function (body, options) {
        return exports.TimesheetentryApiFp(this.configuration).putList(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find timesheet entry corresponding with sent data.
     * @param {string} dateFrom From and including
     * @param {string} dateTo To and excluding
     * @param {string} [id] List of IDs
     * @param {string} [employeeId] List of IDs
     * @param {string} [projectId] List of IDs
     * @param {string} [activityId] List of IDs
     * @param {string} [comment] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetentryApi
     */
    TimesheetentryApi.prototype.search = function (dateFrom, dateTo, id, employeeId, projectId, activityId, comment, from, count, sorting, fields, options) {
        return exports.TimesheetentryApiFp(this.configuration).search(dateFrom, dateTo, id, employeeId, projectId, activityId, comment, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return TimesheetentryApi;
}(BaseAPI));
exports.TimesheetentryApi = TimesheetentryApi;
/**
 * TimesheettimeClockApi - fetch parameter creator
 * @export
 */
exports.TimesheettimeClockApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Find time clock entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/timesheet/timeClock/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find a user’s present running time clock.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresent: function (employeeId, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/timesheet/timeClock/present";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update time clock by ID.
         * @param {number} id Element ID
         * @param {TimeClock} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/timesheet/timeClock/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("TimeClock" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find time clock entries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [hourId] List of IDs
         * @param {boolean} [isRunning] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, employeeId, projectId, activityId, dateFrom, dateTo, hourId, isRunning, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/timesheet/timeClock";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }
            if (hourId !== undefined) {
                localVarQueryParameter['hourId'] = hourId;
            }
            if (isRunning !== undefined) {
                localVarQueryParameter['isRunning'] = isRunning;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Start time clock.
         * @param {number} activityId Activity ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [projectId] Project ID
         * @param {string} [date] Optional. Default is today’s date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start: function (activityId, employeeId, projectId, date, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError('activityId', 'Required parameter activityId was null or undefined when calling start.');
            }
            var localVarPath = "/timesheet/timeClock/:start";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }
            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Stop time clock.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop: function (id, version, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling stop.');
            }
            var localVarPath = "/timesheet/timeClock/{id}/:stop"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TimesheettimeClockApi - functional programming interface
 * @export
 */
exports.TimesheettimeClockApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Find time clock entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TimesheettimeClockApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find a user’s present running time clock.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresent: function (employeeId, fields, options) {
            var localVarFetchArgs = exports.TimesheettimeClockApiFetchParamCreator(configuration).getPresent(employeeId, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update time clock by ID.
         * @param {number} id Element ID
         * @param {TimeClock} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.TimesheettimeClockApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find time clock entries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [hourId] List of IDs
         * @param {boolean} [isRunning] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, employeeId, projectId, activityId, dateFrom, dateTo, hourId, isRunning, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TimesheettimeClockApiFetchParamCreator(configuration).search(id, employeeId, projectId, activityId, dateFrom, dateTo, hourId, isRunning, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Start time clock.
         * @param {number} activityId Activity ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [projectId] Project ID
         * @param {string} [date] Optional. Default is today’s date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start: function (activityId, employeeId, projectId, date, options) {
            var localVarFetchArgs = exports.TimesheettimeClockApiFetchParamCreator(configuration).start(activityId, employeeId, projectId, date, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Stop time clock.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop: function (id, version, options) {
            var localVarFetchArgs = exports.TimesheettimeClockApiFetchParamCreator(configuration).stop(id, version, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TimesheettimeClockApi - factory interface
 * @export
 */
exports.TimesheettimeClockApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Find time clock entry by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TimesheettimeClockApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a user’s present running time clock.
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresent: function (employeeId, fields, options) {
            return exports.TimesheettimeClockApiFp(configuration).getPresent(employeeId, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update time clock by ID.
         * @param {number} id Element ID
         * @param {TimeClock} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.TimesheettimeClockApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find time clock entries corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [employeeId] List of IDs
         * @param {string} [projectId] List of IDs
         * @param {string} [activityId] List of IDs
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {string} [hourId] List of IDs
         * @param {boolean} [isRunning] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, employeeId, projectId, activityId, dateFrom, dateTo, hourId, isRunning, from, count, sorting, fields, options) {
            return exports.TimesheettimeClockApiFp(configuration).search(id, employeeId, projectId, activityId, dateFrom, dateTo, hourId, isRunning, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary Start time clock.
         * @param {number} activityId Activity ID
         * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
         * @param {number} [projectId] Project ID
         * @param {string} [date] Optional. Default is today’s date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start: function (activityId, employeeId, projectId, date, options) {
            return exports.TimesheettimeClockApiFp(configuration).start(activityId, employeeId, projectId, date, options)(fetch, basePath);
        },
        /**
         *
         * @summary Stop time clock.
         * @param {number} id Element ID
         * @param {number} [version] Number of current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop: function (id, version, options) {
            return exports.TimesheettimeClockApiFp(configuration).stop(id, version, options)(fetch, basePath);
        },
    };
};
/**
 * TimesheettimeClockApi - object-oriented interface
 * @export
 * @class TimesheettimeClockApi
 * @extends {BaseAPI}
 */
var TimesheettimeClockApi = /** @class */ (function (_super) {
    __extends(TimesheettimeClockApi, _super);
    function TimesheettimeClockApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Find time clock entry by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    TimesheettimeClockApi.prototype.get = function (id, fields, options) {
        return exports.TimesheettimeClockApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find a user’s present running time clock.
     * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    TimesheettimeClockApi.prototype.getPresent = function (employeeId, fields, options) {
        return exports.TimesheettimeClockApiFp(this.configuration).getPresent(employeeId, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update time clock by ID.
     * @param {number} id Element ID
     * @param {TimeClock} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    TimesheettimeClockApi.prototype.put = function (id, body, options) {
        return exports.TimesheettimeClockApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find time clock entries corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [employeeId] List of IDs
     * @param {string} [projectId] List of IDs
     * @param {string} [activityId] List of IDs
     * @param {string} [dateFrom] From and including
     * @param {string} [dateTo] To and excluding
     * @param {string} [hourId] List of IDs
     * @param {boolean} [isRunning] Equals
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    TimesheettimeClockApi.prototype.search = function (id, employeeId, projectId, activityId, dateFrom, dateTo, hourId, isRunning, from, count, sorting, fields, options) {
        return exports.TimesheettimeClockApiFp(this.configuration).search(id, employeeId, projectId, activityId, dateFrom, dateTo, hourId, isRunning, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Start time clock.
     * @param {number} activityId Activity ID
     * @param {number} [employeeId] Employee ID. Defaults to ID of token owner.
     * @param {number} [projectId] Project ID
     * @param {string} [date] Optional. Default is today’s date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    TimesheettimeClockApi.prototype.start = function (activityId, employeeId, projectId, date, options) {
        return exports.TimesheettimeClockApiFp(this.configuration).start(activityId, employeeId, projectId, date, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Stop time clock.
     * @param {number} id Element ID
     * @param {number} [version] Number of current version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheettimeClockApi
     */
    TimesheettimeClockApi.prototype.stop = function (id, version, options) {
        return exports.TimesheettimeClockApiFp(this.configuration).stop(id, version, options)(this.fetch, this.basePath);
    };
    return TimesheettimeClockApi;
}(BaseAPI));
exports.TimesheettimeClockApi = TimesheettimeClockApi;
/**
 * TokenconsumerApi - fetch parameter creator
 * @export
 */
exports.TokenconsumerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get consumer token by token string.
         * @param {string} token Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByToken: function (token, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token', 'Required parameter token was null or undefined when calling getByToken.');
            }
            var localVarPath = "/token/consumer/byToken";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TokenconsumerApi - functional programming interface
 * @export
 */
exports.TokenconsumerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get consumer token by token string.
         * @param {string} token Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByToken: function (token, fields, options) {
            var localVarFetchArgs = exports.TokenconsumerApiFetchParamCreator(configuration).getByToken(token, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TokenconsumerApi - factory interface
 * @export
 */
exports.TokenconsumerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get consumer token by token string.
         * @param {string} token Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByToken: function (token, fields, options) {
            return exports.TokenconsumerApiFp(configuration).getByToken(token, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TokenconsumerApi - object-oriented interface
 * @export
 * @class TokenconsumerApi
 * @extends {BaseAPI}
 */
var TokenconsumerApi = /** @class */ (function (_super) {
    __extends(TokenconsumerApi, _super);
    function TokenconsumerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get consumer token by token string.
     * @param {string} token Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenconsumerApi
     */
    TokenconsumerApi.prototype.getByToken = function (token, fields, options) {
        return exports.TokenconsumerApiFp(this.configuration).getByToken(token, fields, options)(this.fetch, this.basePath);
    };
    return TokenconsumerApi;
}(BaseAPI));
exports.TokenconsumerApi = TokenconsumerApi;
/**
 * TokenemployeeApi - fetch parameter creator
 * @export
 */
exports.TokenemployeeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create an employee token. Only selected consumers are allowed
         * @param {string} tokenName A user defined name for the new token
         * @param {string} consumerName The name of the consumer
         * @param {number} employeeId The id of the employee
         * @param {boolean} companyOwned Is the key company owned
         * @param {string} expirationDate Expiration date for the employeeToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: function (tokenName, consumerName, employeeId, companyOwned, expirationDate, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'tokenName' is not null or undefined
            if (tokenName === null || tokenName === undefined) {
                throw new RequiredError('tokenName', 'Required parameter tokenName was null or undefined when calling create.');
            }
            // verify required parameter 'consumerName' is not null or undefined
            if (consumerName === null || consumerName === undefined) {
                throw new RequiredError('consumerName', 'Required parameter consumerName was null or undefined when calling create.');
            }
            // verify required parameter 'employeeId' is not null or undefined
            if (employeeId === null || employeeId === undefined) {
                throw new RequiredError('employeeId', 'Required parameter employeeId was null or undefined when calling create.');
            }
            // verify required parameter 'companyOwned' is not null or undefined
            if (companyOwned === null || companyOwned === undefined) {
                throw new RequiredError('companyOwned', 'Required parameter companyOwned was null or undefined when calling create.');
            }
            // verify required parameter 'expirationDate' is not null or undefined
            if (expirationDate === null || expirationDate === undefined) {
                throw new RequiredError('expirationDate', 'Required parameter expirationDate was null or undefined when calling create.');
            }
            var localVarPath = "/token/employee/:create";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (tokenName !== undefined) {
                localVarQueryParameter['tokenName'] = tokenName;
            }
            if (consumerName !== undefined) {
                localVarQueryParameter['consumerName'] = consumerName;
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (companyOwned !== undefined) {
                localVarQueryParameter['companyOwned'] = companyOwned;
            }
            if (expirationDate !== undefined) {
                localVarQueryParameter['expirationDate'] = expirationDate;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TokenemployeeApi - functional programming interface
 * @export
 */
exports.TokenemployeeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create an employee token. Only selected consumers are allowed
         * @param {string} tokenName A user defined name for the new token
         * @param {string} consumerName The name of the consumer
         * @param {number} employeeId The id of the employee
         * @param {boolean} companyOwned Is the key company owned
         * @param {string} expirationDate Expiration date for the employeeToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: function (tokenName, consumerName, employeeId, companyOwned, expirationDate, options) {
            var localVarFetchArgs = exports.TokenemployeeApiFetchParamCreator(configuration).create(tokenName, consumerName, employeeId, companyOwned, expirationDate, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TokenemployeeApi - factory interface
 * @export
 */
exports.TokenemployeeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Create an employee token. Only selected consumers are allowed
         * @param {string} tokenName A user defined name for the new token
         * @param {string} consumerName The name of the consumer
         * @param {number} employeeId The id of the employee
         * @param {boolean} companyOwned Is the key company owned
         * @param {string} expirationDate Expiration date for the employeeToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: function (tokenName, consumerName, employeeId, companyOwned, expirationDate, options) {
            return exports.TokenemployeeApiFp(configuration).create(tokenName, consumerName, employeeId, companyOwned, expirationDate, options)(fetch, basePath);
        },
    };
};
/**
 * TokenemployeeApi - object-oriented interface
 * @export
 * @class TokenemployeeApi
 * @extends {BaseAPI}
 */
var TokenemployeeApi = /** @class */ (function (_super) {
    __extends(TokenemployeeApi, _super);
    function TokenemployeeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create an employee token. Only selected consumers are allowed
     * @param {string} tokenName A user defined name for the new token
     * @param {string} consumerName The name of the consumer
     * @param {number} employeeId The id of the employee
     * @param {boolean} companyOwned Is the key company owned
     * @param {string} expirationDate Expiration date for the employeeToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenemployeeApi
     */
    TokenemployeeApi.prototype.create = function (tokenName, consumerName, employeeId, companyOwned, expirationDate, options) {
        return exports.TokenemployeeApiFp(this.configuration).create(tokenName, consumerName, employeeId, companyOwned, expirationDate, options)(this.fetch, this.basePath);
    };
    return TokenemployeeApi;
}(BaseAPI));
exports.TokenemployeeApi = TokenemployeeApi;
/**
 * TokensessionApi - fetch parameter creator
 * @export
 */
exports.TokensessionApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Delete session token.
         * @param {string} token The login token string to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (token, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token', 'Required parameter token was null or undefined when calling _delete.');
            }
            var localVarPath = "/token/session/{token}"
                .replace("{" + "token" + "}", encodeURIComponent(String(token)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create session token.
         * @param {string} consumerToken Token of the API consumer
         * @param {string} employeeToken The employees token
         * @param {string} expirationDate Expiration date for the combined token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: function (consumerToken, employeeToken, expirationDate, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'consumerToken' is not null or undefined
            if (consumerToken === null || consumerToken === undefined) {
                throw new RequiredError('consumerToken', 'Required parameter consumerToken was null or undefined when calling create.');
            }
            // verify required parameter 'employeeToken' is not null or undefined
            if (employeeToken === null || employeeToken === undefined) {
                throw new RequiredError('employeeToken', 'Required parameter employeeToken was null or undefined when calling create.');
            }
            // verify required parameter 'expirationDate' is not null or undefined
            if (expirationDate === null || expirationDate === undefined) {
                throw new RequiredError('expirationDate', 'Required parameter expirationDate was null or undefined when calling create.');
            }
            var localVarPath = "/token/session/:create";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (consumerToken !== undefined) {
                localVarQueryParameter['consumerToken'] = consumerToken;
            }
            if (employeeToken !== undefined) {
                localVarQueryParameter['employeeToken'] = employeeToken;
            }
            if (expirationDate !== undefined) {
                localVarQueryParameter['expirationDate'] = expirationDate;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find information about the current user.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoAmI: function (fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/token/session/>whoAmI";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TokensessionApi - functional programming interface
 * @export
 */
exports.TokensessionApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Delete session token.
         * @param {string} token The login token string to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (token, options) {
            var localVarFetchArgs = exports.TokensessionApiFetchParamCreator(configuration)._delete(token, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create session token.
         * @param {string} consumerToken Token of the API consumer
         * @param {string} employeeToken The employees token
         * @param {string} expirationDate Expiration date for the combined token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: function (consumerToken, employeeToken, expirationDate, options) {
            var localVarFetchArgs = exports.TokensessionApiFetchParamCreator(configuration).create(consumerToken, employeeToken, expirationDate, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find information about the current user.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoAmI: function (fields, options) {
            var localVarFetchArgs = exports.TokensessionApiFetchParamCreator(configuration).whoAmI(fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TokensessionApi - factory interface
 * @export
 */
exports.TokensessionApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Delete session token.
         * @param {string} token The login token string to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (token, options) {
            return exports.TokensessionApiFp(configuration)._delete(token, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create session token.
         * @param {string} consumerToken Token of the API consumer
         * @param {string} employeeToken The employees token
         * @param {string} expirationDate Expiration date for the combined token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: function (consumerToken, employeeToken, expirationDate, options) {
            return exports.TokensessionApiFp(configuration).create(consumerToken, employeeToken, expirationDate, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find information about the current user.
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoAmI: function (fields, options) {
            return exports.TokensessionApiFp(configuration).whoAmI(fields, options)(fetch, basePath);
        },
    };
};
/**
 * TokensessionApi - object-oriented interface
 * @export
 * @class TokensessionApi
 * @extends {BaseAPI}
 */
var TokensessionApi = /** @class */ (function (_super) {
    __extends(TokensessionApi, _super);
    function TokensessionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Delete session token.
     * @param {string} token The login token string to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensessionApi
     */
    TokensessionApi.prototype._delete = function (token, options) {
        return exports.TokensessionApiFp(this.configuration)._delete(token, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create session token.
     * @param {string} consumerToken Token of the API consumer
     * @param {string} employeeToken The employees token
     * @param {string} expirationDate Expiration date for the combined token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensessionApi
     */
    TokensessionApi.prototype.create = function (consumerToken, employeeToken, expirationDate, options) {
        return exports.TokensessionApiFp(this.configuration).create(consumerToken, employeeToken, expirationDate, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Find information about the current user.
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensessionApi
     */
    TokensessionApi.prototype.whoAmI = function (fields, options) {
        return exports.TokensessionApiFp(this.configuration).whoAmI(fields, options)(this.fetch, this.basePath);
    };
    return TokensessionApi;
}(BaseAPI));
exports.TokensessionApi = TokensessionApi;
/**
 * TravelExpenseApi - fetch parameter creator
 * @export
 */
exports.TravelExpenseApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/travelExpense/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Approve travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve: function (id, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/:approve";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Copy travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copy: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling copy.');
            }
            var localVarPath = "/travelExpense/:copy";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Deliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliver: function (id, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/:deliver";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get travel expense by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/travelExpense/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create travel expense.
         * @param {TravelExpense} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("TravelExpense" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update travel expense.
         * @param {number} id Element ID
         * @param {TravelExpense} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/travelExpense/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("TravelExpense" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find travel expenses corresponding with sent data.
         * @param {string} [employeeId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectManagerId] Equals
         * @param {string} [departureDateFrom] From and including
         * @param {string} [returnDateTo] To and excluding
         * @param {string} [state] category
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, departmentId, projectId, projectManagerId, departureDateFrom, returnDateTo, state, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }
            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (projectManagerId !== undefined) {
                localVarQueryParameter['projectManagerId'] = projectManagerId;
            }
            if (departureDateFrom !== undefined) {
                localVarQueryParameter['departureDateFrom'] = departureDateFrom;
            }
            if (returnDateTo !== undefined) {
                localVarQueryParameter['returnDateTo'] = returnDateTo;
            }
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Unapprove travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unapprove: function (id, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/:unapprove";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Undeliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeliver: function (id, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/:undeliver";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TravelExpenseApi - functional programming interface
 * @export
 */
exports.TravelExpenseApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.TravelExpenseApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Approve travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve: function (id, options) {
            var localVarFetchArgs = exports.TravelExpenseApiFetchParamCreator(configuration).approve(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Copy travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copy: function (id, options) {
            var localVarFetchArgs = exports.TravelExpenseApiFetchParamCreator(configuration).copy(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Deliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliver: function (id, options) {
            var localVarFetchArgs = exports.TravelExpenseApiFetchParamCreator(configuration).deliver(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get travel expense by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TravelExpenseApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create travel expense.
         * @param {TravelExpense} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.TravelExpenseApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update travel expense.
         * @param {number} id Element ID
         * @param {TravelExpense} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.TravelExpenseApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find travel expenses corresponding with sent data.
         * @param {string} [employeeId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectManagerId] Equals
         * @param {string} [departureDateFrom] From and including
         * @param {string} [returnDateTo] To and excluding
         * @param {string} [state] category
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, departmentId, projectId, projectManagerId, departureDateFrom, returnDateTo, state, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TravelExpenseApiFetchParamCreator(configuration).search(employeeId, departmentId, projectId, projectManagerId, departureDateFrom, returnDateTo, state, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Unapprove travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unapprove: function (id, options) {
            var localVarFetchArgs = exports.TravelExpenseApiFetchParamCreator(configuration).unapprove(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Undeliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeliver: function (id, options) {
            var localVarFetchArgs = exports.TravelExpenseApiFetchParamCreator(configuration).undeliver(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TravelExpenseApi - factory interface
 * @export
 */
exports.TravelExpenseApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.TravelExpenseApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Approve travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve: function (id, options) {
            return exports.TravelExpenseApiFp(configuration).approve(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Copy travel expense.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copy: function (id, options) {
            return exports.TravelExpenseApiFp(configuration).copy(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Deliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliver: function (id, options) {
            return exports.TravelExpenseApiFp(configuration).deliver(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get travel expense by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TravelExpenseApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create travel expense.
         * @param {TravelExpense} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.TravelExpenseApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update travel expense.
         * @param {number} id Element ID
         * @param {TravelExpense} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.TravelExpenseApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find travel expenses corresponding with sent data.
         * @param {string} [employeeId] Equals
         * @param {string} [departmentId] Equals
         * @param {string} [projectId] Equals
         * @param {string} [projectManagerId] Equals
         * @param {string} [departureDateFrom] From and including
         * @param {string} [returnDateTo] To and excluding
         * @param {string} [state] category
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (employeeId, departmentId, projectId, projectManagerId, departureDateFrom, returnDateTo, state, from, count, sorting, fields, options) {
            return exports.TravelExpenseApiFp(configuration).search(employeeId, departmentId, projectId, projectManagerId, departureDateFrom, returnDateTo, state, from, count, sorting, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Unapprove travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unapprove: function (id, options) {
            return exports.TravelExpenseApiFp(configuration).unapprove(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Undeliver travel expenses.
         * @param {string} [id] ID of the elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeliver: function (id, options) {
            return exports.TravelExpenseApiFp(configuration).undeliver(id, options)(fetch, basePath);
        },
    };
};
/**
 * TravelExpenseApi - object-oriented interface
 * @export
 * @class TravelExpenseApi
 * @extends {BaseAPI}
 */
var TravelExpenseApi = /** @class */ (function (_super) {
    __extends(TravelExpenseApi, _super);
    function TravelExpenseApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete travel expense.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    TravelExpenseApi.prototype._delete = function (id, options) {
        return exports.TravelExpenseApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Approve travel expenses.
     * @param {string} [id] ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    TravelExpenseApi.prototype.approve = function (id, options) {
        return exports.TravelExpenseApiFp(this.configuration).approve(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Copy travel expense.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    TravelExpenseApi.prototype.copy = function (id, options) {
        return exports.TravelExpenseApiFp(this.configuration).copy(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Deliver travel expenses.
     * @param {string} [id] ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    TravelExpenseApi.prototype.deliver = function (id, options) {
        return exports.TravelExpenseApiFp(this.configuration).deliver(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get travel expense by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    TravelExpenseApi.prototype.get = function (id, fields, options) {
        return exports.TravelExpenseApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create travel expense.
     * @param {TravelExpense} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    TravelExpenseApi.prototype.post = function (body, options) {
        return exports.TravelExpenseApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update travel expense.
     * @param {number} id Element ID
     * @param {TravelExpense} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    TravelExpenseApi.prototype.put = function (id, body, options) {
        return exports.TravelExpenseApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find travel expenses corresponding with sent data.
     * @param {string} [employeeId] Equals
     * @param {string} [departmentId] Equals
     * @param {string} [projectId] Equals
     * @param {string} [projectManagerId] Equals
     * @param {string} [departureDateFrom] From and including
     * @param {string} [returnDateTo] To and excluding
     * @param {string} [state] category
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    TravelExpenseApi.prototype.search = function (employeeId, departmentId, projectId, projectManagerId, departureDateFrom, returnDateTo, state, from, count, sorting, fields, options) {
        return exports.TravelExpenseApiFp(this.configuration).search(employeeId, departmentId, projectId, projectManagerId, departureDateFrom, returnDateTo, state, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Unapprove travel expenses.
     * @param {string} [id] ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    TravelExpenseApi.prototype.unapprove = function (id, options) {
        return exports.TravelExpenseApiFp(this.configuration).unapprove(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Undeliver travel expenses.
     * @param {string} [id] ID of the elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseApi
     */
    TravelExpenseApi.prototype.undeliver = function (id, options) {
        return exports.TravelExpenseApiFp(this.configuration).undeliver(id, options)(this.fetch, this.basePath);
    };
    return TravelExpenseApi;
}(BaseAPI));
exports.TravelExpenseApi = TravelExpenseApi;
/**
 * TravelExpenseaccommodationAllowanceApi - fetch parameter creator
 * @export
 */
exports.TravelExpenseaccommodationAllowanceApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete accommodation allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/travelExpense/accommodationAllowance/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get travel accommodation allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/travelExpense/accommodationAllowance/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create accommodation allowance.
         * @param {AccommodationAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/accommodationAllowance";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("AccommodationAllowance" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update accommodation allowance.
         * @param {number} id Element ID
         * @param {AccommodationAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/travelExpense/accommodationAllowance/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("AccommodationAllowance" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find accommodation allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, rateTypeId, rateCategoryId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/accommodationAllowance";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (travelExpenseId !== undefined) {
                localVarQueryParameter['travelExpenseId'] = travelExpenseId;
            }
            if (rateTypeId !== undefined) {
                localVarQueryParameter['rateTypeId'] = rateTypeId;
            }
            if (rateCategoryId !== undefined) {
                localVarQueryParameter['rateCategoryId'] = rateCategoryId;
            }
            if (rateFrom !== undefined) {
                localVarQueryParameter['rateFrom'] = rateFrom;
            }
            if (rateTo !== undefined) {
                localVarQueryParameter['rateTo'] = rateTo;
            }
            if (countFrom !== undefined) {
                localVarQueryParameter['countFrom'] = countFrom;
            }
            if (countTo !== undefined) {
                localVarQueryParameter['countTo'] = countTo;
            }
            if (amountFrom !== undefined) {
                localVarQueryParameter['amountFrom'] = amountFrom;
            }
            if (amountTo !== undefined) {
                localVarQueryParameter['amountTo'] = amountTo;
            }
            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TravelExpenseaccommodationAllowanceApi - functional programming interface
 * @export
 */
exports.TravelExpenseaccommodationAllowanceApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete accommodation allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.TravelExpenseaccommodationAllowanceApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get travel accommodation allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TravelExpenseaccommodationAllowanceApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create accommodation allowance.
         * @param {AccommodationAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.TravelExpenseaccommodationAllowanceApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update accommodation allowance.
         * @param {number} id Element ID
         * @param {AccommodationAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.TravelExpenseaccommodationAllowanceApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find accommodation allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, rateTypeId, rateCategoryId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TravelExpenseaccommodationAllowanceApiFetchParamCreator(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TravelExpenseaccommodationAllowanceApi - factory interface
 * @export
 */
exports.TravelExpenseaccommodationAllowanceApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete accommodation allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.TravelExpenseaccommodationAllowanceApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get travel accommodation allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TravelExpenseaccommodationAllowanceApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create accommodation allowance.
         * @param {AccommodationAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.TravelExpenseaccommodationAllowanceApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update accommodation allowance.
         * @param {number} id Element ID
         * @param {AccommodationAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.TravelExpenseaccommodationAllowanceApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find accommodation allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, rateTypeId, rateCategoryId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options) {
            return exports.TravelExpenseaccommodationAllowanceApiFp(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TravelExpenseaccommodationAllowanceApi - object-oriented interface
 * @export
 * @class TravelExpenseaccommodationAllowanceApi
 * @extends {BaseAPI}
 */
var TravelExpenseaccommodationAllowanceApi = /** @class */ (function (_super) {
    __extends(TravelExpenseaccommodationAllowanceApi, _super);
    function TravelExpenseaccommodationAllowanceApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete accommodation allowance.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseaccommodationAllowanceApi
     */
    TravelExpenseaccommodationAllowanceApi.prototype._delete = function (id, options) {
        return exports.TravelExpenseaccommodationAllowanceApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get travel accommodation allowance by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseaccommodationAllowanceApi
     */
    TravelExpenseaccommodationAllowanceApi.prototype.get = function (id, fields, options) {
        return exports.TravelExpenseaccommodationAllowanceApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create accommodation allowance.
     * @param {AccommodationAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseaccommodationAllowanceApi
     */
    TravelExpenseaccommodationAllowanceApi.prototype.post = function (body, options) {
        return exports.TravelExpenseaccommodationAllowanceApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update accommodation allowance.
     * @param {number} id Element ID
     * @param {AccommodationAllowance} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseaccommodationAllowanceApi
     */
    TravelExpenseaccommodationAllowanceApi.prototype.put = function (id, body, options) {
        return exports.TravelExpenseaccommodationAllowanceApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find accommodation allowances corresponding with sent data.
     * @param {string} [travelExpenseId] Equals
     * @param {string} [rateTypeId] Equals
     * @param {string} [rateCategoryId] Equals
     * @param {number} [rateFrom] From and including
     * @param {number} [rateTo] To and excluding
     * @param {number} [countFrom] From and including
     * @param {number} [countTo] To and excluding
     * @param {number} [amountFrom] From and including
     * @param {number} [amountTo] To and excluding
     * @param {string} [location] Containing
     * @param {string} [address] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseaccommodationAllowanceApi
     */
    TravelExpenseaccommodationAllowanceApi.prototype.search = function (travelExpenseId, rateTypeId, rateCategoryId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options) {
        return exports.TravelExpenseaccommodationAllowanceApiFp(this.configuration).search(travelExpenseId, rateTypeId, rateCategoryId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return TravelExpenseaccommodationAllowanceApi;
}(BaseAPI));
exports.TravelExpenseaccommodationAllowanceApi = TravelExpenseaccommodationAllowanceApi;
/**
 * TravelExpensecostApi - fetch parameter creator
 * @export
 */
exports.TravelExpensecostApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete cost.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/travelExpense/cost/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get cost by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/travelExpense/cost/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create cost.
         * @param {Cost} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/cost";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Cost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update cost.
         * @param {number} id Element ID
         * @param {Cost} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/travelExpense/cost/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Cost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find costs corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [currencyId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, vatTypeId, currencyId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/cost";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (travelExpenseId !== undefined) {
                localVarQueryParameter['travelExpenseId'] = travelExpenseId;
            }
            if (vatTypeId !== undefined) {
                localVarQueryParameter['vatTypeId'] = vatTypeId;
            }
            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }
            if (rateFrom !== undefined) {
                localVarQueryParameter['rateFrom'] = rateFrom;
            }
            if (rateTo !== undefined) {
                localVarQueryParameter['rateTo'] = rateTo;
            }
            if (countFrom !== undefined) {
                localVarQueryParameter['countFrom'] = countFrom;
            }
            if (countTo !== undefined) {
                localVarQueryParameter['countTo'] = countTo;
            }
            if (amountFrom !== undefined) {
                localVarQueryParameter['amountFrom'] = amountFrom;
            }
            if (amountTo !== undefined) {
                localVarQueryParameter['amountTo'] = amountTo;
            }
            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TravelExpensecostApi - functional programming interface
 * @export
 */
exports.TravelExpensecostApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete cost.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.TravelExpensecostApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get cost by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TravelExpensecostApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create cost.
         * @param {Cost} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.TravelExpensecostApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update cost.
         * @param {number} id Element ID
         * @param {Cost} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.TravelExpensecostApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find costs corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [currencyId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, vatTypeId, currencyId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TravelExpensecostApiFetchParamCreator(configuration).search(travelExpenseId, vatTypeId, currencyId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TravelExpensecostApi - factory interface
 * @export
 */
exports.TravelExpensecostApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete cost.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.TravelExpensecostApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get cost by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TravelExpensecostApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create cost.
         * @param {Cost} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.TravelExpensecostApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update cost.
         * @param {number} id Element ID
         * @param {Cost} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.TravelExpensecostApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find costs corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [vatTypeId] Equals
         * @param {string} [currencyId] Equals
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, vatTypeId, currencyId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options) {
            return exports.TravelExpensecostApiFp(configuration).search(travelExpenseId, vatTypeId, currencyId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TravelExpensecostApi - object-oriented interface
 * @export
 * @class TravelExpensecostApi
 * @extends {BaseAPI}
 */
var TravelExpensecostApi = /** @class */ (function (_super) {
    __extends(TravelExpensecostApi, _super);
    function TravelExpensecostApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete cost.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostApi
     */
    TravelExpensecostApi.prototype._delete = function (id, options) {
        return exports.TravelExpensecostApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get cost by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostApi
     */
    TravelExpensecostApi.prototype.get = function (id, fields, options) {
        return exports.TravelExpensecostApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create cost.
     * @param {Cost} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostApi
     */
    TravelExpensecostApi.prototype.post = function (body, options) {
        return exports.TravelExpensecostApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update cost.
     * @param {number} id Element ID
     * @param {Cost} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostApi
     */
    TravelExpensecostApi.prototype.put = function (id, body, options) {
        return exports.TravelExpensecostApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find costs corresponding with sent data.
     * @param {string} [travelExpenseId] Equals
     * @param {string} [vatTypeId] Equals
     * @param {string} [currencyId] Equals
     * @param {number} [rateFrom] From and including
     * @param {number} [rateTo] To and excluding
     * @param {number} [countFrom] From and including
     * @param {number} [countTo] To and excluding
     * @param {number} [amountFrom] From and including
     * @param {number} [amountTo] To and excluding
     * @param {string} [location] Containing
     * @param {string} [address] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostApi
     */
    TravelExpensecostApi.prototype.search = function (travelExpenseId, vatTypeId, currencyId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options) {
        return exports.TravelExpensecostApiFp(this.configuration).search(travelExpenseId, vatTypeId, currencyId, rateFrom, rateTo, countFrom, countTo, amountFrom, amountTo, location, address, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return TravelExpensecostApi;
}(BaseAPI));
exports.TravelExpensecostApi = TravelExpensecostApi;
/**
 * TravelExpensecostCategoryApi - fetch parameter creator
 * @export
 */
exports.TravelExpensecostCategoryApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get cost category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/travelExpense/costCategory/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find cost category corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/costCategory";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TravelExpensecostCategoryApi - functional programming interface
 * @export
 */
exports.TravelExpensecostCategoryApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get cost category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TravelExpensecostCategoryApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find cost category corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TravelExpensecostCategoryApiFetchParamCreator(configuration).search(id, description, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TravelExpensecostCategoryApi - factory interface
 * @export
 */
exports.TravelExpensecostCategoryApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Get cost category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TravelExpensecostCategoryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find cost category corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            return exports.TravelExpensecostCategoryApiFp(configuration).search(id, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TravelExpensecostCategoryApi - object-oriented interface
 * @export
 * @class TravelExpensecostCategoryApi
 * @extends {BaseAPI}
 */
var TravelExpensecostCategoryApi = /** @class */ (function (_super) {
    __extends(TravelExpensecostCategoryApi, _super);
    function TravelExpensecostCategoryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Get cost category by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostCategoryApi
     */
    TravelExpensecostCategoryApi.prototype.get = function (id, fields, options) {
        return exports.TravelExpensecostCategoryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find cost category corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [description] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensecostCategoryApi
     */
    TravelExpensecostCategoryApi.prototype.search = function (id, description, from, count, sorting, fields, options) {
        return exports.TravelExpensecostCategoryApiFp(this.configuration).search(id, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return TravelExpensecostCategoryApi;
}(BaseAPI));
exports.TravelExpensecostCategoryApi = TravelExpensecostCategoryApi;
/**
 * TravelExpensemileageAllowanceApi - fetch parameter creator
 * @export
 */
exports.TravelExpensemileageAllowanceApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete mileage allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/travelExpense/mileageAllowance/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get mileage allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/travelExpense/mileageAllowance/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create mileage allowance.
         * @param {MileageAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/mileageAllowance";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("MileageAllowance" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update mileage allowance.
         * @param {number} id Element ID
         * @param {MileageAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/travelExpense/mileageAllowance/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("MileageAllowance" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find mileage allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [kmFrom] From and including
         * @param {number} [kmTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [departureLocation] Containing
         * @param {string} [destination] Containing
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {boolean} [isCompanyCar] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, rateTypeId, rateCategoryId, kmFrom, kmTo, rateFrom, rateTo, amountFrom, amountTo, departureLocation, destination, dateFrom, dateTo, isCompanyCar, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/mileageAllowance";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (travelExpenseId !== undefined) {
                localVarQueryParameter['travelExpenseId'] = travelExpenseId;
            }
            if (rateTypeId !== undefined) {
                localVarQueryParameter['rateTypeId'] = rateTypeId;
            }
            if (rateCategoryId !== undefined) {
                localVarQueryParameter['rateCategoryId'] = rateCategoryId;
            }
            if (kmFrom !== undefined) {
                localVarQueryParameter['kmFrom'] = kmFrom;
            }
            if (kmTo !== undefined) {
                localVarQueryParameter['kmTo'] = kmTo;
            }
            if (rateFrom !== undefined) {
                localVarQueryParameter['rateFrom'] = rateFrom;
            }
            if (rateTo !== undefined) {
                localVarQueryParameter['rateTo'] = rateTo;
            }
            if (amountFrom !== undefined) {
                localVarQueryParameter['amountFrom'] = amountFrom;
            }
            if (amountTo !== undefined) {
                localVarQueryParameter['amountTo'] = amountTo;
            }
            if (departureLocation !== undefined) {
                localVarQueryParameter['departureLocation'] = departureLocation;
            }
            if (destination !== undefined) {
                localVarQueryParameter['destination'] = destination;
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }
            if (isCompanyCar !== undefined) {
                localVarQueryParameter['isCompanyCar'] = isCompanyCar;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TravelExpensemileageAllowanceApi - functional programming interface
 * @export
 */
exports.TravelExpensemileageAllowanceApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete mileage allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.TravelExpensemileageAllowanceApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get mileage allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TravelExpensemileageAllowanceApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create mileage allowance.
         * @param {MileageAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.TravelExpensemileageAllowanceApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update mileage allowance.
         * @param {number} id Element ID
         * @param {MileageAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.TravelExpensemileageAllowanceApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find mileage allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [kmFrom] From and including
         * @param {number} [kmTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [departureLocation] Containing
         * @param {string} [destination] Containing
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {boolean} [isCompanyCar] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, rateTypeId, rateCategoryId, kmFrom, kmTo, rateFrom, rateTo, amountFrom, amountTo, departureLocation, destination, dateFrom, dateTo, isCompanyCar, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TravelExpensemileageAllowanceApiFetchParamCreator(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, kmFrom, kmTo, rateFrom, rateTo, amountFrom, amountTo, departureLocation, destination, dateFrom, dateTo, isCompanyCar, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TravelExpensemileageAllowanceApi - factory interface
 * @export
 */
exports.TravelExpensemileageAllowanceApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete mileage allowance.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.TravelExpensemileageAllowanceApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get mileage allowance by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TravelExpensemileageAllowanceApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create mileage allowance.
         * @param {MileageAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.TravelExpensemileageAllowanceApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update mileage allowance.
         * @param {number} id Element ID
         * @param {MileageAllowance} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.TravelExpensemileageAllowanceApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find mileage allowances corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {number} [kmFrom] From and including
         * @param {number} [kmTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [departureLocation] Containing
         * @param {string} [destination] Containing
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {boolean} [isCompanyCar] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, rateTypeId, rateCategoryId, kmFrom, kmTo, rateFrom, rateTo, amountFrom, amountTo, departureLocation, destination, dateFrom, dateTo, isCompanyCar, from, count, sorting, fields, options) {
            return exports.TravelExpensemileageAllowanceApiFp(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, kmFrom, kmTo, rateFrom, rateTo, amountFrom, amountTo, departureLocation, destination, dateFrom, dateTo, isCompanyCar, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TravelExpensemileageAllowanceApi - object-oriented interface
 * @export
 * @class TravelExpensemileageAllowanceApi
 * @extends {BaseAPI}
 */
var TravelExpensemileageAllowanceApi = /** @class */ (function (_super) {
    __extends(TravelExpensemileageAllowanceApi, _super);
    function TravelExpensemileageAllowanceApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete mileage allowance.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensemileageAllowanceApi
     */
    TravelExpensemileageAllowanceApi.prototype._delete = function (id, options) {
        return exports.TravelExpensemileageAllowanceApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get mileage allowance by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensemileageAllowanceApi
     */
    TravelExpensemileageAllowanceApi.prototype.get = function (id, fields, options) {
        return exports.TravelExpensemileageAllowanceApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create mileage allowance.
     * @param {MileageAllowance} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensemileageAllowanceApi
     */
    TravelExpensemileageAllowanceApi.prototype.post = function (body, options) {
        return exports.TravelExpensemileageAllowanceApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update mileage allowance.
     * @param {number} id Element ID
     * @param {MileageAllowance} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensemileageAllowanceApi
     */
    TravelExpensemileageAllowanceApi.prototype.put = function (id, body, options) {
        return exports.TravelExpensemileageAllowanceApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find mileage allowances corresponding with sent data.
     * @param {string} [travelExpenseId] Equals
     * @param {string} [rateTypeId] Equals
     * @param {string} [rateCategoryId] Equals
     * @param {number} [kmFrom] From and including
     * @param {number} [kmTo] To and excluding
     * @param {number} [rateFrom] From and including
     * @param {number} [rateTo] To and excluding
     * @param {number} [amountFrom] From and including
     * @param {number} [amountTo] To and excluding
     * @param {string} [departureLocation] Containing
     * @param {string} [destination] Containing
     * @param {string} [dateFrom] From and including
     * @param {string} [dateTo] To and excluding
     * @param {boolean} [isCompanyCar] Equals
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensemileageAllowanceApi
     */
    TravelExpensemileageAllowanceApi.prototype.search = function (travelExpenseId, rateTypeId, rateCategoryId, kmFrom, kmTo, rateFrom, rateTo, amountFrom, amountTo, departureLocation, destination, dateFrom, dateTo, isCompanyCar, from, count, sorting, fields, options) {
        return exports.TravelExpensemileageAllowanceApiFp(this.configuration).search(travelExpenseId, rateTypeId, rateCategoryId, kmFrom, kmTo, rateFrom, rateTo, amountFrom, amountTo, departureLocation, destination, dateFrom, dateTo, isCompanyCar, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return TravelExpensemileageAllowanceApi;
}(BaseAPI));
exports.TravelExpensemileageAllowanceApi = TravelExpensemileageAllowanceApi;
/**
 * TravelExpensepassengerApi - fetch parameter creator
 * @export
 */
exports.TravelExpensepassengerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete passenger.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/travelExpense/passenger/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get passenger by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/travelExpense/passenger/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create passenger.
         * @param {Passenger} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/passenger";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Passenger" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update passenger.
         * @param {number} id Element ID
         * @param {Passenger} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/travelExpense/passenger/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Passenger" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find passengers corresponding with sent data.
         * @param {string} [mileageAllowance] Equals
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (mileageAllowance, name, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/passenger";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (mileageAllowance !== undefined) {
                localVarQueryParameter['mileageAllowance'] = mileageAllowance;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TravelExpensepassengerApi - functional programming interface
 * @export
 */
exports.TravelExpensepassengerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete passenger.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.TravelExpensepassengerApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get passenger by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TravelExpensepassengerApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create passenger.
         * @param {Passenger} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.TravelExpensepassengerApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update passenger.
         * @param {number} id Element ID
         * @param {Passenger} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.TravelExpensepassengerApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find passengers corresponding with sent data.
         * @param {string} [mileageAllowance] Equals
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (mileageAllowance, name, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TravelExpensepassengerApiFetchParamCreator(configuration).search(mileageAllowance, name, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TravelExpensepassengerApi - factory interface
 * @export
 */
exports.TravelExpensepassengerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete passenger.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.TravelExpensepassengerApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get passenger by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TravelExpensepassengerApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create passenger.
         * @param {Passenger} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.TravelExpensepassengerApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update passenger.
         * @param {number} id Element ID
         * @param {Passenger} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.TravelExpensepassengerApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find passengers corresponding with sent data.
         * @param {string} [mileageAllowance] Equals
         * @param {string} [name] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (mileageAllowance, name, from, count, sorting, fields, options) {
            return exports.TravelExpensepassengerApiFp(configuration).search(mileageAllowance, name, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TravelExpensepassengerApi - object-oriented interface
 * @export
 * @class TravelExpensepassengerApi
 * @extends {BaseAPI}
 */
var TravelExpensepassengerApi = /** @class */ (function (_super) {
    __extends(TravelExpensepassengerApi, _super);
    function TravelExpensepassengerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete passenger.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepassengerApi
     */
    TravelExpensepassengerApi.prototype._delete = function (id, options) {
        return exports.TravelExpensepassengerApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get passenger by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepassengerApi
     */
    TravelExpensepassengerApi.prototype.get = function (id, fields, options) {
        return exports.TravelExpensepassengerApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create passenger.
     * @param {Passenger} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepassengerApi
     */
    TravelExpensepassengerApi.prototype.post = function (body, options) {
        return exports.TravelExpensepassengerApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update passenger.
     * @param {number} id Element ID
     * @param {Passenger} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepassengerApi
     */
    TravelExpensepassengerApi.prototype.put = function (id, body, options) {
        return exports.TravelExpensepassengerApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find passengers corresponding with sent data.
     * @param {string} [mileageAllowance] Equals
     * @param {string} [name] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepassengerApi
     */
    TravelExpensepassengerApi.prototype.search = function (mileageAllowance, name, from, count, sorting, fields, options) {
        return exports.TravelExpensepassengerApiFp(this.configuration).search(mileageAllowance, name, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return TravelExpensepassengerApi;
}(BaseAPI));
exports.TravelExpensepassengerApi = TravelExpensepassengerApi;
/**
 * TravelExpensepaymentTypeApi - fetch parameter creator
 * @export
 */
exports.TravelExpensepaymentTypeApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/travelExpense/paymentType/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/paymentType";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TravelExpensepaymentTypeApi - functional programming interface
 * @export
 */
exports.TravelExpensepaymentTypeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TravelExpensepaymentTypeApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TravelExpensepaymentTypeApiFetchParamCreator(configuration).search(id, description, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TravelExpensepaymentTypeApi - factory interface
 * @export
 */
exports.TravelExpensepaymentTypeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Get payment type by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TravelExpensepaymentTypeApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find payment type corresponding with sent data.
         * @param {string} [id] List of IDs
         * @param {string} [description] Containing
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (id, description, from, count, sorting, fields, options) {
            return exports.TravelExpensepaymentTypeApiFp(configuration).search(id, description, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TravelExpensepaymentTypeApi - object-oriented interface
 * @export
 * @class TravelExpensepaymentTypeApi
 * @extends {BaseAPI}
 */
var TravelExpensepaymentTypeApi = /** @class */ (function (_super) {
    __extends(TravelExpensepaymentTypeApi, _super);
    function TravelExpensepaymentTypeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Get payment type by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepaymentTypeApi
     */
    TravelExpensepaymentTypeApi.prototype.get = function (id, fields, options) {
        return exports.TravelExpensepaymentTypeApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find payment type corresponding with sent data.
     * @param {string} [id] List of IDs
     * @param {string} [description] Containing
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensepaymentTypeApi
     */
    TravelExpensepaymentTypeApi.prototype.search = function (id, description, from, count, sorting, fields, options) {
        return exports.TravelExpensepaymentTypeApiFp(this.configuration).search(id, description, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return TravelExpensepaymentTypeApi;
}(BaseAPI));
exports.TravelExpensepaymentTypeApi = TravelExpensepaymentTypeApi;
/**
 * TravelExpenseperDiemCompensationApi - fetch parameter creator
 * @export
 */
exports.TravelExpenseperDiemCompensationApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete per diem compensation.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            var localVarPath = "/travelExpense/perDiemCompensation/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Get per diem compensation by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/travelExpense/perDiemCompensation/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Create per diem compensation.
         * @param {PerDiemCompensation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/perDiemCompensation";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PerDiemCompensation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Update per diem compensation.
         * @param {number} id Element ID
         * @param {PerDiemCompensation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling put.');
            }
            var localVarPath = "/travelExpense/perDiemCompensation/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PerDiemCompensation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find per diem compensations corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {string} [overnightAccommodation] Equals
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {boolean} [isDeductionForBreakfast] Equals
         * @param {boolean} [isLunchDeduction] Equals
         * @param {boolean} [isDinnerDeduction] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, rateTypeId, rateCategoryId, overnightAccommodation, countFrom, countTo, rateFrom, rateTo, amountFrom, amountTo, location, address, isDeductionForBreakfast, isLunchDeduction, isDinnerDeduction, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/perDiemCompensation";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (travelExpenseId !== undefined) {
                localVarQueryParameter['travelExpenseId'] = travelExpenseId;
            }
            if (rateTypeId !== undefined) {
                localVarQueryParameter['rateTypeId'] = rateTypeId;
            }
            if (rateCategoryId !== undefined) {
                localVarQueryParameter['rateCategoryId'] = rateCategoryId;
            }
            if (overnightAccommodation !== undefined) {
                localVarQueryParameter['overnightAccommodation'] = overnightAccommodation;
            }
            if (countFrom !== undefined) {
                localVarQueryParameter['countFrom'] = countFrom;
            }
            if (countTo !== undefined) {
                localVarQueryParameter['countTo'] = countTo;
            }
            if (rateFrom !== undefined) {
                localVarQueryParameter['rateFrom'] = rateFrom;
            }
            if (rateTo !== undefined) {
                localVarQueryParameter['rateTo'] = rateTo;
            }
            if (amountFrom !== undefined) {
                localVarQueryParameter['amountFrom'] = amountFrom;
            }
            if (amountTo !== undefined) {
                localVarQueryParameter['amountTo'] = amountTo;
            }
            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (isDeductionForBreakfast !== undefined) {
                localVarQueryParameter['isDeductionForBreakfast'] = isDeductionForBreakfast;
            }
            if (isLunchDeduction !== undefined) {
                localVarQueryParameter['isLunchDeduction'] = isLunchDeduction;
            }
            if (isDinnerDeduction !== undefined) {
                localVarQueryParameter['isDinnerDeduction'] = isDinnerDeduction;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TravelExpenseperDiemCompensationApi - functional programming interface
 * @export
 */
exports.TravelExpenseperDiemCompensationApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Delete per diem compensation.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            var localVarFetchArgs = exports.TravelExpenseperDiemCompensationApiFetchParamCreator(configuration)._delete(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Get per diem compensation by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TravelExpenseperDiemCompensationApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Create per diem compensation.
         * @param {PerDiemCompensation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            var localVarFetchArgs = exports.TravelExpenseperDiemCompensationApiFetchParamCreator(configuration).post(body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Update per diem compensation.
         * @param {number} id Element ID
         * @param {PerDiemCompensation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            var localVarFetchArgs = exports.TravelExpenseperDiemCompensationApiFetchParamCreator(configuration).put(id, body, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find per diem compensations corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {string} [overnightAccommodation] Equals
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {boolean} [isDeductionForBreakfast] Equals
         * @param {boolean} [isLunchDeduction] Equals
         * @param {boolean} [isDinnerDeduction] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, rateTypeId, rateCategoryId, overnightAccommodation, countFrom, countTo, rateFrom, rateTo, amountFrom, amountTo, location, address, isDeductionForBreakfast, isLunchDeduction, isDinnerDeduction, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TravelExpenseperDiemCompensationApiFetchParamCreator(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, overnightAccommodation, countFrom, countTo, rateFrom, rateTo, amountFrom, amountTo, location, address, isDeductionForBreakfast, isLunchDeduction, isDinnerDeduction, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TravelExpenseperDiemCompensationApi - factory interface
 * @export
 */
exports.TravelExpenseperDiemCompensationApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Delete per diem compensation.
         * @param {number} id Element ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: function (id, options) {
            return exports.TravelExpenseperDiemCompensationApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Get per diem compensation by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TravelExpenseperDiemCompensationApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Create per diem compensation.
         * @param {PerDiemCompensation} [body] JSON representing the new object to be created. Should not have ID and version set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: function (body, options) {
            return exports.TravelExpenseperDiemCompensationApiFp(configuration).post(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Update per diem compensation.
         * @param {number} id Element ID
         * @param {PerDiemCompensation} [body] Partial object describing what should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: function (id, body, options) {
            return exports.TravelExpenseperDiemCompensationApiFp(configuration).put(id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find per diem compensations corresponding with sent data.
         * @param {string} [travelExpenseId] Equals
         * @param {string} [rateTypeId] Equals
         * @param {string} [rateCategoryId] Equals
         * @param {string} [overnightAccommodation] Equals
         * @param {number} [countFrom] From and including
         * @param {number} [countTo] To and excluding
         * @param {number} [rateFrom] From and including
         * @param {number} [rateTo] To and excluding
         * @param {number} [amountFrom] From and including
         * @param {number} [amountTo] To and excluding
         * @param {string} [location] Containing
         * @param {string} [address] Containing
         * @param {boolean} [isDeductionForBreakfast] Equals
         * @param {boolean} [isLunchDeduction] Equals
         * @param {boolean} [isDinnerDeduction] Equals
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (travelExpenseId, rateTypeId, rateCategoryId, overnightAccommodation, countFrom, countTo, rateFrom, rateTo, amountFrom, amountTo, location, address, isDeductionForBreakfast, isLunchDeduction, isDinnerDeduction, from, count, sorting, fields, options) {
            return exports.TravelExpenseperDiemCompensationApiFp(configuration).search(travelExpenseId, rateTypeId, rateCategoryId, overnightAccommodation, countFrom, countTo, rateFrom, rateTo, amountFrom, amountTo, location, address, isDeductionForBreakfast, isLunchDeduction, isDinnerDeduction, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TravelExpenseperDiemCompensationApi - object-oriented interface
 * @export
 * @class TravelExpenseperDiemCompensationApi
 * @extends {BaseAPI}
 */
var TravelExpenseperDiemCompensationApi = /** @class */ (function (_super) {
    __extends(TravelExpenseperDiemCompensationApi, _super);
    function TravelExpenseperDiemCompensationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Delete per diem compensation.
     * @param {number} id Element ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseperDiemCompensationApi
     */
    TravelExpenseperDiemCompensationApi.prototype._delete = function (id, options) {
        return exports.TravelExpenseperDiemCompensationApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Get per diem compensation by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseperDiemCompensationApi
     */
    TravelExpenseperDiemCompensationApi.prototype.get = function (id, fields, options) {
        return exports.TravelExpenseperDiemCompensationApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Create per diem compensation.
     * @param {PerDiemCompensation} [body] JSON representing the new object to be created. Should not have ID and version set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseperDiemCompensationApi
     */
    TravelExpenseperDiemCompensationApi.prototype.post = function (body, options) {
        return exports.TravelExpenseperDiemCompensationApiFp(this.configuration).post(body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Update per diem compensation.
     * @param {number} id Element ID
     * @param {PerDiemCompensation} [body] Partial object describing what should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseperDiemCompensationApi
     */
    TravelExpenseperDiemCompensationApi.prototype.put = function (id, body, options) {
        return exports.TravelExpenseperDiemCompensationApiFp(this.configuration).put(id, body, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find per diem compensations corresponding with sent data.
     * @param {string} [travelExpenseId] Equals
     * @param {string} [rateTypeId] Equals
     * @param {string} [rateCategoryId] Equals
     * @param {string} [overnightAccommodation] Equals
     * @param {number} [countFrom] From and including
     * @param {number} [countTo] To and excluding
     * @param {number} [rateFrom] From and including
     * @param {number} [rateTo] To and excluding
     * @param {number} [amountFrom] From and including
     * @param {number} [amountTo] To and excluding
     * @param {string} [location] Containing
     * @param {string} [address] Containing
     * @param {boolean} [isDeductionForBreakfast] Equals
     * @param {boolean} [isLunchDeduction] Equals
     * @param {boolean} [isDinnerDeduction] Equals
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenseperDiemCompensationApi
     */
    TravelExpenseperDiemCompensationApi.prototype.search = function (travelExpenseId, rateTypeId, rateCategoryId, overnightAccommodation, countFrom, countTo, rateFrom, rateTo, amountFrom, amountTo, location, address, isDeductionForBreakfast, isLunchDeduction, isDinnerDeduction, from, count, sorting, fields, options) {
        return exports.TravelExpenseperDiemCompensationApiFp(this.configuration).search(travelExpenseId, rateTypeId, rateCategoryId, overnightAccommodation, countFrom, countTo, rateFrom, rateTo, amountFrom, amountTo, location, address, isDeductionForBreakfast, isLunchDeduction, isDinnerDeduction, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return TravelExpenseperDiemCompensationApi;
}(BaseAPI));
exports.TravelExpenseperDiemCompensationApi = TravelExpenseperDiemCompensationApi;
/**
 * TravelExpenserateApi - fetch parameter creator
 * @export
 */
exports.TravelExpenserateApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get travel expense rate by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/travelExpense/rate/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find rates corresponding with sent data.
         * @param {string} [rateCategoryId] Equals
         * @param {string} [type] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [isValidForeignTravel] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [requiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (rateCategoryId, type, isValidDayTrip, isValidAccommodation, isValidDomestic, isValidForeignTravel, requiresZone, requiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/rate";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (rateCategoryId !== undefined) {
                localVarQueryParameter['rateCategoryId'] = rateCategoryId;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (isValidDayTrip !== undefined) {
                localVarQueryParameter['isValidDayTrip'] = isValidDayTrip;
            }
            if (isValidAccommodation !== undefined) {
                localVarQueryParameter['isValidAccommodation'] = isValidAccommodation;
            }
            if (isValidDomestic !== undefined) {
                localVarQueryParameter['isValidDomestic'] = isValidDomestic;
            }
            if (isValidForeignTravel !== undefined) {
                localVarQueryParameter['isValidForeignTravel'] = isValidForeignTravel;
            }
            if (requiresZone !== undefined) {
                localVarQueryParameter['requiresZone'] = requiresZone;
            }
            if (requiresOvernightAccommodation !== undefined) {
                localVarQueryParameter['requiresOvernightAccommodation'] = requiresOvernightAccommodation;
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TravelExpenserateApi - functional programming interface
 * @export
 */
exports.TravelExpenserateApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get travel expense rate by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TravelExpenserateApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find rates corresponding with sent data.
         * @param {string} [rateCategoryId] Equals
         * @param {string} [type] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [isValidForeignTravel] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [requiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (rateCategoryId, type, isValidDayTrip, isValidAccommodation, isValidDomestic, isValidForeignTravel, requiresZone, requiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TravelExpenserateApiFetchParamCreator(configuration).search(rateCategoryId, type, isValidDayTrip, isValidAccommodation, isValidDomestic, isValidForeignTravel, requiresZone, requiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TravelExpenserateApi - factory interface
 * @export
 */
exports.TravelExpenserateApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Get travel expense rate by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TravelExpenserateApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find rates corresponding with sent data.
         * @param {string} [rateCategoryId] Equals
         * @param {string} [type] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [isValidForeignTravel] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [requiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (rateCategoryId, type, isValidDayTrip, isValidAccommodation, isValidDomestic, isValidForeignTravel, requiresZone, requiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options) {
            return exports.TravelExpenserateApiFp(configuration).search(rateCategoryId, type, isValidDayTrip, isValidAccommodation, isValidDomestic, isValidForeignTravel, requiresZone, requiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TravelExpenserateApi - object-oriented interface
 * @export
 * @class TravelExpenserateApi
 * @extends {BaseAPI}
 */
var TravelExpenserateApi = /** @class */ (function (_super) {
    __extends(TravelExpenserateApi, _super);
    function TravelExpenserateApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Get travel expense rate by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateApi
     */
    TravelExpenserateApi.prototype.get = function (id, fields, options) {
        return exports.TravelExpenserateApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find rates corresponding with sent data.
     * @param {string} [rateCategoryId] Equals
     * @param {string} [type] Equals
     * @param {boolean} [isValidDayTrip] Equals
     * @param {boolean} [isValidAccommodation] Equals
     * @param {boolean} [isValidDomestic] Equals
     * @param {boolean} [isValidForeignTravel] Equals
     * @param {boolean} [requiresZone] Equals
     * @param {boolean} [requiresOvernightAccommodation] Equals
     * @param {string} [dateFrom] From and including
     * @param {string} [dateTo] To and excluding
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateApi
     */
    TravelExpenserateApi.prototype.search = function (rateCategoryId, type, isValidDayTrip, isValidAccommodation, isValidDomestic, isValidForeignTravel, requiresZone, requiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options) {
        return exports.TravelExpenserateApiFp(this.configuration).search(rateCategoryId, type, isValidDayTrip, isValidAccommodation, isValidDomestic, isValidForeignTravel, requiresZone, requiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return TravelExpenserateApi;
}(BaseAPI));
exports.TravelExpenserateApi = TravelExpenserateApi;
/**
 * TravelExpenserateCategoryApi - fetch parameter creator
 * @export
 */
exports.TravelExpenserateCategoryApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get travel expense rate category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/travelExpense/rateCategory/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find rate categories corresponding with sent data.
         * @param {string} [type] Equals
         * @param {string} [name] Containing
         * @param {number} [travelReportRateCategoryGroupId] Equals
         * @param {string} [ameldingWageCode] Containing
         * @param {string} [wageCodeNumber] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [isRequiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (type, name, travelReportRateCategoryGroupId, ameldingWageCode, wageCodeNumber, isValidDayTrip, isValidAccommodation, isValidDomestic, requiresZone, isRequiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/rateCategory";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (travelReportRateCategoryGroupId !== undefined) {
                localVarQueryParameter['travelReportRateCategoryGroupId'] = travelReportRateCategoryGroupId;
            }
            if (ameldingWageCode !== undefined) {
                localVarQueryParameter['ameldingWageCode'] = ameldingWageCode;
            }
            if (wageCodeNumber !== undefined) {
                localVarQueryParameter['wageCodeNumber'] = wageCodeNumber;
            }
            if (isValidDayTrip !== undefined) {
                localVarQueryParameter['isValidDayTrip'] = isValidDayTrip;
            }
            if (isValidAccommodation !== undefined) {
                localVarQueryParameter['isValidAccommodation'] = isValidAccommodation;
            }
            if (isValidDomestic !== undefined) {
                localVarQueryParameter['isValidDomestic'] = isValidDomestic;
            }
            if (requiresZone !== undefined) {
                localVarQueryParameter['requiresZone'] = requiresZone;
            }
            if (isRequiresOvernightAccommodation !== undefined) {
                localVarQueryParameter['isRequiresOvernightAccommodation'] = isRequiresOvernightAccommodation;
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TravelExpenserateCategoryApi - functional programming interface
 * @export
 */
exports.TravelExpenserateCategoryApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get travel expense rate category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TravelExpenserateCategoryApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find rate categories corresponding with sent data.
         * @param {string} [type] Equals
         * @param {string} [name] Containing
         * @param {number} [travelReportRateCategoryGroupId] Equals
         * @param {string} [ameldingWageCode] Containing
         * @param {string} [wageCodeNumber] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [isRequiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (type, name, travelReportRateCategoryGroupId, ameldingWageCode, wageCodeNumber, isValidDayTrip, isValidAccommodation, isValidDomestic, requiresZone, isRequiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TravelExpenserateCategoryApiFetchParamCreator(configuration).search(type, name, travelReportRateCategoryGroupId, ameldingWageCode, wageCodeNumber, isValidDayTrip, isValidAccommodation, isValidDomestic, requiresZone, isRequiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TravelExpenserateCategoryApi - factory interface
 * @export
 */
exports.TravelExpenserateCategoryApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Get travel expense rate category by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TravelExpenserateCategoryApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find rate categories corresponding with sent data.
         * @param {string} [type] Equals
         * @param {string} [name] Containing
         * @param {number} [travelReportRateCategoryGroupId] Equals
         * @param {string} [ameldingWageCode] Containing
         * @param {string} [wageCodeNumber] Equals
         * @param {boolean} [isValidDayTrip] Equals
         * @param {boolean} [isValidAccommodation] Equals
         * @param {boolean} [isValidDomestic] Equals
         * @param {boolean} [requiresZone] Equals
         * @param {boolean} [isRequiresOvernightAccommodation] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (type, name, travelReportRateCategoryGroupId, ameldingWageCode, wageCodeNumber, isValidDayTrip, isValidAccommodation, isValidDomestic, requiresZone, isRequiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options) {
            return exports.TravelExpenserateCategoryApiFp(configuration).search(type, name, travelReportRateCategoryGroupId, ameldingWageCode, wageCodeNumber, isValidDayTrip, isValidAccommodation, isValidDomestic, requiresZone, isRequiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TravelExpenserateCategoryApi - object-oriented interface
 * @export
 * @class TravelExpenserateCategoryApi
 * @extends {BaseAPI}
 */
var TravelExpenserateCategoryApi = /** @class */ (function (_super) {
    __extends(TravelExpenserateCategoryApi, _super);
    function TravelExpenserateCategoryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Get travel expense rate category by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateCategoryApi
     */
    TravelExpenserateCategoryApi.prototype.get = function (id, fields, options) {
        return exports.TravelExpenserateCategoryApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find rate categories corresponding with sent data.
     * @param {string} [type] Equals
     * @param {string} [name] Containing
     * @param {number} [travelReportRateCategoryGroupId] Equals
     * @param {string} [ameldingWageCode] Containing
     * @param {string} [wageCodeNumber] Equals
     * @param {boolean} [isValidDayTrip] Equals
     * @param {boolean} [isValidAccommodation] Equals
     * @param {boolean} [isValidDomestic] Equals
     * @param {boolean} [requiresZone] Equals
     * @param {boolean} [isRequiresOvernightAccommodation] Equals
     * @param {string} [dateFrom] From and including
     * @param {string} [dateTo] To and excluding
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateCategoryApi
     */
    TravelExpenserateCategoryApi.prototype.search = function (type, name, travelReportRateCategoryGroupId, ameldingWageCode, wageCodeNumber, isValidDayTrip, isValidAccommodation, isValidDomestic, requiresZone, isRequiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options) {
        return exports.TravelExpenserateCategoryApiFp(this.configuration).search(type, name, travelReportRateCategoryGroupId, ameldingWageCode, wageCodeNumber, isValidDayTrip, isValidAccommodation, isValidDomestic, requiresZone, isRequiresOvernightAccommodation, dateFrom, dateTo, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return TravelExpenserateCategoryApi;
}(BaseAPI));
exports.TravelExpenserateCategoryApi = TravelExpenserateCategoryApi;
/**
 * TravelExpenserateCategoryGroupApi - fetch parameter creator
 * @export
 */
exports.TravelExpenserateCategoryGroupApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get travel report rate category group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            var localVarPath = "/travelExpense/rateCategoryGroup/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary [BETA] Find rate categoriy groups corresponding with sent data.
         * @param {string} [name] Containing
         * @param {boolean} [isForeignTravel] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (name, isForeignTravel, dateFrom, dateTo, from, count, sorting, fields, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/travelExpense/rateCategoryGroup";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication tokenAuthScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (isForeignTravel !== undefined) {
                localVarQueryParameter['isForeignTravel'] = isForeignTravel;
            }
            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TravelExpenserateCategoryGroupApi - functional programming interface
 * @export
 */
exports.TravelExpenserateCategoryGroupApiFp = function (configuration) {
    return {
        /**
         *
         * @summary [BETA] Get travel report rate category group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            var localVarFetchArgs = exports.TravelExpenserateCategoryGroupApiFetchParamCreator(configuration).get(id, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary [BETA] Find rate categoriy groups corresponding with sent data.
         * @param {string} [name] Containing
         * @param {boolean} [isForeignTravel] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (name, isForeignTravel, dateFrom, dateTo, from, count, sorting, fields, options) {
            var localVarFetchArgs = exports.TravelExpenserateCategoryGroupApiFetchParamCreator(configuration).search(name, isForeignTravel, dateFrom, dateTo, from, count, sorting, fields, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TravelExpenserateCategoryGroupApi - factory interface
 * @export
 */
exports.TravelExpenserateCategoryGroupApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary [BETA] Get travel report rate category group by ID.
         * @param {number} id Element ID
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: function (id, fields, options) {
            return exports.TravelExpenserateCategoryGroupApiFp(configuration).get(id, fields, options)(fetch, basePath);
        },
        /**
         *
         * @summary [BETA] Find rate categoriy groups corresponding with sent data.
         * @param {string} [name] Containing
         * @param {boolean} [isForeignTravel] Equals
         * @param {string} [dateFrom] From and including
         * @param {string} [dateTo] To and excluding
         * @param {number} [from] From index
         * @param {number} [count] Number of elements to return
         * @param {string} [sorting] Sorting pattern
         * @param {string} [fields] Fields filter pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: function (name, isForeignTravel, dateFrom, dateTo, from, count, sorting, fields, options) {
            return exports.TravelExpenserateCategoryGroupApiFp(configuration).search(name, isForeignTravel, dateFrom, dateTo, from, count, sorting, fields, options)(fetch, basePath);
        },
    };
};
/**
 * TravelExpenserateCategoryGroupApi - object-oriented interface
 * @export
 * @class TravelExpenserateCategoryGroupApi
 * @extends {BaseAPI}
 */
var TravelExpenserateCategoryGroupApi = /** @class */ (function (_super) {
    __extends(TravelExpenserateCategoryGroupApi, _super);
    function TravelExpenserateCategoryGroupApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary [BETA] Get travel report rate category group by ID.
     * @param {number} id Element ID
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateCategoryGroupApi
     */
    TravelExpenserateCategoryGroupApi.prototype.get = function (id, fields, options) {
        return exports.TravelExpenserateCategoryGroupApiFp(this.configuration).get(id, fields, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary [BETA] Find rate categoriy groups corresponding with sent data.
     * @param {string} [name] Containing
     * @param {boolean} [isForeignTravel] Equals
     * @param {string} [dateFrom] From and including
     * @param {string} [dateTo] To and excluding
     * @param {number} [from] From index
     * @param {number} [count] Number of elements to return
     * @param {string} [sorting] Sorting pattern
     * @param {string} [fields] Fields filter pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpenserateCategoryGroupApi
     */
    TravelExpenserateCategoryGroupApi.prototype.search = function (name, isForeignTravel, dateFrom, dateTo, from, count, sorting, fields, options) {
        return exports.TravelExpenserateCategoryGroupApiFp(this.configuration).search(name, isForeignTravel, dateFrom, dateTo, from, count, sorting, fields, options)(this.fetch, this.basePath);
    };
    return TravelExpenserateCategoryGroupApi;
}(BaseAPI));
exports.TravelExpenserateCategoryGroupApi = TravelExpenserateCategoryGroupApi;
